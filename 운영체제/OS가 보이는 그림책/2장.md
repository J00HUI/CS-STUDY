### 🔆 os가 프로그램을 실행하는 구조
이 장에서는 os가 프로그램을 처리하는 흐름에 대해 살펴보겠습니다. 
컴퓨터에 설치된 프로그램(애플리케이션)은 보통 하드디스크 안에 있지만, os가 프로그램을 실행할 때는 이것을 메모리로 읽어드린(로드한)후에 실행합니다. 
이 메모리상에 할당된 프로그램을 '프로세스'라고 합니다.
프로세스에는 '실행 상태', '실행 가능 상태', '대기 상태'가 있으며, 상황은 시시각각으로 변합니다.
프로세스가 cpu에 할당되어 처리 중인 상태가 '실행 상태'입니다.
또한, 프로세스는 우선순위가 높은 처리에 의해 중단되는 일도 있습니다. 이것을 '인터럽트(interrupt) 처리'라고 합니다.

os에는 일정한 성능과 안전성이 요구되는데, 이런 것이 달성되어 있는지 아닌지를 평가하기 위한 지침으로 RASIS가 있습니다.
RASIS란,
Reliability : 신뢰성, 고장이 일어나기 어려우며 신뢰할 수 있을 것
Availability : 가용성, 기동률이 높으며 언제나 사용할 수 있을 것
Serviceability : 보수성, 고장 예방 및 수리에 신속히 복구할 수 있을 것
Integrity : 보전성, 시스템 장애나 조작 실수로 의해 고장 나기 어려울 것
Security : 안전성, 부정 액세스 등에 대한 기밀 보안 유지가 가능할 것

> 용어 설명
* 프로세스 (process) : 프로그램의 실행 단위로, 메모리상에 할당된 프로그램을 말한다.
* 인터럽트 (interrupt) : 실행 중인 프로그램을 중단하고 우선순위가 높은 다른 프로그램에게 cpu를 할당하여 실행하는 것을 말한다.

### 🏷️ 멀티태스킹
os가 cpu에게 의뢰하는 작업 단위를 '태스크(task)' 라고 합니다. 대부분의 경우, 프로세스와 동일한 의미로 생각해도 무방합니다.
주요 os는 여러 개의 태스크를 동시에 처리하는 능력을 갖고 있는데, 이것을 '멀티태스킹(multi-tasking)'이라고 합니다. 
ex) 파일을 다운로드하면서, 문서를 작성할 수 있습니다.

'동시에 처리'한다고 했지만, 실제로는 os가 cpu에게 태스크를 순서대로 할당하는 것입니다.
이때 할당 순서를 정하는 것을 '스케줄링'이라고 합니다. 이 전환이 아주 빠른 속도로 수행되므로, 마치 여러 개의 태스크가 동시에 움직이는 것처럼 보일 뿐입니다.

프로세스가 메모리와 같은 공유 자원을 이용할 때는 여러 개의 프로세스가 같은 시기에 변경되지 않도록 일시적으로 자원을 점유(잠금:lock) 하는 일도 발생합니다.
2개의 프로세스가 공유 자원을 잠근 채로 서로의 공유 자원에 액세스하기 위해 기다릴 때, 양쪽 프로세스가 둘 다 영구적으로 대기상태가 되는 것을 데드락(dead lock)이라고 합니다. 

이러한 데드락의 발생을 피하기 위한 세마포나 뮤텍스라는 배타 제어 장치가 마련되어 있습니다.

이렇게 os는 cpu와 태스트가 효율적으로 기능하도록 관리하고 있습니다.

> 용어 설명
* 멀티 태스킹(multi-tasking) : os 관리하에 여러 개의 테스크(프로세스)가 병행하여 작동하는 것으로, 태스크를 순서대로 cpu에 할당하고 있기 때문에 여러 개의 테스크가 동시에 작동하는 것처럼 보인다.
* 스케줄링(scheduling) : os 가 여러개이 프로세스를 처리할 때 cpu에게 할당할 순서를 정하는 것이다.
</br>

## 💎 01 잡과 태스크
컴퓨터의 기본적인 처리를 나타내는 용어를 소개합니다.

### 잡
사용자(인간) 입장에서 보았을 때, 컴퓨터에게 시키는 일의 단위를 '잡(job)'이라고 합니다.
잡 안에는 여러 프로그램의 실행이 포함됩니다.

### 잡 관리
os는 잡의 실행 순서와 잡이 정상적으로 처리되고 있는지를 관리합니다.
잡을 작게 나눈 단위를 '잡 스텝(job step)'이라고 합니다.

* 잡을 실행순으로 나열합니다.
* 잡 스텝을 순서대로 처리합니다.
* 잡의 상태를 기록합니다. ex) 잡 A 정상, 잡 B 정상, 잡 C 오류 ...

```
NOTE_ 잡의 실행 방법을 지정하는 언어를 '잡 제어 언어(JCL)'라고 해요.
```
### 태스크
태스크는 os 입장에서 본 작업 단위입니다. os는 잡 스탭을 태스크로 분해하여 cpu에게 처리를 의뢰합니다.
```
NOTE_프로세스나 스레드를 태스크라고 부르기도 해요.
```

### 태스크 관리
os는 잡 관리로부터 넘겨받은 테스크의 상태를 관리하거나 cpu의 처리 할당을 수행합니다.
* 테스크를 생성합니다.
* 테스크의 처리를 cpu에게 의뢰합니다.
* 처리가 종료되면 테스크는 소멸됩니다.


## 💎 02 스루풋

### 스루풋
os의 단위 시간당 처리량을 스루풋(throughput)이라고 합니다.

스루풋 높음 : 작업이 원활하게 진행됩니다.
낮음 : 작업이 원활하게 진행되지 않습니다.
```
NOTE_ 스루풋이 높으면 처리 효율이 좋아져요.
```

### 리스폰스 타임과 턴어라운드 타임
os가 잡을 처리하는 시간은 다음과 같이 분류됩니다.

IMG_4436.JPG![IMG_4436](https://user-images.githubusercontent.com/83942393/125607580-df08b2e7-2eca-4bbb-91e0-c926ff733d5e.JPG)

### 스풀
cpu로부터 입출력 장치로 가는 명령을 메모리와 같이 비교적 고속인 기억 장치에 일시적으로 저장하는 것을 '스풀(spool)'이라고 합니다.
ex) 프린터는 cpu와 비교해서 처리 속도가 느리므로, 스풀을 사용하여 cpu의 처리와 입출력 동작의 처리이 차이를 완화시킬 수 있습니다.

![image](https://user-images.githubusercontent.com/83942393/125607865-ecebfbca-4c25-4d95-bb9a-baf00f1f0957.png)

## 💎 03 인터럽트 1

### 인터럽트
실행 중인 프로그램을 중단하고 우선순위가 높은 다른 프로그램에게 cpu를 할당하여 실행하는 것.
인터럽트에는 내부 인터럽트(소프트웨어 인터럽트)와 외부 인터럽트(하드웨어 인터럽트)가 있습니다.

IMG_4438.jpg![IMG_4438](https://user-images.githubusercontent.com/83942393/125608594-b69c1ce1-d085-4ea9-b8a3-1dc3c82629dd.jpg)

### 내부 인터럽트
내부 인터럽트는 실행 중인 프로그램이 원인이 되어 일어나는 인터럽트입니다.

* 프로그램 인터럽트
  * 오버플로어(overflow: 계산 시 자리 넘침)로 인해 쓰기가 허가되지 않은 메모리 영역에 액세스했을 때 프로그램 인터럽트가 발생 (오버플로어가 발생한 것을 os에게 알립니다.)
  * 페이지 폴트(page fault) : 무효한 메모리를 참조한다.
  * 트레이스(tace) : 디버그를 위해 프로그램을 한 명령씩 실행한다.
  * 슈퍼바이저 콜(superviser call) : 시스템 콜을 실행한다.
  * 명령 코드 이상 : 무효한 명령을 실행한다.

## 💎 04 인터럽트 2

### 외부 인터럽트
주변기기의 입출력 동작이나 하드웨어 고장, 오작동으로 인해 일어나는 인터럽트입니다.

* 기계 체크 인터럽트 : 전원 이상이나 하드웨어에 장애가 발생했을 때 기계 체크 인터럽트가 발생. 인터럽트 중에서 가장 우선시됩니다.
* 타이머 인터럽트 : 일정 시간 또는 일정 시간마다 하드웨어로부터 발생하는 인터럽트, 설정 시간이 경과했다는 것을 os에게 알려 다음 태스크를 실행합니다.
* 입출력 인터럽트 : 주변 기기의 입출력 동작이 완료되었을 때와 같이 상태가 변화했을 때 발생합니다.
  * 입출력 동작의 상태가 변했다는 것을 os에게 알립니다.
  * 프린터의 용지가 떨어졌을 때도 입출력 인터럽트가 발생합니다.
* 콘솔 인터럽트 : 사용자가 키보드와 같은 입출력 장치를 조작하면 콘솔 인터럽트가 발생합니다.
  * ex) 사용자로부터 입력이 있었다는 것을 os에게 알립니다.

## 💎 05 프로세스란?
### 프로세스
사용자가 프로그램을 실행하면 os는 그 내용을 메모리상으로 읽어들여 처리를 실행합니다.
이 메모리에 할당된 프로그램을 '프로세스(process)'라고 합니다.
하나의 프로그램으로부터 여러 개의 프로세스를 만들 수 있습니다.

NOTE_ 프로세스를 프로그램의 인스턴스(실체)라고도 해요.

## 멀티태스킹
os 관리하에서 여러 개의 태스크(프로세스)가 병행하여 작동하는 것을 '멀티태스킹'이라고 합니다.
태스크를 순서대로 cpu에 할당하고 있기 때문에 여러 개의 태스크가 동시에 작동하고 있는 것처럼 보입니다.
태스크 전환에는 약간의 시간(오버헤드)이 걸립니다.

## 시분할 처리 시스템 (time sharing system)
여러 사용자가 한 대의 고성능 컴퓨터를 공유하여 사용할 때 , cpu의 사용 권한을 사용자에게 순서대로 단시간 할당하는 시스템

NOTE_ 사용자에게는 마치 자신이 컴퓨터를 점유하고 있는 것처럼 보여요.

## 💎 06 프로세스 관리
os가 프로세스를 어떻게 관리하는지에 대해 살펴봅시다.

### 프로세스 상태
프로세스에는 '대기 상태', '실행 가능 상태', '실행 상태'와 같은 세 가지 상태가 있는데, 프로세스는 이런 상태를 옮겨가면서 실행됩니다.
![image](https://user-images.githubusercontent.com/83942393/125613118-87df6bb1-1225-4a8f-b585-530f61158f45.png)
* 입출력 종료, 깨움 : 입출력 인터럽트
* 선점, 시간초과 : 프리엠션

### 디스패치와 프리엠션
os가 가장 우선순위가 높은 실행 가능 상태의 프로세스에 대해 cpu의 사용 권한을 할당하는 것을 '디스패치(dispatch)'라고 합니다.
또한 인터럽트에 의해 cpu의 할당을 해제하는 것을 '프리엠션(preemption)'이라고 합니다.

NOTE_ 프리엠션은 '가로채기'라는 뜻이예요.

## 💎 07 멀티태스킹의 종류
### 프리엠티브
os가 실행 가능 상태인 태스크에게 cpu의 사용권을 할당하고 **강제적** 으로 태스크를 전환하여 관리하는 것을 '프리엠티브 멀티태스킹(preemptive multitasking)'이라고 합니다.
* 타임 슬라이스 : cpu의 사용 권한을 할당하는 단위 시간
* 현재는 프리엠티브 멀티 태스킹이 주류입니다.

### 논프리엠티브
실행 중인 태스크가 처리를 수행하지 않는 시간을 **자발적** 으로 해제함으로써 다른 태스크와 동시에 실행할 수 있도록 하는 것을 '논프리엠티브 멀티태스킹(non-preemptive multitasking)'이라고 합니다.
* 태스크가 종료될 때까지 cpu의 사용 권한을 다른 태스크에게 양보하지 않습니다.
* cpu를 해제하지 않는 태스크가 있으면 os 전체의 동작이 정지되는 경우도 있습니다.

![image](https://user-images.githubusercontent.com/83942393/125613925-7d83f8fb-f06e-484a-bffa-6f546b8ba049.png)

## 💎 08 프로세스 제어

### 프로그램 상태어(psw : program status word)
인터럽트로 인해 중단된 프로그램의 상태나 연산의 종료 상태를 저장해 두는 레지스터를 '프로그램 상태어'라고 합니다.
* 인터럽트의 상태나 중단된 명령
* 연산 ex) 자리올림이 발생하는 등 연산 결과의 상태

### 프로세스 제어 블럭(pcb : process control block)
각 프로세스의 cpu 상태(컨텍스트)나 프로세스의 상태를 저장해 두는 메모리 영역을 말합니다.
![image](https://user-images.githubusercontent.com/83942393/125614409-069efe9e-a739-4b62-9a92-25dea3d7a9b2.png)

### 컨텍스트 스위치
인터럽트로 인해 프로세스를 전환할 때 os 가 컨텍스트를 pcb에 저장하고 복원하는 것을 '컨텍스트 스위치'라고 합니다.

## 💎 09 스케줄링
프로세스의 실행 순서는 os가 관리합니다.

### 스케줄링
os가 여러 개의 프로세스를 처리할 때 cpu를 할당할 순서를 정하는 것을 '스케줄링(scheduling)'이라고 합니다.
스케줄링을 하기 위한 소프트웨어를 '스케줄러'라고 합니다.

![image](https://user-images.githubusercontent.com/83942393/125614945-053fef14-f8e7-4928-9dff-044ba924d276.png)

### 스케줄링의 종류
* 라운드 로빈 방식(round robin scheduling)
  * 프로세스가 기다리고 있는 순서대로 일정 시간씩 cpu를 할당해서 시간이 초과한 프로세스를 맨 마지막으로 돌리는 방식 
* 우선순위 방식
  * os가 프로세스의 우선순위를 정해서 우선순위가 높은 프로세스부터 실행해 나가는 방식
  * 많은 os가 이 우선순위 방식을 채택하고 있습니다.
  * 우선순위 방식에서는 데드락이 발생하는 경우가 있어요.

## 💎 10 프로세스의 분기
프로세스의 일을 분담하여 작업 효율을 올리는 방법을 UNIX 환경을 예로 들어 살펴봅시다.

### fork와 exec
* unix 계열 os에서 시스템 콜에 의해 프로세스를 복사하는 것을 'fork'라고 합니다.
* 복사되는 쪽을 '부모 프로세스', 복사된 쪽을 '자식 프로세스'라고 합니다.
* 자식 프로세스에서 다른 프로그램을 실행하도록 지시하는 것을 'exec'라고 합니다.

IMG_4441.JPG![IMG_4441](https://user-images.githubusercontent.com/83942393/125615876-f9e3582f-58cf-4d59-8784-9275df2c825c.JPG)

### wait
자식 프로세스의 처리가 끝나면, 부모 프로세스에게 신호(시그널)가 보내지므로, 이것을 기다림으로써 부모는 자식 프로세스의 종료까지 대기할 수 있습니다.
그 후에 wait 시스템 콜에 의해 자식 프로세스에게 마련되었던 Pcb와 메모리가 제거됩니다.
IMG_4442.JPG![IMG_4442](https://user-images.githubusercontent.com/83942393/125616048-8adf2c6d-7a11-4e38-b11f-4444ac02911c.JPG)
NOTE_ 부모 프로세스는 하나의 wait 처리가 완료될 떄까지 다른 자식 프로세스의 종료 시그널을 받을 수 없어요.

## 💎 11 프로세스의 동기
파일이나 데이터베이스와 같은 자원을 동시에 다룰 때는 주의가 필요합니다.

### 배타 제어
* 여러 개의 프로세스가 파일이나 데이터베이스에 동시에 액세스하면 데이터의 무결성이 손상될 수 있습니다.
* 처리가 끝날 때까지 하나의 프로세스에게 자원을 독점시키는 것을 '배타 제어'라고 합니다.

IMG_4447.jpg![IMG_4447](https://user-images.githubusercontent.com/83942393/125616807-2d2e7b8f-749d-47df-8d26-70f8bf777160.jpg)

NOTE_ 실행이 동시에 일어나면 결과가 달라져요.

### 세마포 (semaphore)
정해진 수 이상의 프로세스가 공유 자원에 동시 액세스하지 않도록 카운터를 사용하여 제어하는 장치
os 는 세마포의 p 조작(획득) 과 v 조작(해제)으로 '통행 가능', '통행 불가' 와 같은 두 가지 상태를 관리합니다.
ex) 세마포의 카운터가 초기값을 '2'로 한 경우
프로세스 A, 프로세스 B, 프로세스 C 순으로 P 조작을 수행한다면

IMG_4448.jpg![IMG_4448](https://user-images.githubusercontent.com/83942393/125617002-ba8f9e75-39d4-4de5-85be-883c1ced93cc.jpg)

NOTE_ 프로그램 중 배타 제어가 필요한 부분(P 조작부터 V 조작까지의 처리)를 '크리티컬 섹션'이라고 해요.

## 💎 12 데드락
배타 제어에서는 데드락에 주의해야 합니다.

### 데드락 (dead lock)
2개의 프로세스가 공유 자원을 잠근 채로 서로의 공유 자원에 액세스하려고 하면, 양쪽 프로세스가 모두 영구적으로 대기 상태가 되는 것
IMG_4449.jpg![IMG_4449](https://user-images.githubusercontent.com/83942393/125617361-45272751-c9eb-4292-8c4f-827690dd6780.jpg)

### 뮤텍스
데드락을 피하기 위한 방법에는 '세마포'와 '뮤텍스'가 있습니다.
이 중 '뮤텍스(mutex)'는 카운터 초기값이 1인 경우와 똑같은 뜻입니다.
IMG_4450.JPG![IMG_4450](https://user-images.githubusercontent.com/83942393/125617501-2a178f7f-871d-4c99-803c-c7921d568e96.JPG)

NOTE_ 여러 개의 프로세스에 의한 공유 자원 경쟁이 없어지므로 배타 제어에 적합해요.

## 💎 13 프로세스 간 통신
### 프로세스 간 통신
프로세스끼리는 다른 메모리 공간을 참조하기 때문에, 서로 어떤 데이터를 갖고 있는지 알 수 없습니다.
os에는 프로세스끼리 통신을 해서 데이터를 주고받는 기능이 마련되어 있습니다.
unix 계열 os를 예로 프로세스 간 통신의 종류를 소개합니다.

* 메시지 큐
  * 프로세스끼리는 os의 메시지 기능을 사용하여 1대 1로 통신할 수 있습니다.
  * 메시지를 넣는 장소를 '메시지 큐'라고 합니다.

* 파이프
  * 여러 개의 프로세스 입출력을 연결하는 장치를 '파이프'라고 합니다.
  * 파이프는 fork한 부모 자식 프로세스 간에 사용됩니다.

NOTE_ 파이프는 일방통행이기 때문에 상대 프로세스별로 파이프가 달라요.

* 이름 붙은 파이프
  * 파이프에 이름을 붙임으로써 부모 자식 프로세스가 아니어도 프로세스 간 통신을 할 수 있습니다.
  ex) 파이프 'FROM A' , 파이프 'FROM B'
  
## 💎 14 공유 메모리와 스레드

### 공유 메모리
* 여러 개의 프로세스에서 공통으로 사용할 수 있는 메모리 영역이며, 시스템 콜에 의해 작성됩니다.
* 공유 메모리에 접속하는 것을 '어태치(attach)', 끊는 것을  디태치(detach'라고 합니다.

IMG_4452.jpg![IMG_4452](https://user-images.githubusercontent.com/83942393/125618753-7a793006-929f-4615-b575-6badb7c57aa6.jpg)

### 스레드 (thread)
* 프로세스 안의 프로그램 실행의 흐름
* 스레드는 분기가 가능해서 여러 개의 스레드를 동시에 실행할 수 있습니다.
* 이것을 멀티 스레드(multi-thread)라고 합니다.
* cpu를 사용하는 최소 단위
* '라이트 웨이트 프로세스(light weight process)'라고도 부릅니다.
IMG_4454.JPG![IMG_4454](https://user-images.githubusercontent.com/83942393/125619768-70533305-b5af-453a-bd81-89561a41d153.JPG)

### 스레드와 프로세스의 차이
스레드가 프로세스를 동시에 여러 개 실행하는 것과 다른 점은 동일한 프로세스의 스레드는 같은 메모리 공간을 참조한다는 점입니다.

![image](https://user-images.githubusercontent.com/83942393/125618527-e0652210-9dce-4b80-877e-6331e01a1947.png)
