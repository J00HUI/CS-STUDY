## 03 운영체제의 발전 과정과 유형

운영체제의 발전 과정을 살펴봄으로써 운영체제의 공통 요소와 운영체제가 어떻게, 왜 개발 되어 왔는지 이해할 수 있다. 특히 운영체제와 하드웨어는 서로 밀접하게 연관되어 있으므로 하드웨어의 발전과 함께 살펴보자.

### 1. 운영체제의 발전 과정
컴퓨터 시스템의 성능을 향상시키려고 운영체제는 계속 발전해 왔다. 그 발전 과정을 하나씩 살펴보면 현재 사용 중인 운영체제의 기능이 탄생한 배경을 이해할 수 있을 것이다. 운영체제의 발전 과정과 핵심 특징을 연도별로 정리하면 다음과 같다.
</br>
| 연도 | 운영체제 | 특징 |
|:----------|:----------|:----------|
| 1940년대 | 운영체제 없음(작업별 순차 처리) | * 기계어를 직접 사용 </br> * 단순 순차(직렬 처리) |
| 1950년대 | 일괄 처리 시스템 | * 작업별로 일괄 처리 </br> * 버퍼링, 스풀링 방법 등장 |
| 1960년대 | * 다중 프로그래밍 시스템 </br> * 시분할 시스템 </br> * 다중 처리 시스템 </br> * 실시간 처리 시스템 | * [가상 기억장치](https://github.com/ERIN56/CS-STUDY/blob/master/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/C02%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98%20%EC%86%8C%EA%B0%9C/%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC.md) 등장 </br> * 다중 프로그래밍, 다중 처리, 시분할 처리 등 개념 등장 </br> * 운영체제를 고급 언어로 작성 </br> * `데이터 통신 지원용 운영체제` 사용 |
| 1970년대 초반| * 다중 모드 시스템 </br> * 범용 시스템 | * 일괄 처리, 시분할 처리, 다중 프로그래밍 등을 제공하는 다중 모드 시스템 등장 </br> * 장치의 독립성 제공 </br> * TCP/IP 통신 표준 활성화 </br> * 운영체제가 네트워크와 보안을 아우르는 수준으로 발전 |
| 1970년대 중반 | 분산 처리 시스템 | * 각종 응용 프로그램 개발 및 데이터베이스 활용 확대 </br> * 네트워크 기술의 발전 </br> * 하드웨어에 운영체제 개념이 포함된 펌웨어 개념 등장 |
| 1990년대 | 병렬 계산과 분산 게산 | * 월드와이드웹의 등장으로 분산 컴퓨팅 증가 </br> * GUI 강화 </br> * 개인용과 서버용 운영체제의 보편화 |
| 2000년대 이후 | * 모바일 및 임베디드 </br> * 가상화 및 클라우드 컴퓨팅 | * 네트워크 기반의 분산 및 병렬 운영체제의 보편화 </br> * 모바일 장치와 가전제품을 위한 모바일 및 임베디드 운영체제의 보편화 </br> * 다양한 기능, 확장성과 호환성 극대화 </br> * 다양한 통신망의 확대와 개발형 시스템 발달 </br> * 여러 운영체제가 한 시스템의 자원을 공유할 수 있게 해주는 서버 가상화 기술의 확산 </br> * 컴퓨팅 자원, 스토리지, 소프트웨어 등을 사용자에게 서비스 형태로 제공하는 클라우드 컴퓨팅의 등장 |
</br>

```
NOTE_ 개인용 컴퓨터
하드웨어 가격이 저렴해지면서 컴퓨터 시스템 하나를 한 명이 사용하는 것이 일반화되었는데, 이를 개인용 컴퓨터 PC(personal Computer) 라고 한다.
처음에는 다중 사용자나 다중 작업이 필요 없었으나, 사용자의 편리함과 빠른 응답을 제공하려고 다중 작업, 다중 사용자 환경으로 변했다.
```
</br>

### 1.1 1940년대 : 운영체제 없음(작업별 순차 처리)
  * 사용자가 기계어로 직접 프로그램을 작성하여 실행하는 작업별 순차 처리 시스템을 사용 , 운영체제 개념이 존재 X
  * 컴퓨터에 필요한 모든 작업을 프로그램에 담았다.    
  ``` 
  ex. 
  카드 판독기에 판독의 시작, 종료 시점, 데이터 해석 방법 등을 포함하고, 프로세서에는 명령어 저장 방법, 계산 대상, 결과 저장 위치와 방법, 
  출력 시점과 위치 등을 모두 명령어로 명시적으로 표현했다.
  ```
  * 모든 작업을 예약으로 진행하여 문제가 발생 
  ```
  ex. 
  컴퓨터에 결함이 발생하여 예약한 1시간을 넘기면 하던 일을 멈추고 다른 사용자에게 넘겨주고 내 차레가 올 떄까지 기다려야 한다. 반대로 더 일찍 마치면
  나머지 시간은 비어 있어 시간 낭비된다.
  ```
  </br>
  
 ### 1.2 1950년대 : 일괄 처리 시스템
 * 초기 운영체제인 일괄 처리 시스템(batch processing system)은 작업을 올리는 시간과 해제하는 시간 낭비를 줄이는 데 관심을 두었다. 그래서 데이터가 발생할 때마다 즉시 처리하지 않고, 일정 기간 또는 일정량이 될 때까지 모아두었다가 한꺼번에 처리하여 작업 준비 시간을 줄였다. 이를 위해 일괄 처리, 버퍼링, 스풀링 등 방법을 도입했다.

 ◾ 일괄 처리
   * 직렬 처리 기술과 동일
   * 사용자가 펀치 카드와 같은 오프라인 장치에 작업을 저장하여, 처리 시스템인 오퍼레이터에 제출한다.
   * 그러면 오퍼레이터에서 비슷한 작업들을 그룹으로 묶어 함께 일괄 처리 한다.
   * 즉, 작업 준비 시간을 줄이려고 데이터가 발생할 때마다 즉시 처리하지 않고 데이터를 일정 기간 또는 일정량이 될 때까지 모아두었다가 한꺼번에 처리하는 것 </br></br>

   ![일괄처리](https://user-images.githubusercontent.com/83942393/124875022-617c6c80-e003-11eb-81a6-b6b176957eb5.png)
   
   * 일괄 처리의 장점
     * 많은 사용자와 프로그램이 컴퓨터 자원을 공유할 수 있다.
     * 컴퓨터 자원을 덜 사용 중일 때는 작업 처리 시간을 교대할 수 있다.
     * 시시각각 수동으로 개입하고 감독하여 컴퓨터 자원의 유휴를 피할 수 있다.
  
   * 단점
     * 준비 작업들의 유형이 동일해야 한다.
     * 작업에 모든 유형의 입력을 할 수 없다.
     * 입출력 장치가 프로세서보다 속도가 느려 프로세서가 종종 유휴 상태가 된다.
     * 작업에 우선순위를 주기가 어렵다.
  
  이 문제점을 보완하기 위해 모니터링, 버퍼링, 스풀링 등 여러 방법이 등장했다.
  </br></br>
  
 ◾ 버퍼링
 : 프로세서와 입출력장치의 속도 차이로 생긴 유휴시간이 없도록, 입출력장치별로 입출력 버퍼를 두어, 프로세서에서 연산을 할 때 동시에 다른 작업을 입출력하는 아주 간단한 방법
 
 ```
 NOTE_ 버퍼
 프로세서가 어떤 작업을 처리하는 동안 버퍼에 다음으로 처리할(또는 출력할) 작업을 미리 읽어 저장해 두는 메모리이다.
 ```
 
  * 프로세서가 연산을 시작하기 직전, 입력장치가 다음 입력을 즉시 받아들이도록 명령 -> 프로세서와 입력장치가 동시에 가동
  * 프로세서가 다음 데이터를 준비하고 있을 때 입력장치가 입력을 하면, 프로세서는 데이터를 바로 처리 + 입력장치는 다음 데이터를 읽어 드림 -> 시스템 성능 향상
  * 출력도 이와 비슷한 버퍼링을 수행
  * 출력장치가 데이터를 받아들일 동안 프로세서가 데이터를 생성하여 버퍼에 넣는다. </br></br>
  <img src="https://user-images.githubusercontent.com/83942393/124877893-81615f80-e006-11eb-88db-84560db80d5a.jpeg" width="50%" height="50%"></img></br></br>
  
  ◾ 스풀링(spooling)
  : 속도가 빠른 디스크를 버퍼처럼 사용하여 입출력장치에서 미리 읽는 것이다. 버퍼링이 컴퓨터 하드웨어의 일부인 버퍼를 사용한다면, 스풀링은 별개의 오프라인 장치를 사용한다는 점이 다르다. 
  
  * 버퍼링이 하나의 입출력 작업과 그 작업의 계산만 함꼐 할 수 있는 반면에, 
  * 스풀링은 여러 작업의 입출력과 계산을 함께 할 수 있다.
  * 스풀링은 프로세서에 일정한 디스크 공간과 테이블만 있으면, 하나의 계산 작업과 다른 입출력 작업을 중복해서 처리할 수 있으므로, 성능에 직접적으로 도움을 준다.
  * 이처럼 스풀링은 프로세서와 입출력장치가 고효율로 작업할 수 있도록 한다.
  * 특히, 프로세서 중심 작업과 입출력 중심 작업이 혼합된 경우에 더 좋다. </br></br>
<img src="https://user-images.githubusercontent.com/83942393/124879156-e49fc180-e007-11eb-8af3-12799c491de7.png" width="50%" height="50%"></img></br></br>
  
  ### 1.3 1960년대 : 다중 프로그래밍, 시분할, 다중 처리, 실시간 시스템
  : 이 시기 운영체제의 특징은 장치 독립성을 이용한 편리한 하드웨어 관리와 다중 프로그래밍, 시분할, 다중 처리, 실시간을 이용한 시스템의 처리 능력 향상이다.
  
  * 다중 프로그래밍 시스템
    * 여러 프로그램을 메모리에 나눠 적재한 후 프로세서를 번갈아 할당하여 프로세서의 사용을 극대화하면서, 여러 프로그램을 동시에 실행
  * 시분할 시스템
    * 다중 프로그래밍 시스템에 프로세서 스케줄링 이라는 개념을 더한 것. 
    * 일정한 프로세서 사용 시간을 할당하여 빠른 응답이 가능하므로, 사용자와 대화하는 방법으로 여러 프로그램을 실행한다.
  * 다중 처리 시스템
    * 하나의 시스템에서 프로세서를 여러 개 사용하여 처리 능력을 높인 것
  * 실시간 처리 시스템
    * 즉시 응답

``` 
NOTE_ 장치의 독립성
프로그램을 특정의 입출력 장치를 전제로 하지 않아, 다른 입출력장치와 함께 실행할 수 있는 것이 장치 독립성의 개념이다. 
예를 들어, 어떤 때에는 자기 테이프를 사용하고, 다른 때에는 자기 디스크를 사용하는 것과 같이, 입출력 장치를 동적으로 사용할 수 있다.
```
</br>

이 시기에 미항공상의 SABRE 예약 시스템을 개발했다. 이 시스템은 멀리 떨어진 사용자가 단말기를 이용하여 중앙 컴퓨터 시스템과 통신하는 트랜잭션 처리 시스템의 효시이다.   
트랜잭션 처리 시스템은 사용자와 컴퓨터 시스템이 서로 대화를 하되, 사용자의 비교적 간단한 요구에 컴퓨터가 빠르게 응답하는 것이다. 역서 사용자 단말기를 컴퓨터의 온라인이라고 한다.   

</br>

 ### 1.4 1970년대 초반 : 다중모드, 범용 시스템
 * 모든 사용자에게 모든 기능을 제공할 수 있도록 범용 시스템으로 설계
 * 일괄 처리, 시분할 처리, 실시간 처리, 다중 처리를 모두 제공하는 다중 모드 시스템도 등장
 * 해당 기능이 필요 없는 사용자에게도 동일한 모든 기능을 제공하여 , 실행 시간의 과부하가 발생
 * 시스템을 이해하기 위해선 고도의 훈련이 필요
 * 오류가 발생하면 수정하는 데 시간이 오래 걸렸으며, 시스템 유지 비용이 늘어나는 등 문제 발생

```
NOTE_범용
널리 여러 용도로 쓰인다. 스마트폰은 더 이상 임베디드 시스템 보다는 범용 시스템에 가까워지고 있다.
```
</br>

### 1.5 1970년대 중반~1990년대 : 분산 처리 시스템, 병렬 계산과 분산 계산
 * 컴퓨터 네트워크와 온라인 처리 방법을 널리 사용
 * 네트워크를 이용하여 멀리 떨어진 컴퓨터를 사용할 수 있고, 마이크로프로세서가 등장하여 개인용 컴퓨터를 가질 수 있게 됨
 * 사용자가 지역적으로 멀리 떨어진 여러 시스템과 통신할 수 있어, 정보 보호가 중요한 관심사가 됨
 * 1970년대 명렁어 중심의 시스템 사용법이 1980년대 사용자에게 편리한 메뉴 지향적인 시스템으로 대체되었고, 1990년대 GUI 시스템으로 발전
 * 분산 처리 개념을 확립하여, 컴퓨터가 있는 곳으로 데이터를 가져가 처리하기 보다는 데이터가 발생하는 곳으로 컴픂터의 능력을 가져오는 데 관심을 갖게 됨
</br>

###  1.6 2000년대 이후 : 모바일 및 임베디드, 가상화 및 클라우드 컴퓨팅
 * 모바일 운영체제 : 노키아의 심비안, 구글의 안드로이드, 애플의 iOS, RIM의 블랙베리 OS, 마이크로소프트의 윈도우 등
 * 각종 사물에 컴퓨터 칩과 통신 기능을 내장하여 인터넷에 연결하는 사물인터넷(IoT, Internet of Things) 기술이 등장
 * 1960년대 후반 등장한 가상화 기술이 본격적으로 확산 (가상화 : 물리적 자원을 추상화하여 논리적 자원 형태로 표현하는 기술)
 </br>

 * 가상화는 적용 대상에 따라 서버 가상화, 데스크톱 가상화, 스토리지 가상화, 네트워크 가상화, 소프트웨어 가상화로 구분
 * 이 중 운영체제와 관련된 가상화 핵심은 서버 가상화
 </br>
 
 * 서버 가상화 : 물리적 서버 하나에 가상 서버를 여러 개 구성하는 방법
 * 서버 하나에서 각 응용 프로그램과 운영체제를 독립된 환경으로 사용할 수 있어, 여러 운영체제가 한 시스템의 자원을 공유할 수 있다.
 </br>
 
![서버 가상화](https://user-images.githubusercontent.com/83942393/124884007-d86a3300-e00c-11eb-99fb-3f7ead85f15e.png)</br>
![image](https://user-images.githubusercontent.com/83942393/124905307-e0cc6900-e020-11eb-8b16-7850186933b4.png)

  ```
  NOTE_하이퍼 바이저(Hypervisor)
  프로세서나 메모리 같은 다양한 컴퓨터 자원에 서로 다른 각종 운영 체계(OS)의 접근 방법을 통제하는 얇은 계층의 소프트웨어. 
다수의 OS를 하나의 컴퓨터 시스템에서 가동할 수 있게 하는 소프트웨어로 중앙 처리 장치(CPU)와 OS 사이에 일종의 중간웨어로 사용되며,
하나의 컴퓨터에서 서로 다른 OS를 사용하는 가상 컴퓨터를 만들 수 있는 효과적인 가상화 엔진이다.
  ```
  가상화 방법에 따라
  1. 호스트 운영체제에서 가상 머신을 구동하는 호스트 기반 가상화
  2. 호스트 운영체제 설치 전에 가상화 솔루션을 탑재하여 가상의 CPU, 메모리, 디스크, 네트워크 카드 등을 생성하는 베어메탈(bare-metal) 기반 가상화로 분류 
  </br>
<img src="https://user-images.githubusercontent.com/83942393/124902903-5aaf2300-e01e-11eb-9b60-400d71c22cb8.png" width="70%" height="70%"></img></br>
</br>

  (a) 호스트 기반 가상화</br></br>
  ![image](https://user-images.githubusercontent.com/83942393/124902444-e6747f80-e01d-11eb-9eec-60016be4c4d8.png)</br>
  </br>
  호스트형 하이퍼바이저는 일반적인 소프트웨어처럼 호스트 OS 위에서 실행됩니다.</br>
  하드웨어 자원을 VM 내부의 게스트 OS에 에뮬레이트 하는 방식이기 때문에, 네이티브 방식에 비해 오버헤드가 크지만, 게스트 OS 종류에 대한 제약이 없고, 데스크톱뿐만 아니라 노트북에서도 운영할 수 있습니다.
  
  (대표적으로는 VMware server, VMware Workstation, Virtual box가 있습니다.)
  
  * 장점
    * 설치가 쉽고, 구성이 편리하다.
  * 단점
    * 성능이 떨어질 수 있다.
  
  </br></br>
  (b) 베어메탈 기반 가상화 / 네이티브 or 하이퍼바이저형 (native / bare_metal or hypervisor)</br></br>
  ![image](https://user-images.githubusercontent.com/83942393/124902241-b75e0e00-e01d-11eb-969f-bbce06b2e323.png)</br>
  </br>
  하이퍼바이저가 하드웨어 바로 위에서 실행되는 방식입니다.</br>
  
  * 하이퍼바이저가 하드웨어를 직접 제어하기 때문에, 자원을 효율적으로 사용
  * 별도의 호스트 OS가 없으므로 오버헤드가 적지만, 여러 하드웨어 드라이버를 세팅해야 하므로 설치가 어렵다.
  
  (대표적으로는 Xen, 마이크로소프트 Hyper-V, KVM이 네이티브 하이퍼바이저에 속합니다.)
  
  네이티브형 하이퍼바이저는 [전 가상화(Full Virtualization), 반가상화(Para Virtualization)](https://github.com/ERIN56/CS-STUDY/blob/master/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/C02%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98%20%EC%86%8C%EA%B0%9C/%EC%84%9C%EB%B2%84%20%EA%B0%80%EC%83%81%ED%99%94.md) 방식으로 세분화할 수 있습니다.
  하이퍼바이저를 통해 가상 머신 내의 게스트 OS가 호스트 시스템을 활용한다는 점은 같지만, 하드웨어와 인터랙션하는 방식에는 차이가 있습니다.

  * 장점
    * 향상된 성능을 제공하고, 실시간 운영체제를 지원
  * 단점
    * 운영체제 위에 없기 때문에 디바이스용 드라이버, 하드웨어 플랫폼 드라이버 등을 포함해야 한다.
    * 설치와 구성이 어렵다. 


  하이퍼바이저에 의해 구동되는 VM은 각 VM별로 독립된 가상의 자원을 할당받습니다.
  VM은 논리적으로 분리되어 있어, 한 VM에 오류가 발생해도 다른 VM으로 확산되지 않는다는 장점이 있습니다.
 


### 출처
[네이버 지식백과] 장치 독립성 [device independence, 裝置獨立性, 裝置-] (IT용어사전, 한국정보통신기술협회)
[네이버 지식백과] 하이퍼바이저 [Hypervisor] (IT용어사전, 한국정보통신기술협회)
서버 가상화 https://library.gabia.com/contents/infrahosting/7426/
