## 03 운영체제의 발전 과정과 유형

운영체제의 발전 과정을 살펴봄으로써 운영체제의 공통 요소와 운영체제가 어떻게, 왜 개발 되어 왔는지 이해할 수 있다. 특히 운영체제와 하드웨어는 서로 밀접하게 연관되어 있으므로 하드웨어의 발전과 함께 살펴보자.

### 1. 운영체제의 발전 과정
컴퓨터 시스템의 성능을 향상시키려고 운영체제는 계속 발전해 왔다. 그 발전 과정을 하나씩 살펴보면 현재 사용 중인 운영체제의 기능이 탄생한 배경을 이해할 수 있을 것이다. 운영체제의 발전 과정과 핵심 특징을 연도별로 정리하면 다음과 같다.
</br>
| 연도 | 운영체제 | 특징 |
|:----------|:----------|:----------|
| 1940년대 | 운영체제 없음(작업별 순차 처리) | * 기계어를 직접 사용 </br> * 단순 순차(직렬 처리) |
| 1950년대 | 일괄 처리 시스템 | * 작업별로 일괄 처리 </br> * 버퍼링, 스풀링 방법 등장 |
| 1960년대 | * 다중 프로그래밍 시스템 </br> * 시분할 시스템 </br> * 다중 처리 시스템 </br> * 실시간 처리 시스템 | * [가상 기억장치](https://github.com/ERIN56/CS-STUDY/blob/master/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/C02%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98%20%EC%86%8C%EA%B0%9C/%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC.md) 등장 </br> * 다중 프로그래밍, 다중 처리, 시분할 처리 등 개념 등장 </br> * 운영체제를 고급 언어로 작성 </br> * `데이터 통신 지원용 운영체제` 사용 |
| 1970년대 초반| * 다중 모드 시스템 </br> * 범용 시스템 | * 일괄 처리, 시분할 처리, 다중 프로그래밍 등을 제공하는 다중 모드 시스템 등장 </br> * 장치의 독립성 제공 </br> * TCP/IP 통신 표준 활성화 </br> * 운영체제가 네트워크와 보안을 아우르는 수준으로 발전 |
| 1970년대 중반 | 분산 처리 시스템 | * 각종 응용 프로그램 개발 및 데이터베이스 활용 확대 </br> * 네트워크 기술의 발전 </br> * 하드웨어에 운영체제 개념이 포함된 펌웨어 개념 등장 |
| 1990년대 | 병렬 계산과 분산 게산 | * 월드와이드웹의 등장으로 분산 컴퓨팅 증가 </br> * GUI 강화 </br> * 개인용과 서버용 운영체제의 보편화 |
| 2000년대 이후 | * 모바일 및 임베디드 </br> * 가상화 및 클라우드 컴퓨팅 | * 네트워크 기반의 분산 및 병렬 운영체제의 보편화 </br> * 모바일 장치와 가전제품을 위한 모바일 및 임베디드 운영체제의 보편화 </br> * 다양한 기능, 확장성과 호환성 극대화 </br> * 다양한 통신망의 확대와 개발형 시스템 발달 </br> * 여러 운영체제가 한 시스템의 자원을 공유할 수 있게 해주는 서버 가상화 기술의 확산 </br> * 컴퓨팅 자원, 스토리지, 소프트웨어 등을 사용자에게 서비스 형태로 제공하는 클라우드 컴퓨팅의 등장 |
</br>

```
NOTE_ 개인용 컴퓨터
하드웨어 가격이 저렴해지면서 컴퓨터 시스템 하나를 한 명이 사용하는 것이 일반화되었는데, 이를 개인용 컴퓨터 PC(personal Computer) 라고 한다.
처음에는 다중 사용자나 다중 작업이 필요 없었으나, 사용자의 편리함과 빠른 응답을 제공하려고 다중 작업, 다중 사용자 환경으로 변했다.
```

### 1.1 1940년대 : 운영체제 없음(작업별 순차 처리)
  * 사용자가 기계어로 직접 프로그램을 작성하여 실행하는 작업별 순차 처리 시스템을 사용 , 운영체제 개념이 존재 X
  * 컴퓨터에 필요한 모든 작업을 프로그램에 담았다.    
  ``` 
  ex. 
  카드 판독기에 판독의 시작, 종료 시점, 데이터 해석 방법 등을 포함하고, 프로세서에는 명령어 저장 방법, 계산 대상, 결과 저장 위치와 방법, 
  출력 시점과 위치 등을 모두 명령어로 명시적으로 표현했다.
  ```
  * 모든 작업을 예약으로 진행하여 문제가 발생 
  ```
  ex. 
  컴퓨터에 결함이 발생하여 예약한 1시간을 넘기면 하던 일을 멈추고 다른 사용자에게 넘겨주고 내 차레가 올 떄까지 기다려야 한다. 반대로 더 일찍 마치면
  나머지 시간은 비어 있어 시간 낭비된다.
  ```
  
 ### 1.2 1950년대 : 일괄 처리 시스템
 * 초기 운영체제인 일괄 처리 시스템(batch processing system)은 작업을 올리는 시간과 해제하는 시간 낭비를 줄이는 데 관심을 두었다. 그래서 데이터가 발생할 때마다 즉시 처리하지 않고, 일정 기간 또는 일정량이 될 때까지 모아두었다가 한꺼번에 처리하여 작업 준비 시간을 줄였다. 이를 위해 일괄 처리, 버퍼링, 스풀링 등 방법을 도입했다.

 ◽ 일괄 처리
   * 직렬 처리 기술과 동일
   * 사용자가 펀치 카드와 같은 오프라인 장치에 작업을 저장하여, 처리 시스템인 오퍼레이터에 제출한다.
   * 그러면 오퍼레이터에서 비슷한 작업들을 그룹으로 묶어 함께 일괄 처리 한다.
   * 즉, 작업 준비 시간을 줄이려고 데이터가 발생할 때마다 즉시 처리하지 않고 데이터를 일정 기간 또는 일정량이 될 때까지 모아두었다가 한꺼번에 처리하는 것 </br></br>
   ![일괄처리](https://user-images.githubusercontent.com/83942393/124875022-617c6c80-e003-11eb-81a6-b6b176957eb5.png)
   
   * 일괄 처리의 장점
     * 많은 사용자와 프로그램이 컴퓨터 자원을 공유할 수 있다.
     * 컴퓨터 자원을 덜 사용 중일 때는 작업 처리 시간을 교대할 수 있다.
     * 시시각각 수동으로 개입하고 감독하여 컴퓨터 자원의 유휴를 피할 수 있다.
  
   * 단점
     * 준비 작업들의 유형이 동일해야 한다.
     * 작업에 모든 유형의 입력을 할 수 없다.
     * 입출력 장치가 프로세서보다 속도가 느려 프로세서가 종종 유휴 상태가 된다.
     * 작업에 우선순위를 주기가 어렵다.
  
  이 문제점을 보완하기 위해 모니터링, 버퍼링, 스풀링 등 여러 방법이 등장했다.
  
 ◽ 버퍼링
 : 프로세서와 입출력장치의 속도 차이로 생긴 유휴시간이 없도록, 입출력장치별로 입출력 버퍼를 두어, 프로세서에서 연산을 할 때 동시에 다른 작업을 입출력하는 아주 간단한 방법
 
 ```
 NOTE_ 버퍼
 프로세서가 어떤 작업을 처리하는 동안 버퍼에 다음으로 처리할(또는 출력할) 작업을 미리 읽어 저장해 두는 메모리이다.
 ```
 
  * 프로세서가 연산을 시작하기 직전, 입력장치가 다음 입력을 즉시 받아들이도록 명령 -> 프로세서와 입력장치가 동시에 가동
  * 프로세서가 다음 데이터를 준비하고 있을 때 입력장치가 입력을 하면, 프로세서는 데이터를 바로 처리 + 입력장치는 다음 데이터를 읽어 드림 -> 시스템 성능 향상
  * 출력도 이와 비슷한 버퍼링을 수행
  * 출력장치가 데이터를 받아들일 동안 프로세서가 데이터를 생성하여 버퍼에 넣는다.


