## 03 운영체제의 발전 과정과 유형

운영체제의 발전 과정을 살펴봄으로써 운영체제의 공통 요소와 운영체제가 어떻게, 왜 개발 되어 왔는지 이해할 수 있다. 특히 운영체제와 하드웨어는 서로 밀접하게 연관되어 있으므로 하드웨어의 발전과 함께 살펴보자.

### 1. 운영체제의 발전 과정
컴퓨터 시스템의 성능을 향상시키려고 운영체제는 계속 발전해 왔다. 그 발전 과정을 하나씩 살펴보면 현재 사용 중인 운영체제의 기능이 탄생한 배경을 이해할 수 있을 것이다. 운영체제의 발전 과정과 핵심 특징을 연도별로 정리하면 다음과 같다.
</br>
| 연도 | 운영체제 | 특징 |
|:----------|:----------|:----------|
| 1940년대 | 운영체제 없음(작업별 순차 처리) | * 기계어를 직접 사용 </br> * 단순 순차(직렬 처리) |
| 1950년대 | 일괄 처리 시스템 | * 작업별로 일괄 처리 </br> * 버퍼링, 스풀링 방법 등장 |
| 1960년대 | * 다중 프로그래밍 시스템 </br> * 시분할 시스템 </br> * 다중 처리 시스템 </br> * 실시간 처리 시스템 | * [가상 기억장치](https://github.com/ERIN56/CS-STUDY/blob/master/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/C02%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98%20%EC%86%8C%EA%B0%9C/%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC.md) 등장 </br> * 다중 프로그래밍, 다중 처리, 시분할 처리 등 개념 등장 </br> * 운영체제를 고급 언어로 작성 </br> * `데이터 통신 지원용 운영체제` 사용 |
| 1970년대 초반| * 다중 모드 시스템 </br> * 범용 시스템 | * 일괄 처리, 시분할 처리, 다중 프로그래밍 등을 제공하는 다중 모드 시스템 등장 </br> * 장치의 독립성 제공 </br> * TCP/IP 통신 표준 활성화 </br> * 운영체제가 네트워크와 보안을 아우르는 수준으로 발전 |
| 1970년대 중반 | 분산 처리 시스템 | * 각종 응용 프로그램 개발 및 데이터베이스 활용 확대 </br> * 네트워크 기술의 발전 </br> * 하드웨어에 운영체제 개념이 포함된 펌웨어 개념 등장 |
| 1990년대 | 병렬 계산과 분산 게산 | * 월드와이드웹의 등장으로 분산 컴퓨팅 증가 </br> * GUI 강화 </br> * 개인용과 서버용 운영체제의 보편화 |
| 2000년대 이후 | * 모바일 및 임베디드 </br> * 가상화 및 클라우드 컴퓨팅 | * 네트워크 기반의 분산 및 병렬 운영체제의 보편화 </br> * 모바일 장치와 가전제품을 위한 모바일 및 임베디드 운영체제의 보편화 </br> * 다양한 기능, 확장성과 호환성 극대화 </br> * 다양한 통신망의 확대와 개발형 시스템 발달 </br> * 여러 운영체제가 한 시스템의 자원을 공유할 수 있게 해주는 서버 가상화 기술의 확산 </br> * 컴퓨팅 자원, 스토리지, 소프트웨어 등을 사용자에게 서비스 형태로 제공하는 클라우드 컴퓨팅의 등장 |
</br>

```
NOTE_ 개인용 컴퓨터
하드웨어 가격이 저렴해지면서 컴퓨터 시스템 하나를 한 명이 사용하는 것이 일반화되었는데, 이를 개인용 컴퓨터 PC(personal Computer) 라고 한다.
처음에는 다중 사용자나 다중 작업이 필요 없었으나, 사용자의 편리함과 빠른 응답을 제공하려고 다중 작업, 다중 사용자 환경으로 변했다.
```
* [다중 사용자, 다중 작업, 실시간 처리](https://github.com/ERIN56/CS-STUDY/blob/master/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/C02%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98%20%EC%86%8C%EA%B0%9C/%EB%8B%A4%EC%A4%91%EC%9E%91%EC%97%85%2C%20%EB%8B%A4%EC%A4%91%20%EC%82%AC%EC%9A%A9%EC%9E%90%2C%20%EC%8B%A4%EC%8B%9C%EA%B0%84%20%EC%B2%98%EB%A6%AC.md)
</br>

### 1.1 1940년대 : 운영체제 없음(작업별 순차 처리)
  * 사용자가 기계어로 직접 프로그램을 작성하여 실행하는 작업별 순차 처리 시스템을 사용 , 운영체제 개념이 존재 X
  * 컴퓨터에 필요한 모든 작업을 프로그램에 담았다.    
  ``` 
  ex. 
  카드 판독기에 판독의 시작, 종료 시점, 데이터 해석 방법 등을 포함하고, 프로세서에는 명령어 저장 방법, 계산 대상, 결과 저장 위치와 방법, 
  출력 시점과 위치 등을 모두 명령어로 명시적으로 표현했다.
  ```
  * 모든 작업을 예약으로 진행하여 문제가 발생 
  ```
  ex. 
  컴퓨터에 결함이 발생하여 예약한 1시간을 넘기면 하던 일을 멈추고 다른 사용자에게 넘겨주고 내 차레가 올 떄까지 기다려야 한다. 반대로 더 일찍 마치면
  나머지 시간은 비어 있어 시간 낭비된다.
  ```
  </br>
  
 ### 1.2 1950년대 : 일괄 처리 시스템
 * 초기 운영체제인 일괄 처리 시스템(batch processing system)은 작업을 올리는 시간과 해제하는 시간 낭비를 줄이는 데 관심을 두었다. 그래서 데이터가 발생할 때마다 즉시 처리하지 않고, 일정 기간 또는 일정량이 될 때까지 모아두었다가 한꺼번에 처리하여 작업 준비 시간을 줄였다. 이를 위해 일괄 처리, 버퍼링, 스풀링 등 방법을 도입했다.

 ◾ 일괄 처리
   * 직렬 처리 기술과 동일
   * 사용자가 펀치 카드와 같은 오프라인 장치에 작업을 저장하여, 처리 시스템인 오퍼레이터에 제출한다.
   * 그러면 오퍼레이터에서 비슷한 작업들을 그룹으로 묶어 함께 일괄 처리 한다.
   * 즉, 작업 준비 시간을 줄이려고 데이터가 발생할 때마다 즉시 처리하지 않고 데이터를 일정 기간 또는 일정량이 될 때까지 모아두었다가 한꺼번에 처리하는 것 </br></br>

   ![일괄처리](https://user-images.githubusercontent.com/83942393/124875022-617c6c80-e003-11eb-81a6-b6b176957eb5.png)
   
   * 일괄 처리의 장점
     * 많은 사용자와 프로그램이 컴퓨터 자원을 공유할 수 있다.
     * 컴퓨터 자원을 덜 사용 중일 때는 작업 처리 시간을 교대할 수 있다.
     * 시시각각 수동으로 개입하고 감독하여 컴퓨터 자원의 유휴를 피할 수 있다.
  
   * 단점
     * 준비 작업들의 유형이 동일해야 한다.
     * 작업에 모든 유형의 입력을 할 수 없다.
     * 입출력 장치가 프로세서보다 속도가 느려 프로세서가 종종 유휴 상태가 된다.
     * 작업에 우선순위를 주기가 어렵다.
  
  이 문제점을 보완하기 위해 모니터링, 버퍼링, 스풀링 등 여러 방법이 등장했다.
  </br></br>
  
 ◾ 버퍼링
 : 프로세서와 입출력장치의 속도 차이로 생긴 유휴시간이 없도록, 입출력장치별로 입출력 버퍼를 두어, 프로세서에서 연산을 할 때 동시에 다른 작업을 입출력하는 아주 간단한 방법
 
 ```
 NOTE_ 버퍼
 프로세서가 어떤 작업을 처리하는 동안 버퍼에 다음으로 처리할(또는 출력할) 작업을 미리 읽어 저장해 두는 메모리이다.
 ```
 
  * 프로세서가 연산을 시작하기 직전, 입력장치가 다음 입력을 즉시 받아들이도록 명령 -> 프로세서와 입력장치가 동시에 가동
  * 프로세서가 다음 데이터를 준비하고 있을 때 입력장치가 입력을 하면, 프로세서는 데이터를 바로 처리 + 입력장치는 다음 데이터를 읽어 드림 -> 시스템 성능 향상
  * 출력도 이와 비슷한 버퍼링을 수행
  * 출력장치가 데이터를 받아들일 동안 프로세서가 데이터를 생성하여 버퍼에 넣는다. </br></br>
  <img src="https://user-images.githubusercontent.com/83942393/124877893-81615f80-e006-11eb-88db-84560db80d5a.jpeg" width="50%" height="50%"></img></br></br>
  
  ◾ 스풀링(spooling)
  : 속도가 빠른 디스크를 버퍼처럼 사용하여 입출력장치에서 미리 읽는 것이다. 버퍼링이 컴퓨터 하드웨어의 일부인 버퍼를 사용한다면, 스풀링은 별개의 오프라인 장치를 사용한다는 점이 다르다. 
  
  * 버퍼링이 하나의 입출력 작업과 그 작업의 계산만 함꼐 할 수 있는 반면에, 
  * 스풀링은 여러 작업의 입출력과 계산을 함께 할 수 있다.
  * 스풀링은 프로세서에 일정한 디스크 공간과 테이블만 있으면, 하나의 계산 작업과 다른 입출력 작업을 중복해서 처리할 수 있으므로, 성능에 직접적으로 도움을 준다.
  * 이처럼 스풀링은 프로세서와 입출력장치가 고효율로 작업할 수 있도록 한다.
  * 특히, 프로세서 중심 작업과 입출력 중심 작업이 혼합된 경우에 더 좋다. </br></br>
<img src="https://user-images.githubusercontent.com/83942393/124879156-e49fc180-e007-11eb-8af3-12799c491de7.png" width="50%" height="50%"></img></br></br>
  
  ### 1.3 1960년대 : 다중 프로그래밍, 시분할, 다중 처리, 실시간 시스템
  : 이 시기 운영체제의 특징은 장치 독립성을 이용한 편리한 하드웨어 관리와 다중 프로그래밍, 시분할, 다중 처리, 실시간을 이용한 시스템의 처리 능력 향상이다.
  
  * 다중 프로그래밍 시스템
    * 여러 프로그램을 메모리에 나눠 적재한 후 프로세서를 번갈아 할당하여 프로세서의 사용을 극대화하면서, 여러 프로그램을 동시에 실행
  * 시분할 시스템
    * 다중 프로그래밍 시스템에 프로세서 스케줄링 이라는 개념을 더한 것. 
    * 일정한 프로세서 사용 시간을 할당하여 빠른 응답이 가능하므로, 사용자와 대화하는 방법으로 여러 프로그램을 실행한다.
  * 다중 처리 시스템
    * 하나의 시스템에서 프로세서를 여러 개 사용하여 처리 능력을 높인 것
  * 실시간 처리 시스템
    * 즉시 응답

``` 
NOTE_ 장치의 독립성
프로그램을 특정의 입출력 장치를 전제로 하지 않아, 다른 입출력장치와 함께 실행할 수 있는 것이 장치 독립성의 개념이다. 
예를 들어, 어떤 때에는 자기 테이프를 사용하고, 다른 때에는 자기 디스크를 사용하는 것과 같이, 입출력 장치를 동적으로 사용할 수 있다.
```
</br>

이 시기에 미항공상의 SABRE 예약 시스템을 개발했다. 이 시스템은 멀리 떨어진 사용자가 단말기를 이용하여 중앙 컴퓨터 시스템과 통신하는 트랜잭션 처리 시스템의 효시이다.   
트랜잭션 처리 시스템은 사용자와 컴퓨터 시스템이 서로 대화를 하되, 사용자의 비교적 간단한 요구에 컴퓨터가 빠르게 응답하는 것이다. 역서 사용자 단말기를 컴퓨터의 온라인이라고 한다.   

</br>

 ### 1.4 1970년대 초반 : 다중모드, 범용 시스템
 * 모든 사용자에게 모든 기능을 제공할 수 있도록 범용 시스템으로 설계
 * 일괄 처리, 시분할 처리, 실시간 처리, 다중 처리를 모두 제공하는 다중 모드 시스템도 등장
 * 해당 기능이 필요 없는 사용자에게도 동일한 모든 기능을 제공하여 , 실행 시간의 과부하가 발생
 * 시스템을 이해하기 위해선 고도의 훈련이 필요
 * 오류가 발생하면 수정하는 데 시간이 오래 걸렸으며, 시스템 유지 비용이 늘어나는 등 문제 발생

```
NOTE_범용
널리 여러 용도로 쓰인다. 스마트폰은 더 이상 임베디드 시스템 보다는 범용 시스템에 가까워지고 있다.
```
</br>

### 1.5 1970년대 중반~1990년대 : 분산 처리 시스템, 병렬 계산과 분산 계산
 * 컴퓨터 네트워크와 온라인 처리 방법을 널리 사용
 * 네트워크를 이용하여 멀리 떨어진 컴퓨터를 사용할 수 있고, 마이크로프로세서가 등장하여 개인용 컴퓨터를 가질 수 있게 됨
 * 사용자가 지역적으로 멀리 떨어진 여러 시스템과 통신할 수 있어, 정보 보호가 중요한 관심사가 됨
 * 1970년대 명렁어 중심의 시스템 사용법이 1980년대 사용자에게 편리한 메뉴 지향적인 시스템으로 대체되었고, 1990년대 GUI 시스템으로 발전
 * 분산 처리 개념을 확립하여, 컴퓨터가 있는 곳으로 데이터를 가져가 처리하기 보다는 데이터가 발생하는 곳으로 컴픂터의 능력을 가져오는 데 관심을 갖게 됨
</br>

###  1.6 2000년대 이후 : 모바일 및 임베디드, 가상화 및 클라우드 컴퓨팅
 * 모바일 운영체제 : 노키아의 심비안, 구글의 안드로이드, 애플의 iOS, RIM의 블랙베리 OS, 마이크로소프트의 윈도우 등
 * 각종 사물에 컴퓨터 칩과 통신 기능을 내장하여 인터넷에 연결하는 사물인터넷(IoT, Internet of Things) 기술이 등장
 * 1960년대 후반 등장한 가상화 기술이 본격적으로 확산 (가상화 : 물리적 자원을 추상화하여 논리적 자원 형태로 표현하는 기술)
 </br>

 * 가상화는 적용 대상에 따라 서버 가상화, 데스크톱 가상화, 스토리지 가상화, 네트워크 가상화, 소프트웨어 가상화로 구분
 * 이 중 운영체제와 관련된 가상화 핵심은 서버 가상화
 </br>
 
 --- 
 #### 서버 가상화
 : 물리적 서버 하나에 가상 서버를 여러 개 구성하는 방법
 
 * 기업은 하나의 물리 서버를 보다 효율적으로 사용하기를 원함.
 * 서버 하나에서 각 응용 프로그램과 운영체제를 독립된 환경으로 사용할 수 있어, 여러 운영체제가 한 시스템의 자원을 공유할 수 있다.
 * '하이퍼바이저'를 이용해 하드웨어 자원을 가상화하는 방식 (VM)
 </br>
 
![서버 가상화](https://user-images.githubusercontent.com/83942393/124884007-d86a3300-e00c-11eb-99fb-3f7ead85f15e.png)</br>
![image](https://user-images.githubusercontent.com/83942393/124905307-e0cc6900-e020-11eb-8b16-7850186933b4.png)

  ```
  NOTE_하이퍼 바이저(Hypervisor)
  프로세서나 메모리 같은 다양한 컴퓨터 자원에 서로 다른 각종 운영 체계(OS)의 접근 방법을 통제하는 얇은 계층의 소프트웨어. 
다수의 OS를 하나의 컴퓨터 시스템에서 가동할 수 있게 하는 소프트웨어로 중앙 처리 장치(CPU)와 OS 사이에 일종의 중간웨어로 사용되며,
하나의 컴퓨터에서 서로 다른 OS를 사용하는 가상 컴퓨터를 만들 수 있는 효과적인 가상화 엔진이다.
  ```
  </br>
  
  가상화 방법에 따라   
  1. 호스트 운영체제에서 가상 머신을 구동하는 호스트 기반 가상화
  2. 호스트 운영체제 설치 전에 가상화 솔루션을 탑재하여 가상의 CPU, 메모리, 디스크, 네트워크 카드 등을 생성하는 베어메탈(bare-metal) 기반 가상화로 분류 
  </br>
<img src="https://user-images.githubusercontent.com/83942393/124902903-5aaf2300-e01e-11eb-9b60-400d71c22cb8.png" width="70%" height="70%"></img></br>
</br>

  (a) 호스트 기반 가상화</br></br>
  ![image](https://user-images.githubusercontent.com/83942393/124902444-e6747f80-e01d-11eb-9eec-60016be4c4d8.png)</br>
  </br>
  호스트형 하이퍼바이저는 일반적인 소프트웨어처럼 호스트 OS 위에서 실행됩니다.</br>
  하드웨어 자원을 VM 내부의 게스트 OS에 에뮬레이트 하는 방식이기 때문에, 네이티브 방식에 비해 오버헤드가 크지만, 게스트 OS 종류에 대한 제약이 없고, 데스크톱뿐만 아니라 노트북에서도 운영할 수 있습니다.
  
  (대표적으로는 VMware server, VMware Workstation, Virtual box가 있습니다.)
  
  * 장점
    * 설치가 쉽고, 구성이 편리하다.
  * 단점
    * 성능이 떨어질 수 있다.
  
  </br></br>
  (b) 베어메탈 기반 가상화 / 네이티브 or 하이퍼바이저형 (native / bare_metal or hypervisor)</br></br>
  ![image](https://user-images.githubusercontent.com/83942393/124902241-b75e0e00-e01d-11eb-969f-bbce06b2e323.png)</br>
  </br>
  하이퍼바이저가 하드웨어 바로 위에서 실행되는 방식입니다.</br>
  
  * 하이퍼바이저가 하드웨어를 직접 제어하기 때문에, 자원을 효율적으로 사용
  * 별도의 호스트 OS가 없으므로 오버헤드가 적지만, 여러 하드웨어 드라이버를 세팅해야 하므로 설치가 어렵다.
  * 장점
    * 향상된 성능을 제공하고, 실시간 운영체제를 지원
  * 단점
    * 운영체제 위에 없기 때문에 디바이스용 드라이버, 하드웨어 플랫폼 드라이버 등을 포함해야 한다.
    * 설치와 구성이 어렵다. 
  
  (대표적으로는 Xen, 마이크로소프트 Hyper-V, KVM이 네이티브 하이퍼바이저에 속합니다.)
  
  네이티브형 하이퍼바이저는 **전 가상화(Full Virtualization), 반가상화(Para Virtualization)** 방식으로 세분화할 수 있습니다.</br>
  둘의 차이는 하이퍼바이저를 통해 가상 머신 내의 게스트 OS가 호스트 시스템을 활용한다는 점은 같지만, 하드웨어와 인터랙션하는 방식에는 차이가 있습니다.</br></br>
  <img src="https://user-images.githubusercontent.com/83942393/125015693-fab28e00-e0aa-11eb-9500-d816ca33a68f.png" width="70%" height="70%"></img></br>
  
  1-1)전 가상화(Full Virtualization)</br>
  * 게스트 OS를 호스트 시스템과 완전히 분리하여 실행
  * 게스트 OS는 하드웨어 자원을 요청하기 위해, 반드시 하이퍼바이저가 중재 해야 함
  
  전 가상화는 하드웨어를 모두 가상화하는 방식입니다.</br>
  게스트 OS가 하이퍼바이저에게 하드웨어 시스템 제어를 요구하면, 하이퍼바이저는 하드웨어에게 해당 요구사항을 전달합니다.</br></br>
  ![image](https://user-images.githubusercontent.com/83942393/125016317-1d917200-e0ac-11eb-8c00-d0720748f4d0.png)</br>
  
  * 각 게스트 OS는 **'DOM 0'** 라는 관리 머신을 거쳐 하이퍼바이저와 통신하므로, CPU와 RAM 처럼 I/O가 잦은 자원을 컨트롤 하기에는 번거롭다. </br>
  * 이런 한계를 개선하기 위해 반가상화 방식이 출현. </br>
  </br>
  
  1-2) 반가상화(Para Virtualization)</br>
  * 게스트 OS 를  수정하여 필요한 하드웨어 자원을 **직접** 요구
  </br>
  
  * 반 가상화 방식은 하드웨어를 완전히 가상화 하지 않습니다.</br>
  * 대신 게스트 OS의 커널을 일부 수정해 하드웨어와 인터렉션할 수 있도록 합니다.</br>
  * OS를 수정해야 하므로 게스트 OS가 윈도우일 경우 별도의 Tool을 이용해야 해서 번거로움이 있습니다.</br></br>
  
  ![image](https://user-images.githubusercontent.com/83942393/125017123-79a8c600-e0ad-11eb-9ecc-c513c3bfa54c.png)</br>

  대표적인 반가상화 방식 소프트웨어인 Xen에서 게스트 OS는 Hyper Call 이라는 명렁어를 통해 필요한 하드웨어 자원을 바로 하이퍼바이저에게 전달하고, 하이퍼바이저는 바로 하드웨어를 제어합니다.</br>
  즉, 각각의 게스트 OS는 필요한 자원을 직접 요청할 수 있는 능력이 있으므로 모든 요청을 'DOM 0'가 한꺼번에 처리하여 하드웨어를 제어하는 전가상화 방식에 비해 성능이 좋습니다.</br>
</br>

> 하이퍼바이저에 의해 구동되는 VM은 각 VM별로 독립된 가상의 자원을 할당받습니다.   
> VM은 논리적으로 분리되어 있어, 한 VM에 오류가 발생해도 다른 VM으로 확산되지 않는다는 장점이 있습니다.

</br>

  --- 
  
  * 클라우드 컴퓨팅 등장 - 서버 가상화 기술을 이용하여 사용자에게 컴퓨팅 자원, 스토리지, 소프트웨어 등을 서비스 형태로 제공
    * 클라우드 데이터 센터에서 원하는 만큼 컴퓨터 자원을 무한대로 사용할 수 있다.
    * 컴퓨터 자원을 원할 때 원하는 만큼 늘리거나 줄일 수 있다.
    * 컴퓨터 자원을 사용한 만큼 사용료를 지불한다. 
    * 그리드 컴퓨팅(grid computing)의 분산 컴퓨팅 개념, 유틸리티 컴퓨팅(utility computing)의 과금 모델, 서버 기반 컴퓨팅(server based computing)의 처리 모델을 적용
 </br>
 
 * 클라우드 컴퓨팅 기술을 이용한 서비스는 크게 세 가지로 구분
   * IaaS(Infrastructure as a Service) : 데이터 센터에 있는 서버, 스토리지, 네트워크 등 인프라나 자원을 가상화하여 인터넷으로 제공

   * PaaS(Platform as a Service) : 응용 프로그램 구축, 테스트 및 설치가 가능한 통합 개발 환경을 웹으로 제공</br>
     * 구글, 다음, 네이버에서 제공하는 Open API가 PaaS의 일종. </br>
     * 구글 앱 엔진(Google App Engine)은 웹 서비스를 개발, 구축, 관리, 배포할 수 있는 플랫폼을 제공</br>

   * SaaS(Software as a Service) : 특정 소프트웨어를 인터넷으로 제공.
     * 해당 소프트웨어와 관련된 데이터를 클라우드에서 관리하고, 사용자는 웹 브라우저로 접속하여 소프트웨어를 사용한다.
     * 이런 소프트웨어를 온디맨드(on demand) 소프트웨어라고 한다.

</br>

### 2. 운영체제의 유형
 * 일괄 처리 시스템
 * 다중 프로그래밍 시스템
 * 다중 처리 시스템
 * 시분할 시스템
 * 실시간 처리 시스템
 * 분산 처리 시스템
 
 ```
 NOTE_단일 작업 운영체제와 다중 작업 운영체제
 운영체제는 동시 작업 지원 여부에 따라 단일 직업(single tasking) 운영체제와 다중 작업(multitasking) 운영체제로 구분할 수 있다.
 단일 작업 운영체제는 한 번에 하나의 프로그램만 수행할 수 있는 운영체제로 도스가 이에 해당한다. 현재의 컴퓨터는 대부분 동시에 2개 이상의
 프로그램을 수행할 수 있는 다중 작업 운영체제이다.
 ```
### 2.1 다중 프로그래밍 시스템
 * 일괄 처리 시스템의 가장 큰 문제 : 프로세스가 다른 작업을 하고 있을 때는 입출력 작업이 불가능하여, 프로세서와 메인 메모리의 활용도가 떨어진다는 것
 * 이것을 다중 프로그래밍을 도입하여 해결
 * 다중 프로그래밍은 프로세서가 유휴 상태일 때, 실행 중인 둘 이상의 작업이 프로세서를 전환하여 사용할 수 있도록 동작
 * 즉, 여러 프로그램을 메모리에 적재한 후, 하나의 프로그램이 프로세서를 사용하다가 입출력 동작 등을 하여 프로세서를 사용하지 않는 유휴 시간 동안 다른 프로그램이 프로세서를 사용하도록 하는 시스템

<img src="https://user-images.githubusercontent.com/83942393/125015369-5892a600-e0aa-11eb-870e-ead088fa78d2.png" width="60%" height="60%"></img></br>

```
그림은 작업 2가 프로세서를 사용하다가 입출력 동작 중이면 그동안 작업 1이 프로세서를 사용한다. 
작업 3은 프로세서 실행 시간을 얻을 때까지 대기하도록 하여 프로세스가 쉬지 않게 함으로써 프로세서 사용을 극대화한다.
```

예)</br> 프로그램 A가 프로세서를 사용하다가 작업 중이거나 입출력을 하려고 대기하는 유휴시간이 발생하면 프로그램 B가 프로세서를 사용하는 방법으로 여러 프로그램을 순차적으로 실행한다.
  **프로세서의 유휴시간에도 다른 프로그램을 처리하여, 동시에 여러 프로그램을 실행하는 것과 같은 효과를 내어 프로세서 효율을 극대화한다.**</br>
  
<img src="https://user-images.githubusercontent.com/83942393/125017925-07d17c00-e0af-11eb-98a5-1b860dd44a9c.png" width="60%" height="60%"></img></br>

  * 장점
    * 높고 효율적인 프로세서 사용률 (효율적인 운영)이 증가하여 마치 많은 사용자의 프로그램이 거의 동시에 프로세서를 할당받는 듯한 느낌
  * 단점
    * 아주 복잡함
      * 여러 작업을 준비 상태로 두려면, 이를 메모리에 보관해야 하고, 일정 형태의 메모리 관리 필요
      * 여러 작업이 수행할 준비를 갖추면, 이 중 하나를 선택하는 결정 방법이 필요
      * -> 이것이 인터럽트를 이용하여 수행하는 프로세서 스케줄링의 다중 프로그래밍 , 운영체제의 중심

</br>

### 2.2 시분할 시스템(TSS, Time Sharing System)
  * 다중 프로그래밍을 논리적으로 확장한 개념
  * 프로세서가 다중 작업을 교대로 수행
  * 다수의 사용자가 동시에 컴퓨터의 자원을 공유할 수 있는 기술
  * 즉, **다양한 터미널에 위치한 많은 사용자가 특정 컴퓨터 시스템을 동시에 사용할 수 있게 한다.**
  </br>

  * 1970년 초까지는 시분할 시스템을 만들기가 아주 어렵고 비용도 많이 들어 일반화하지 못했으나, 이제는 대부분 다중 프로그래밍과 시분할 방법을 모두 지원
  * 프로세서에 적재된 여러 프로그램을 실행, but) 각 프로그램에 일정한 프로세서 사용 시간(time slice) 또는 규정 시간량(quantum)을 할당하여, 주어진 시간 동안 컴퓨터와 대화하는 형식으로 실행
  * 여러 사용자에게 짧은 간격으로 프로세서를 번갈아 가며 할당해서, 마치 자기 혼자 프로세서를 독점하고 있는 양 착각하게 하여, 여러 사용자가 단일 컴퓨터 시스템을 동시에 사용할 수 있게 한다.</br></br>
  
  <img src="https://user-images.githubusercontent.com/83942393/125019110-5a139c80-e0b1-11eb-86f1-a0bac541cf30.png" width="60%" height="60%"></img></br>
  </br>
  
> **다중 프로그래밍과 시스템과 시분할 시스템의 공통점과 차이점**</br>
> 둘 다 메모리에 여러 프로그램을 적재하므로 메모리 관리가 필요하고, 어떤 프로그램을 먼저 실행할지 결정하는 스케줄링이라는 개념이 필요</br>
> 하지만 다중 프로그래밍 시스템은 프로세서 사용을 최대화하는 것이 목표라면, 시분할 시스템은 응답시간을 최소화하는 것이 목표라는 큰 차이가 있다.
</br>

  * 시분할 시스템은 여러 작업(프로세스)을 메모리에 저장하므로 짧은 시간에 작업을 교체할 수 있도록 적절한 메모리 관리가 필요
  * 한 작업이 다른 작업의 데이터를 변경하지 않도록 보호가 필요
  * 특히, 다수의 사용자가 접근하는 파일은 접근 권한을 두어 특정 권한이 있는 사용자만 접근할 수 있도록 파일 시스템을 보호해야 함
  * 공유 자원에는 액세스 순서를 조정할 수 있는 기능도 제공해야 함
  </br>
  
  * 시분할 시스템의 장점
    * 빠른 응답 제공
    * 소프트웨어의 중복 회피 가능
    * 프로세서 유휴시간 감소
  * 단점
    * 신뢰성 문제
    * 보안 의문 및 사용자 프로그램과 데이터 무결성
    * 데이터 통신의 문제

</br></br>
### 2.3 다중 처리 시스템 (multiprocessing)
  : 단일 컴퓨터 시스템 내에서, 둘 이상의 프로세서를 사용하여 동시에 둘 이상의 프로세스(프로그램)을 지원한다.</br>
  ( 하나의 프로세서가 2개 이상의 프로그램을 전환하는 다중 프로그래밍과 혼동해서는 안 된다.)</br>
  
  * 여러 프로세서와 시스템 버스, 클록, 메모리와 주변장치를 공유한다.
  * 프로세서가 둘 이상이므로 빠르고, 프로세서가 하나 고장이 나도, 다른 프로세서를 사용하여 작업을 계속할 수 있어 신뢰성이 높다. 
  * 프로세서가 여러 개이므로, 프로세서 간의 연결, 상호작용, 역할 분담 등을 고려해야 한다.</br></br>

<img src="https://user-images.githubusercontent.com/83942393/125021823-58000c80-e0b6-11eb-9da5-e50fcdb24573.png" width="30%" height="30%"></img></br>
  
</br></br>

### 2.4 실시간 처리 시스템 (real time processing system)
  : 데이터 처리 시스템으로 정의</br>
  
  * 입력에 응답하는 데 필요한 시간 간격이 너무 짧아서 환경을 제어한다.
    * 온라인 시스템은 실시간으로 할 필요가 없는 반면에, 실시간 처리 시스템은 항상 온라인 상태이어야 한다.
  * 입력 및 업데이트된 정보 요구를 처리한 후, 디스플레이에 응답하는 시스템에 소요되는 시간을 반응(응답)시간으로 한다.
  * 반응시간은 프로세서에 이미 고정되어 있다. 따라서 반응시간이 온라인 처리에 비해 매우 짧다.
  </br>
  
  * 실시간 처리 시스템은 더 높은 적시(:알맞은 때) 응답을 요구하는 장소에서 사용
  * 데이터 흐름 또는 프로세서 연산에 엄격한 시간 요구가 있을 때 사용
  * 고정 시간 제약을 잘 정의하지 않으면, 시스템이 실패

#### 실시간 처리 시스템의 두 가지 유형
◾ 경성 실시간 처리 시스템 (hard real time processing system)
: 작업의 실행 시작이나 완료에 대한 시간 제약 조건을 지키지 못할 때, 시스템에 치명적인 영향을 주는 시스템
```
예)
무기 제어, 발전소 제어, 철도 자동 제어, 미사일 자동 조준 등
```
* 보장되는 컴퓨팅, 시간의 정확성과 컴퓨팅 예측성을 갖게 해야 한다.
</br>

◾ 연성 실시간 처리 시스템(soft real time processing system)
:  작업 실행에서 시간 제약 조건은 있으나, 이를 지키지 못해도 전체 시스템에 치명적인 영향을 미치지 않는 시스템
```
예)
동영상 -> 초당 일정 프레임 이상의 영상을 재생해야 한다는 제약이 있으나, 일부 프레임을 건너 뛰어도 동영상을 재생하는 시스템에는 큰 영향을 미치지 않는다.
```
</br></br>

### 2.5 분산 처리 시스템 (distributed processing system)
  * 시스템마다 독립적인 운영체제와 메모리로 운영하며, 필요할 때 통신하는 시스템
  * 최근 컴퓨터 시스템은 여러 물리적 프로세서에 연산을 분산하는 경향이 있는데, 이는 자원 공유, 연산 속도 향상, 신뢰성과 통신 때문
  * 분산 처리 시스템은 사용자에게는 중앙집중식 시스템처럼 보이나, 다수의 독립된 프로세서에서 실행
  * 데이터를 여러 위치에서 처리, 저장하며 여러 사용자가 공유할 수 있음
  * 하나의 프로그램을 여러 프로세서에서 동시에 실행할 수도 있음</br></br>
  <img src="https://user-images.githubusercontent.com/83942393/125023889-bb8c3900-e0ba-11eb-9ae1-8c1146988f9a.jpg" width="50%" height="50%"></img></br>
  ```
  NOTE_워크 스테이션(workstation)
  개인이나 적은 인원수의 사람들이 특수한 분야에 사용하기 위해 만들어진 고성능의 컴퓨터
  ```
</br></br>


### 출처
[네이버 지식백과] 장치 독립성 [device independence, 裝置獨立性, 裝置-] (IT용어사전, 한국정보통신기술협회)
[네이버 지식백과] 하이퍼바이저 [Hypervisor] (IT용어사전, 한국정보통신기술협회)
서버 가상화 https://library.gabia.com/contents/infrahosting/7426/
