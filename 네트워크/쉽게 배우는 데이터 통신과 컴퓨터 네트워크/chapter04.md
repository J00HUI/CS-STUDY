### 🔆 Preview

물리 계층을 이용해 전송되는 데이터는 전송 매체의 물리적인 특성으로 인해 오류가 발생할 수 있다.   

오류의 종류 :       
- 데이터가 수신 호스트에 전달되지 않는 데이터 분실      
- 데이터 일부가 깨져서 도착하는 데이터 변형        

오류 문제를 해결하려면 일차적으로 오류가 발생했다는 것을 인지해야 한다.      

- 데이터 분실 : 송신 호스트 주도의 타임아웃 방식으로 검출      
- 데이터 변형 : 수신 호스트가 송신 데이터에 포함된 오류 검출 코드(생성 다항식)를 활용해 검출      

물리적인 전송 오류를 해결하는 것은 계층 2 프로토콜의 가장 중요한 역할이다.      

컴퓨터 네트워크에서는 오류 데이터를 복구하기 위하여 재전송 기법을 사용한다.        

- 데이터 분실 : 타이아웃 과정을 거쳐 송신 호스트가 원래의 데이터를 재전송      
- 데이터 변형 : 수신 호스트의 오류 발생 통지에 따라 송신 호스트가 원래 데이터를 재전송하여 해결    
</br>

### 💎 01 데이터 전송 방식
* 컴퓨터 네트워크는 독립적으로 실행되는 호스트들을 연결해 하나의 통신망을 구성한 것이다.
* 네트워크를 통한 자원 공유, 병렬 처리에 의한 성능 향상, 중복 저장으로 신뢰성 향상 등의 효과를 얻을 수 있다.
</br>

> 자원 공유(Resource Sharing)
* 컴퓨터 하드웨어뿐 아니라 각 호스트에서 사용하는 논리적인 정보를 공유하는 것이다.
* 자원을 더 효율적으로 활용할 수 있게 해주어 네트워크를 발전시킨 1차 요인이기도 하다.
</br>

> 병렬 처리에 의한 성능 향상
* 병렬 처리는 원래 컴퓨터 시스템 내부에서 구현되고 발전되어 왔다.
* 하나의 공유 시스템 버스에 다수의 메인 프로세서를 장착하거나, I/O 장치의 처리 속도를 향상시키기 위해 I/O 전용 프로세서를 설치하는 것이 그 예이다.
* 시스템이 수행할 작업을 분할해 동시에 처리함으로써 처리 시간을 단축시키는 효과를 얻는다.
* 네트워크가 시스템 버스 역할을 수행하는 방식의 분산 병렬 처리 시스템에 대한 연구는 이전부터 많이 진행되었지만, 네트워크 속도의 제한 때문에 한계가 있었다.
* 그러나 네트워크 속도가 많이 향상됨에 따라 네트워크를 활용한 분산 병렬 처리의 효과도 크게 향상되고 있다.
</br>

> 중복 저장으로 신뢰성 향상
* 네트워크에 연결된 시스템이 보관하는 정보의 신뢰성을 향상시키기 위해 사용한다.
* 중요한 정보를 여러 시스템에 중복 저장하고, 중복에 따른 부가 처리는 컴퓨터 시스템이 자동으로 해결해줌으로써 하드디스크 손상과 같은 특정 시스템에서 발생한 데이터 손실을 복구할 수 있다.
* 그러나 신뢰성의 정도가 향상됨에 따라 시스템 성능은 저하될 수 있다.
</br>

### 1. 전송과 교환
* 컴퓨터 네트워크에는 전송 매체로 연결된 호스트들이 존재한다.
* 송신 호스트가 수신 호스트에 데이터를 **전달** (Transfer)하려면, 전송과 교환 과정을 거쳐야 한다.
* **교환** (Switching) 은 전달 경로가 둘 이상일 때, 라우터에서 데이터를 어느 방향으로 전달할지를 선택하는 기능으로, 다양한 기준에 따라 데이터를 올바른 경로로 전달할 수 있도록 해준다.
* **전송** (Transmission)은 특정한 물리 매체에 의하여 일대일(1:1)로 직접 연결된 두 시스템 간의 신뢰성 있는 데이터 전송을 보장하기 위한 것이다.
* 전송에는 라우팅 개념이 포함되지 않는다.
</br>

### 1.1 전송과 교환의 개요
그림은 호스트 a 와 호스트 d 가 통신한다고 가정하고, 둘 사이의 데이터 전달 과정을 통해 전송과 교환의 차이점을 설명한다.   

호스트 a 에서 호스트 d 로 데이터를 전달하려면 다음 세 과정을 순차적으로 진행해야 한다.
1. 호스트 a 와 호스트 c 간의 직접 연결에 의한 전송
2. 호스트 c 에서의 올바른 경로 선택을 의미하는 교환
3. 호스트 c 와 호스트 d 간의 직접 연결에 의한 전송

<img src="https://user-images.githubusercontent.com/83942393/129123127-eff64b4c-7c65-4a7c-85ce-9e5aae153334.png" width="60%" height="60%"></img></br>

* 전송 개념에는 교환 개념이 배제되어야 한다.
* 이를 위해서는, 두 호스트를 전송 매체로 직접 연결해 송신 호스트가 전송한 데이터가 수신 호스트에 직접 도착하도록 해야 한다.

```
호스트 c 에서의 교환 과정은 수신 데이터를 어느 경로로 전달할지를 결정한다.
호스트 c 는 호스트 a, 호스트 d, 호스트 e라는 세 경로로 데이터를 전송할 수 있다.
호스트 a 방향은 데이터가 출발지로 되돌아가므로 잘못된 선택이고, 호스트 e 방향은 직관적으로 볼 때, 데이터가 먼거리로 우회하여 전달되기 때문에 잘못된 선택이다.
호스트 d 방향으로 직접 보내주는 것이 가장 올바른 경로 선택이다.
올바른 경로를 선택하기 위해 교환 기능을 수행하는 호스트는 경로 선택과 관련된 정보를 관리한다.
```
</br>

### 1.2 전송 방식의 종류
네트워크를 다양한 기준으로 분류할 수 있지만,
1. 네트워크에 연결된 호스트의 지리적 분포에 따라 구분하는 방식
2. 데이터 전송·교환 기술로 분류
하는 방식이 대표적이다.

* 지리적 분포에 따른 분류 방식에는 LAN(근거리 통신망), MAN(도시 규모의 통신망), WAN(원거리 통신망) 등이 있다.
* 네트워크 전송·교환 기술에 따라 네트워크를 분류하는 방식에는 각 호스트를 일대일로 직접 연결해 목적지 호스트에만 데이터를 전송하는 점대점(Point-to-Point) 방식과 네트워크에 연결된 모든 호스트에 데이터를 전송하는 브로드캐스팅(Broadcasting) 방식이 있다.
</br>

> 점대점 방식
* 점대점 방식에서는, 호스트 간의 데이터 전달 과정에서 송신 호스트가 중개 호스트와 일대일로 연결되므로, 다른 호소트에는 데이터가 전달되지 않는다.
* 따라서 데이터를 최종 목적지 호스트까지 올바르게 전달하려고, 인접 호스트에 전송하는 과정을 단계적으로 반복한다.
```
이때 각 호스트는 데이터를 송수신하는 호스트일 수도 있고, 중간에 있는 교환 시스템일 수도 있다.
```
* 원거리에 있는 시스템 사이의 통신 방식으로, WAN 환경에서 주로 사용한다.
* 스타형, 링형, 완전형, 불규칙형
</br>

> 브로드캐스팅 방식
* 공유 전송 매체 하나에 여러 호스트를 연결하기 때문에, 네트워크에 연결된 모든 호스트에 데이터가 전송된다.
* 데이터 전달 과정에서는 별도의 교환 기능이 필요없다.
* 대신, 자신을 목적지로 하지 않은 데이터를 받은 호스트는 받은 데이터를 버려 결국 하나의 목적지 호스트만 데이터를 수신하도록 설계해야 한다.
* LAN처럼 지리적으로 가까운 호스트 사이의 통신에서 주로 사용한다.
* 버스형, 링형 
</br>

### 2. 점대점 방식
* 점대점 방식 네트워크에서는 교환 호스트가 송수신 호스트의 중간에 위치한다.
* 이들을 연결하는 구성 형태에 따라 기술적으로 영향을 많이 받는다.

그림은 대표적인 점대점 방식으로 스타형, 링형, 완전형, 불규칙형이 있다.  
<img src="https://user-images.githubusercontent.com/83942393/129124448-6f6e0360-2ac5-4b0c-8823-753c017f83b5.png" width="60%" height="60%"></img></br>

* 점대점 방식은 연결 개수가 많아지면, 성능 면에서 유리하지만, 전송 매체의 길이가 증가해 비용이 많이 든다.
* 반대로 연결 개수가 적어지면, 전송 매체를 더 많이 공유해 네트워크의 혼잡도가 증가한다.
* 따라서 네트워크 트래픽이 많이 발생하는 구간에서는 전송 매체의 수를 늘리고, 그렇지 않은 구간에서는 줄이는 것이 좋다.
</br>

### 2.1 스타형
* 스타형은 중앙에 있는 하나의 중개 호스트 주위로 여러 호스트를 일대일로 연결하는 형태이다.
* 주변 호스트가 데이터를 송수신하려면, 반드시 중앙의 중개 호스트를 거쳐야 한다.
* 따라서 중앙 호스트의 신뢰성과 성능이 전체 네트워크의 성능과 신뢰성에 많은 영향을 준다.
* 또, 데이터를 적절한 목적지로 전송하는 중개 기능도 중앙 호스트가 독점적으로 담당한다.
* 스타형은 아래 그림처럼 다단계로 확장할 수 있는데, 중앙에 있는 스타 구조 주변에 위치한 호스트들을 중심으로 새로운 스타 구조가 확장되는 형태이다.
* 이를 트리(Tree) 형이라 하는데, 이 구조에서는 주변 호스트가 중개 호스트로 확장되는 과정을 반복해 네트워크를 무한대로 펼칠 수 있다.
* 트리형의 장점은 모든 데이터가 중앙 호스트를 중심으로 라우팅되므로, 중개 과정이 간단하다는 점이다.
* 반대로, 중앙 호스트에 문제가 발생하면 전체 네트워크의 동작에 영향을 많이 준다는 단점이 있다.

<img width="325" alt="스크린샷 2021-08-12 오후 3 16 13" src="https://user-images.githubusercontent.com/83942393/129147255-528b3762-5a12-4857-8028-fa51ed5fa8ef.png"></br>
그림 4-3 트리의 구조   
<img src="https://user-images.githubusercontent.com/83942393/129125739-0d854f56-8235-4489-805c-36c49b31c527.png" width="45%" height="45%"></img></br>
<img src="https://user-images.githubusercontent.com/83942393/129125862-251628e1-14e9-4276-8543-5f42f4f8812f.png" width="20%" height="20%"></img></br>
</br>

### 2.2 링형
* 링형은 호스트의 연결이 순환 고리 구조이며, 전송 데이터가 브로드캐스팅되는 특징이 있다.
* 그러나 호스트가 일대일로 직접 연결되기 때문에 점대점 방식에도 포함된다.
* 송신 호스트와 수신 호스트의 거리가 멀수록 데이터 전달 과정에 개입하는 중개 호스트의 개수도 자연히 증가한다.
* 링형에서는 네트워크에 연결된 모든 호스트가 데이터 전송과 교환 기능을 동시에 수행할 수 있어야 한다.
* 이론적으로는 송수신 호스트 사이의 중개 거리를 판단해 데이터를 시계 방향이나 반시계 방향으로 전달하는 것이 효율적이다.
```
그러나 실제 환경에서 링형은 데이터를 한 방향으로만 전달하도록 설계한다.
왜냐하면 데이터 전달 방향을 고정하면, 복잡한 처리 과정이 단순해져, 중개되는 호스트의 개수를 줄이는 것보다 유리하기 때문이다.
```
* 링형에서는 연결된 여러 호스트가 데이터를 동시에 전송하면 데이터 충돌이 발생할 수 있다.
* 따라서 호스트 사이의 데이터 송신 시점을 제어하는 토큰이라는 특수한 제어 프레임을 사용한다.
```
토큰은 데이터 전송 권한을 의미하기 때문에, 호스트가 데이터를 전송하려면 토큰을 꼭 확보해야 한다.
평소에는 링 네트워크 하나의 토큰이 순환하는데, 데이터를 전송하려는 호스트는 토큰이 도착하면, 이를 내부에 보관한 후, 데이터 전송을 시작한다.
그리고 데이터가 네트워크를 한 바퀴 순환하여 되돌아오면 데이터 전송이 완료된 것이므로, 토큰을 다시 링 네트워크에 돌려주어야 한다.

이러한 과정이 반복적으로 이루어지면서, 링에 연결된 모든 호스트가 토큰을 확보하고, 데이터 전송 기회가 동등하게 부여된다.
```
* 링형의 단점은 한 호스트가 고장나면 전체 네트워크가 동작하지 않을 수 있다.
* 따라서 정전이나 기타 원인에 의해 오작동하는 호스트는 네트워크에서 논리적으로 분리하여 고립시킬 수 있어야 한다.
</br>

### 2.3 완전형
* 완전형은 네트워크에 존재하는 모든 호스트가 다른 모든 호스트와 일대일로 직접 연결하는 방식이다.
* 호스트끼리 서로 공유하지 않는 전용 매체로 직접 연결하기 때문에, 교환 기능이 필요 없다.
* 완전형의 단점은, 사용하는 전송 매체의 수가 증가하면, 비용 측면에서 극단적으로 비효율적이라는 것이다.
```
예를 들어 네트워크에 존재하는 호스트의 개수가 N개라고 가정하면 연결에 필요한 전송 매체의 수는 Nx(N-1)/2 개가 된다.
```
* 특별한 목적을 위해, 제한적으로 연결하는 경우를 제외하면, 완전형을 사용하는 경우는 거의 없다고 볼 수 있다.
</br>

### 2.4 불규칙형
* 불규칙형은 말 그대로 전송 매체에 의한 연결 구조를 특정 패턴으로 분류할 수 없다는 뜻이다.
* 일반 네트워크의 형태는 불규칙형이다.
* 네트워크에서 고려해야 하는 여러 환경 요인에 의해 연결 구조가 결정된다.
```
예를 들어, 특정한 두 호스트 사이에 통신 트래픽이 많으면 이들을 직접 연결하고, 적으면 다른 호스트의 중개 과정을 거쳐서 데이터를 주고받도록 설계한다.
```
</br>

### 3. 브로드캐스팅 방식
* 점대점 방식은 전송 매체를 사용해 각 호스트를 일대일로 직접 연결한다는 전제하에, 어떤 호스트를 어떤 구조로 연결하는지를 다룬다.
* 반면, 브로드캐스팅(Broadcasting) 방식은 특정 호스트가 전송한 데이터가 네트워크에 연결된 모든 호스트에 전달된다는 특징이 있다.
* WAN 같은 원거리 통신망에서는 특정 호스트 사이를 직접 연결한 전송 매체가 있는지, 아니면 어떤 우회 경로로 몇 단계를 거쳐서 연결할 수 있는지에 대한 판단이 중요하다.
* 그러나, LAN에서는 연결의 존재 여부보다는 데이터를 목적지 호스트까지 얼마나 효율적으로 전달할 수 있는지가 중요한 잣대가 된다.
* 이를 지원하는 브로드캐스팅 방식은 네트워크의 모든 호스트를 하나의 전송 매체로 연결하므로, 중개 기능을 수행하는 교환 호스트가 필요 없다.
* 또한 임의의 송신 호스트에서 보낸 데이터가 네트워크의 모든 호스트에 전달되므로, 데이터를 수신하도록 지정된 호스트는 해당 데이터를 수신하고 보관하지만, 다른 호스트들은 수신 데이터를 버린다.

그림은 브로드캐스팅 방식을 지원하는 버스형과 링형이다.     
![image](https://user-images.githubusercontent.com/83942393/129128537-8dcccfe3-18e4-4d62-b4fb-db7dec7cf7e7.png)

* 버스형은 공유 전송 매체인 버스에 모든 호스트를 연결하므로 공유 버스에 연결된 모든 호스트가 전송 데이터를 수신할 수 있다.
* 링형은 특정 송신 호스트가 전송한 데이터가 링을 한 바퀴 돈 후에, 다시 송신 호스트로 되돌아오는 방식이다.
* 따라서 링에 연결된 모든 호스트 데이터가 전달되므로 브로드캐스팅 방식에 포함시킬 수 있다.
```
링형은 점대점 방식과 브로드캐스팅 방식의 기준에 모두 부합하는 구조이다.

네트워크의 호스트가 일대일 연결 구조를 지원한다는 측면에서 점대점 방식을 지원하고, 전송 데이터가 모든 호스트에게 전달된다는 측면에서는 브로드캐스팅 방식을 지원한다.
```
</br>

### 3.1 버스형
* 버스형 구조에서는 둘 이상의 호스트에서 데이터를 동시에 전송하면 데이터 충돌이 발생할 수 있으므로 충돌에 따른 오류 문제를 해결해야 한다.
* 충돌 문제는 크게 두 가지 방법으로 해결할 수 있다.
1. 호스트의 전송 권한을 제한함으로써 사전에 충돌을 에방
    * 이 방식에서 호스트가 데이터를 전송하려면 사전에 전송 권한을 확보해야 한다.
    * 전송 권한을 확보하는 방법에는 전송 시간대를 분할하여 각 호스트별로 데이터를 전송할 수 있는 시간대(Time Slice)를 다르게 지정하는 방법과
    * 토큰으로 전송 권한을 순환적으로 이용하는 방법이 있다.

2. 둘째, 충돌 허용
    * 둘 이상의 호스트가 데이터를 동시에 전송할 수 있도록 허용하지만, 충돌이 발생했을 때 이를 감지하고 해결하는 과정이 필요하다.
    * 대표적인 공유 버스 방식인 이더넷(Ethernet)에서 채택하는 방식이 충돌 허용의 예이다.
</br>

### 3.2 링형
* 링형에서는 전송 데이터가 링 주위를 특정 방향으로 순환하면서 전달된다.
* 자신이 수신 호스트가 아닌 호스트는 데이터를 수신하지 않고, 그냥 통과시켜야 한다.
* 수신 호스트로 지정된 호스트는 전송 데이터를 자신의 내부 버퍼에 보관하고, 데이터는 계속해서 링을 순환시켜야 한다.
* 링을 한 바퀴 순환한 데이터는 원래의 송신 호스트로 되돌아온다.
* 송신 호스트는 자신이 전송한 데이터를 링엥서 회수함으로써 전송 과정을 종료하고, 이전에 확보한 토큰을 링에 돌려주어 다른 호스트가 데이터를 전송할 수 있게 한다.
* 링형에서는 충돌 문제를 해결하려고 토큰 기능을 사용한다.
* 호스트들이 데이터를 전송하지 않을 때는 토큰이 링 주위를 순환하게 된다.
* 임의의 호스트가 데이터를 전송하고자 하면, 이 토큰을 획득하여 데이터를 전송하고, 데이터 전송을 완료하면 다시 토큰을 네트워크에 돌려준다.
</br>

### 멀티포인트 통신
* 컴퓨터 통신의 가장 기본적인 형식은, 두 호스트 사이의 데이터 전송을 의미하는 유니캐스팅(Unicasting) 방식이다.   
* 인터넷에서 제공되는 텔넷, FTP, 웹 검색과 같은 대부분의 서비스는 유니캐스팅 방식을 사용한다.  </br>
* 최근의 인터넷 통신 환경은 통신 주체 하나가 다수의 상대방과 통신하는 일대다(1:n) 형식뿐 아니라, 다수와 다수가 통신하는 다대다(n:n) 형식의 다양한 멀티포인트(Multipoint)서비스를 요구한다.
```
화상 회의, 원격 교육, 인터넷 채팅 등이 대표적인 예에 속한다.
```
* 하나의 송신 호스트를 기준으로, 수신 호스트 하나와 연결되면 유니포인트(Unipoint)가 되고, 다수의 수신 호스트와 연결되면 멀티포인트(Multipoint)가 된다.
* 송신 호스트가 한 번의 전송으로 수신 호스트 하나에만 데이터를 전송할 수 있으면 유니캐스팅이고, 다수의 수신 호스트에 전송할 수 있으면 멀티캐스팅이다.
</br>

### 4.1 멀티포인트 유니캐스팅
* 유니캐스팅 방식의 프로토콜은 두 호스트 사이의 일대일 통신만 지원한다.
* 따라서 유니캐스팅 방식을 이용해, 일대다 통신을 하려면 아래 그림과 같은 **멀티포인트 유니캐스팅** (Multipoint Unicasting) 방식을 사용해야 한다.

![image](https://user-images.githubusercontent.com/83942393/129130731-eba6e550-4a9b-4b8c-821d-b2a024b9100d.png)

* 그림처럼 맨 왼쪽의 송신 호스트 a 가 다수의 수신 호스트 (d, e, f)에 데이터를 전송하려면, 먼저 각 수신 호스트와 개별적으로 연결을 설정해야 한다.
```
그림에는 수신 호스트가 세 개 이므로, 연결 설정이 세 개 필요하다.
```
* 데이터 전송 과정에서도 연결 설정처럼 개별 수신 호스트에 별도로 세 번 데이터를 전송해야 한다.
* 유니캐스팅과 멀티포인트 유니캐스팅 방식은, 송수신 호스트 사이의 흐름 제어와 수신 호스트의 응답 기능 및 재전송 기능 등을 구현하기 좋다.
* 그러나 멀티포인트 유니캐스팅의 경우, 수신 호스트 수가 적을 떄는 문제없지만, 그 수가 많아지면 성능 면에서 여러 문제가 나타날 수 있다.
</br>

### 4.2 브로드캐스팅
* 송신 호스트가 전송한 데이터가 네트워크에 연결된 모든 호스트에 전송되는 방식을 브로드캐스팅 이라 한다.
* 수신된 데이터에 대한 처리는 전적으로 수신 호스트의 몫으로 남는다.
* 즉, 수신 데이터를 받아들일지, 폐기할지는 수신 호스트가 목적지 주소를 근거로 결정한다.
* 브로드캐스팅 방식에서는 호스트 수가 많을수록, 네트워크 트래픽이 급격히 증가하는 단점이 있다.
* 따라서 이 방식을 사용해야 한다면, 네트워크 전체에 데이터를 전송하기 보다는 특정 서브넷(Subnet)내에서 사용하는 것이 좋다.

그림은 브로드캐스팅 방식에서 데이터 전송 과정을 보여준다.   
![image](https://user-images.githubusercontent.com/83942393/129132219-71a9fa70-c549-4f1b-b586-d94dc769ffb1.png)
* 왼쪽의 송신 호스트 a 가 전송한 데이터는 네트워크에 연결된 모든 호스트(b, c, d, e)에 전달되고, 이 데이터의 수신 여부는 각 수신 호스트가 판단한다.
* 즉, 전송 데이터의 내부에 기술된 호스트 주소가 자신과 일치하지 않는 호스트는 데이터를 받아들이지 않는다.
* 브로드캐스팅 방식에서는 모든 호스트가 데이터를 수신할 수 있도록, 송신 호스트가 다수의 복사본을 개별 수신 호스트들에 전송하지 않고, 특정한 브로드캐스팅 주소로 전송한다.
* 네트워크에 연결된 라우터나 스위치 등의 네트워크 장비에서는 브로드캐스트 주소로 전달된 패킷을 복사하여 네트워크 전체로 전송해준다.
</br>

### 4.3 멀티캐스팅
* 멀티캐스팅 방식은 프로토콜 자체에서 일대다 전송 기능을 구현하기 때문에 아래 그림과 같은 통신 환경을 연결 설정 요구 한 번으로 지원할 수 있다.
* 이는 멀티포인트 유니캐스팅 그림에서 연결 설정 요구가 세 번 필요한 것과는 비교된다.
<img src="https://user-images.githubusercontent.com/83942393/129132604-068dc69b-f675-4512-bcfd-36f3da6b1272.png" width="60%" height="60%"></img></br>
* 데이터 전송 과정에서도, 멀티포인트 유니캐스팅에서는 수신 호스트의 수만큼 데이터를 반복 전송해야 하지만, 멀티캐스팅에서는 송신 호스트의 전송 요구 한 번으로 모든 수신 호스트에 데이터를 전달할 수 있다.
* 멀티캐스팅의 응용 예는 매우 다양하다.
* 인터넷 멀티미디어 환경에서 제공하는 비디오·오디오 서비스, 화상 회의 서비스 등을 비롯해 자사에 등록된 다수 고객을 대상으로 하는 모든 형태의 데이터 서비스(ex) 인터넷 뉴스, 인터넷 주식) 가 멀티캐스팅 서비스이다.
* 멀티캐스팅을 구현하려면 멀티캐스트 그룹을 생성하고 관리하는 기능이 필요하다.
```
예를 들어, 임의의 호스트가 특정 멀티캐스트 그룹에 가입하고 탈퇴하는 기능이 이에 해당한다.
또 멀티캐스트 데이터를 중개하는 라우터에서 멀티캐스트 그룹 주소를 인식하고, 다수의 수신 호스트에서 중개하는 등의 멀티캐스트 트래픽에 대한 처리 기능도 구현되어야 한다.
```
</br>

`내가 생각하는 일대다와 다대다의 차이점`   

* 일대다에선 송신호스트 a만 멀티캐스팅 가능, 다대다에선 다른 호스트들 (d, e, f)도 멀티캐스팅 가능   
* 교실에 앉아서 화면을 통해 교장 선생님의 말씀을 듣는 건 일대다(1:n), 화상 회의를 통해 통신하는 건 다대다(n:m)
* 내 모습을 교장 선생님이나 다른 교실의 친구들은 볼 수 없으나, 화상 회의는 내 모습도 연결된 다른 사람에게 전송되고, 그 사람들의 모습도 나에게 전송된다. 
</br>

### 💎 02 오류 제어
데이터 링크 계층 프로토콜이 전송 오류 기능을 제공하려면, 우선 오류 발생 여부를 인지할 수 있어야 한다.   
오류의 종류에는 프레임 변형과 프레임 분실이 있다.   
오류를 감지하면 오류 복구 과정이 진행되는데, 컴퓨터 네트워크에서는 일반적으로 송신 호스트가 원래의 데이터를 재전송하는 기법을 사용한다.   
</br>

### 1. 전송 오류의 유형
전송 프레임의 오류를 극복하고, 상위 계층에 신뢰성 있는 전송 서비스를 제공하려면 다음과 같은 기본 기능을 이용해 오류 복구 기능을 제공해야 한다.    
</br>

> 송신 호스트의 응답 프레임
* 송신 호스트가 전송한 데이터의 프레임의 일부가 깨지는 프레임 변형 오류를 확인한 수신 호스트는 송신 호스트에 응답 프레임을 전송해 원래의 데이터 프레임을 재전송하도록 요구할 수 있다.
* 수신 호스트가 전송하는 응답 프레임의 종류에는 데이터 프레임이 정상적으로 도착했을 때 회신하는 **긍정 응답 프레임** 과 데이터 프레임이 깨졌을 때 회신하는 **부정 응답 프레임** 이 있다.
* 송신 호스트의 재전송 기능은 수신 호스트의 부정 응답 프레임 회신에 의해 이루어진다.
</br>

> 송신 호스트의 타이머 기능
* 프레임 분실 오류가 발생하면, 수신 호스트는 이 사실을 인지할 수 없다.
* 따라서 오류 복구 과정이 송신 호스트 주도로 이루어져야 한다.
* 송신 호스트는 데이터 프레임을 전송한 후에 일정한 시간 이내에 수신 호스트로부터 긍정 응답 프레임 회신이 없으면 **타임아웃** (Timeout) 기능을 동작시켜 데이터 프레임을 재전송한다.
</br>

> 순서 번호 기능
* 수신 호스트가 보낸 긍정 응답 프레임을 분실하면, 데이터 프레임이 제대로 도착해도 송신 호스트가 이를 인지할 수 없다.
* 따라서 송신 호스트가 타임아웃 기능에 의해 원래 프레임을 재전송함으로써 수신 호스트가 데이터를 중복 수신하는 결과를 초래한다.
* 이럴 때, 수신 호스트가 중복 데이터 프레임을 가려내려면, 각 프레임 내부에 **순서 번호**(Sequence Number)를 기록해야 한다.
* 데이터 프레임은 원래의 데이터 외에, 오류 검출을 위한 정보도 함께 제공한다.
* 오류 검출을 위한 정보에는 수신 호스트에서 오류를 감지하는 기능만 하는 정보와, 오류가 발생한 프레임을 복구하는 기능을 하는 정보가 있다.
* 오류를 감지만 하는 방법을 사용할 때는 송신 호스트의 도움을 받아 오류 복구 기능을 수행해야 한다.
* 즉, 수신 호스트가 데이터 프레임을 올바르게 수신하면 송신 호스트에 **긍정 응답**(Positive Acknowledgement) 프레임을 보냄으로써, 송수신 호스트 사이의 전송이 완결된다.
* 그러나 프레임 변형 오류가 발생하면 **부정 응답**(Negative Acknowledgement) 프레임을 회신해 송신 호스트의 재전송 기능에 따라 오류 복구 과정을 진행한다.
</br>

### 1.1 정상적인 전송
그림은 송신 호스트가 전송한 프레임이 오류 없이 수신 호스트에 전송된 경우이다.   

<img src="https://user-images.githubusercontent.com/83942393/129139521-87a2582b-e0c9-411a-af57-d6df3fd57fa0.png" width="50%" height="50%"></img></br>
그림 4-8 정상적인 데이터 전송   

* 수신 호스트는 데이터 프레임을 제대로 수신했다는 의미의 긍정 응답 프레임을 회신함으로써 하나의 데이터 프레임에 대한 전송 과정이 완료된다.
* 송신 호스트가 긍정 응답 프레임을 회신받지 못하면 데이터 프레임에 오류가 발생했다는 의미이다.
* 일반적으로 변형된 프레임을 수신한 수신 호스트는 부정 응답 프레임을 전송할 수도 있지만, 프로토콜의 종류에 따라서는 부정 응답 프레임을 지원하지 않을 수도 있다. 이때는 송신 호스트의 타임아웃 기능에 따라 오류 복구 기능을 시작한다.
* 데이터 프레임이 정상적으로 전송되었지만, 수신 호스트의 긍정 응답 프레임이 송신 호스트에게 도착하지 못해도 송신 호스트의 타임아웃 기능에 따라 오류를 복구한다.
</br>

### 1.2 프레임 변형
그림은 데이터 프레임이 수신 호스트에 도착했으나, 전송 과정에서 프레임의 내용이 변형되는 오류가 발생한 경우이다.

<img src="https://user-images.githubusercontent.com/83942393/129139837-7c6a3d5e-68fe-4abc-af61-9db309a628bc.png" width="50%" height="50%"></img></br>
그림 4-9 프레임변형 오류   

* 프레임 변형 오류를 인지한 수신 호스트는 송신 호스트에 부정 응답 프레임을 전송함으로써, 원래의 데이터 프레임을 재전송하는 오류 복구 과정이 진행된다.
*(앞서 언급한 것처럼 부정 응답 프레임을 사용하지 않는 프로토콜에서는 송신 호스트의 타임아웃 기능에 따라 복구 과정을 시작한다.)*   
* 한편, 재전송된 데이터 프레임은 \[그림 4-8]과 같이 올바르게 전송될 수도 있지만, 그림 \[4-9] 처럼 다시 변형 오류가 발생할 수도 있다.
* 또한 긍정 응답 프레임이나 부정 응답 프레임도 전송 과정에서 변형이나 분실과 같은 오류가 발생할 수 있다. 
* 따라서 데이터 링크 계층 프로토콜에서 다루는 전송 오류 문제의 원래는 매우 단순하지만, 프로토콜 설계 시 세심한 주의가 필요하다.
</br>

### 1.3 프레임 분실
* 데이터 링크 계층의 주요 기능 중 하나는 프레임을 전송한 송신 호스트에서 동작하는 타임아웃 기능이다.   
* 그림은 송신 호스트가 전송한 데이터 프레임이 전송 과정에서 사라지는 프레임 분실 오류가 발생하면, 수신 호스트는 송신 호스트로부터 어떠한 데이터 프레임도 전달받지 못했기 때문에 긍정 응답이나 부정 응답 프레임을 회신할 수 없다.   
* 결과적으로 송신 호스트도 응답 프레임을 회신받을 수 없어 응답 프레임을 무한정 기다려야 한다.   

<img src="https://user-images.githubusercontent.com/83942393/129140725-ab90e8e3-8157-43cb-b3ef-58ffaa727996.png" width="60%" height="60%"></img></br>

* 그림에서 수신 호스트가 데이터 프레임의 분실 여부를 인지할 수 있는 방법이 없다.
* 따라서 오류 복구는 송신 호스트의 주도로 타임아웃 기능에 따라 처리된다.
```
즉, 송신 호스트는 데이터 프레임을 전송한 후에 특정 시간까지 수신 호스트의 긍정 응답 프레임이 도착하지 않으면 타임아웃 기능에
따라 원래의 프레임을 스스로 재전송한다.
```
</br>

### 2. 순서 번호
데이터 링크 계층의 오류 복구 기능이 수행되는 과정에서 동일한 데이터 프레임이 수신 호스트에 중복해 도착할 수 있다.
따라서 오류 없이 수신된 중복 데이터 프레임을 가려내기 위해, 프레임 내부에 각 프레임의 고유 번호인 순서 번호(Sequence Number)를 기록한다.

### 2.1 순서 번호의 필요성
* 그림의 (a)처럼 올바르게 수신한 데이터 프레임에 대한 긍정 응답 프레임이 사라지는 오류가 발생하면, 송신 호스트의 타임 아웃 기능에 따라 재전송 과정이 진행된다.   
* 재전송된 데이터 프레임이 제대로 수신되면, 수신 호스트 입장에서는 **동일한** 프레임을 중복해 수신하는 결과가 초래된다.   

![image](https://user-images.githubusercontent.com/83942393/129141155-5a3201fd-8a81-4f37-8c64-19a6253bb13d.png)

* (b)는 긍정 응답 프레임이 올바르게 회신되고, 송신 호스트가 다음 데이터를 송신하여, 수신 호스트는 서로 다른 두 개의 데이터 프레임을 수신하게 된다.    
* 송신 호스트 입장에서 보면, 자신이 동일한 데이터 프레임을 두 번 전송했는지(a), 아니면 서로 다른 두 개의 데이터 프레임을 전송했는지(b) 구분할 수 있다.
* 그러나 수신 호스트는 두 경우를 구분할 수 없다.
* 따라서 수신 호스트가 두 경우를 구분할 수 있도록, 데이터 프레임별로 고유의 순서 번호를 부여하는 방식이 필요하다.
</br>

### 2.2 순서 번호에 의한 프레임 구분
그림은 데이터 프레임에 순서 번호를 부여해, 긍정 응답의 분실 문제를 해결하는 원리를 설명한다.     

<img src="https://user-images.githubusercontent.com/83942393/129141616-c49eba8e-d856-4e77-8e02-19a1dc78d645.png" width="50%" height="50%"></img></br>

<img src="https://user-images.githubusercontent.com/83942393/129141677-b2c8482a-5d98-40d0-8789-f1c882c5fe2d.png" width="50%" height="50%"></img></br>

* 위의 그림에서 데이터 프레임에 순서 번호만 추가했다.
* 수신 호스트는 (a)처럼 순서 번호에 근거하여 동일한 데이터 프레임이 재전송되어 중복 도착했는지, 아니면 (b)처럼 서로 다른 데이터 프레임이 도착했는지를 구분할 수 있다.
</br>

### 3. 흐름 제어
* 오류 제어와 함께 데이터 링크 계층에서 제공하는 주요 기능은 데이터 프레임의 전송 속도를 조절하는 것이다.
* 송신 호스트는 수신 호스트가 감당할 수 있을 정도의 전송 속도를 유지하면서 데이터 프레임을 전송해야 하는데, 이러한 기능을 흐름 제어(Flow Control)이라 한다.
* 흐름 제어 기능 부재에 따른 프레임 분실은 앞서 설명한 전송 오류의 프레임 분실과 동일한 결과를 가져오기 때문에, 이것도 데이터를 재전송하는 방법으로 복구해야 한다.
* 흐름 제어의 기본 원리는 수신 호스트가 다음에 수신할 데이터 프레임의 전송 시점을 송신 호스트에 통지하는 방식이다.
* 가장 많이 사용하는 흐름 제어 프로토콜의 예가 뒤에서 소개하는 슬라이딩 윈도우 프로토콜이다.  
</br>

### 💎 03 프레임
데이터 링크 계층에서는 전송 데이터를 **프레임**(Frame) 이라는 작은 단위로 나누어 처리한다.   
전송 프레임에는 상위 계층에서 보낸 전송 데이터의 오류를 확인하기 위한 체크섬(Checksum), 송수신 호스트의 주소, 기타 프로토콜에서 사용하는 제어 코드 같은 정보가 포함된다.   
프레임을 전송받은 수신 호스는 제일 먼저 체크섬을 확인해, 전송 중에 변형 오류가 발생했는지 확인해야 한다.   
오류가 발생하면 부정 응답 프레임을 회신하여, 송신 호스트가 원래의 데이터를 재전송하도록 요구함으로써 복구 과정을 시작해야 한다.   
프레임 내용에 포함되는 정보는 프로토콜의 용도에 따라 다르다.   
일반적으로 프레임은 내부 정보를 표현하는 방식에 따라 문자 프레임과 비트 프레임으로 구분된다.   
</br>

### 1. 문자 프레임
문자 프레임(Character Frame)은 프레임 내용이 문자로 구성되므로, 문자 데이터를 전송할 때 사용한다.
문자 프레임 방식은 8비트 단위(또는 ASCII 문자 코드)의 고정 크기로 동작한다.
</br>

### 1.1 프레임의 구조
* 하나의 프레임 단위를 구분하기 위해, 프레임의 앞뒤에 ASCII 코드의 특수 문자를 이용한다.
* 즉, 각 프레임의 시작 위치에 DLE, STX 문자를 추가하고, 끝나는 위치에는 DLE, ETX 를 추가해 프레임의 다른 정보와 구분할 수 있도록 한다.

그림의 (a)는 문자 프레임 방식의 프레임 구조이다.   

![image](https://user-images.githubusercontent.com/83942393/129143613-50966cec-1ad0-46c7-b189-c57295e8f67f.png)</br>
그림 4-13 문자 프레임의 구조   

* 이 방식에서 발생 가능한 문제점은 그림의 (b)처럼 데이터의 내용 중에 DLE, STX나 DLE, ETX 문자가 포함될 수 있다는 것이다.
* 결과적으로 프레임을 수신하는 호스트가 프레임의 시작과 끝 위치를 결정하는 데 혼선을 준다.
```
이러한 현상은 문자 프레임 방식을 사용해 실행 파일과 같은 이진 코드 데이터를 전송하는 경우에 발생할 확률이 높다.
```
</br>

### 1.2 문자 스터핑
* 문자 스터핑(Character Stuffing)은 프레임 내부의 전송 데이터에 DLE 문자가 포함되면, 송신 호스트가 전송하는 데이터를 미리 조작함으로써 혼선의 여지를 없앨 수 있다. 
* 즉, 그림의 (a)처럼 DLE 문자 다음에 DLE 문자 하나를 강제로 추가한다.

![image](https://user-images.githubusercontent.com/83942393/129144175-65d66efe-7678-446d-864f-071f8776dec2.png)
* 수신 호스트는 프레임 내용에 DLE 문자가 연속해서 두 번 나타나면 두 번째 DLE는 송신 호스트가 임의로 추가한 문자라고 판단할 수 있다.
* 따라서 상위 계층인 네트워크 계층에 데이터를 전달하기 전에, 둘 중 하나를 제거해야 한다.
* 그림의 (b)는 이를 설명하고 있으며, 송신 호스트가 최초에 전송한 프레임인 \[그림 4-13]의 (b)와 동일한 결과가 된다.

이와 같이 문자 프레임의 전송 과정에서 제어 문자를 추가하는 기능을 문자 스터핑이라 한다.   
문자 스터핑이 올바르게 동작하는 이유는, 프레임의 시작과 끝을 나타내는 제어 코드에는 어떤 경우에도 DLE 문자가 연속해서 두 번 발생하지 않기 때문이다.   
</br>

### 2. 비트 프레임
* 비트 프레임(Bit Frame) 방식은 문자 단위의 가정을 없애고, 임의의 비트 패턴 데이터를 전송할 수 있다.
* 프레임의 시작과 끝 위치에 플래그(Flag)라는 특수하게 정의된 비트 패턴(01111110)을 사용해 프레임 단위를 구분한다.
* 문자 프레임 방식에서 DLE 패턴이 프레임의 내용에 나타날 가능성이 있는 것처럼, 비트 프레임 방식에서도 전송 데이터에 플래그와 동일한 비트 패턴을 포함할 수 있다.
* 따라서 데이터의 내용에 이 패턴이 나타나면, 전송하기 전에 이를 적당히 조작하는 과정이 필요하다.
</br>

### 2.1 프레임의 구조
그림은 비트 프레임의 구조이다.
</br>
</br>

<img src="https://user-images.githubusercontent.com/83942393/129144863-b3445543-2fde-4d93-883d-4caed50c67a3.png" width="70%" height="70%"></img></br>
</br>

* 데이터를 전송하기 전에 프레임의 좌우에 플래그를 추가하고, 수신 호스트는 이 플래그를 제거해 전송 데이터와 필요한 제어 정보를 상위 계층에 전달할 수 있다.
</br>

### 2.2 비트 스터핑
* 비트 프레임 방식에서는 송신 호스트가 전송하고자 하는 데이터의 내용 중에 값이 1인 패턴이 연속해서 5번 발생하면, 강제로 0을 추가해 전송한다.
* 플래그는 1이 연속해서 6개 나오는 패턴이므로, 원천적으로 데이터 내용에 플래크 패턴이 발생하는 것을 차단하기 위함이다.

그림의 프레임의 내용에 굵게 표시된 0은 송신 호스트가 추가한 비트이다.   
</br>

<img src="https://user-images.githubusercontent.com/83942393/129145165-afb01856-8e6b-4f19-8d29-9f4f2ed6c9c3.png" width="70%" height="70%"></img></br>
</br>

* 수신 호스트가 수신한 데이터의 내용에서 플래그 패턴 외에는 어떤 경우도 1이 연속해서 5개를 넘지 않는다.
* 다시 말해서 플래그 패턴과 동일한 형태의 패턴이 데이터 링크 계층의 전송 데이터에는 발생할 수 없다.
* 이와 같은 기능을 비트 스터핑(Bit Stuffing)이라 하며, 수신 호스트는 송신 과정에서 추가된 0을 제거하여, 원래의 데이터를 상위 계층에 전달한다.
</br>

### 💎 04 다항 코드
프레임 전송 과정에서 발생하는 오류를 극복하는 방법은 크게 두 가지이다.   

첫 번째 방법은, 전송 프레임에 오류 검출 코드를 넣어 수신 호스트가 전송 과정의 오류를 검출하도록 하는 것이다.   
이 방법의 오류 복구는 주로 재전송이 이루어진다.   
가장 간단한 오류 검출 코드 방법은 패리티 비트를 추가하는 것이고, 컴퓨터 네트워크에서는 일반적으로 다항 코드 방식을 사용한다.   

두 번째 방법은, 프레임에 오류 복구 코드를 넣어 수신 호스트가 오류 검출과 복구 기능을 모두 수행하도록 하는 것이다.   
예를 들어, 해밍 코드(Hamming Code)는 1비트 오류를 검출하고 복구하는 기능이 있다.   
오류 복구 코드를 사용해 수신 호스트가 오류 복구 기능을 수행하는 방식을 순방향 오류 복구(FEC, Forward Error Correction)라 한다.    
</br>

### 1. 오류 검출
* 네트워크에서는 일반적으로 오류 복구 코드를 이용한 순방향 오류 복구 방식은 사용하지 않고, 재전송(Retransmission) 방식을 이용해 오류를 복구한다. 
* 이를 역방향 오류 복구(BEC, Backward Error Correction) 또는 ARQ(Automatic Repeat reQuest) 방식이라 한다. 
* 역방향 오류 복구 기능을 수행하려면, 수신한 프레임에 오류가 있는지 판단할 수 있어야 한다.
* 이를 위해서는 송신 호스트가 오류를 검출하기 위한 코드를 전송 데이터와 함께 송신해야 한다.
* 오류 검출 코드는 패리티 비트, 블록 검사, 다항 코드 등을 이용해 생성할 수 있다.
</br>

### 1.1 패리티 비트
* 1바이트(8비트) 구조에서 패리티(Parity) 비트는 7비트의 ASCII 코드를 제외한 나머지 1비트이다.
* 패리티 비트는 전송 과정에서 1비트 오류를 검출하기 위한 것으로, 패리티 비트를 포함해 1의 개수가 짝수나 홀수 개가 되도록 한다.
* 예를 들어, 그림과 같이 1101001이라는 데이터를 **짝수 패리티** (Even Parity) 방식을 사용해 전송하려면, 11010010의 형태로 만들어 전송한다.
* 즉, 짝수 패리티 방식에서는 데이터 끝에 패리티 비트를 추가해 전체 1의 개수를 짝수로 만들어준다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/129147785-a7a77ad5-c92c-4ac3-92da-a58b9c855064.png" width="45%" height="45%"></img></br>

* 데이터 전송 과정에서 1비트 오류가 발생하면, 1의 개수가 홀수 개로 바뀐다.
```
예를 들어, 위의 데이터 전송 과정에서 세 번째 비트가 0에서 1로 바뀌면, 수신 호스트는 11110010을 받는다.
```
* 수신 호스트는 패리티 검사를 통해 1의 개수가 홀수로 변경된 사실을 알게 되어, 데이터 전송 과정에서 1비트 오류가 발생했음을 확인할 수 있다.
* **홀수 패리티** (Odd Parity) 방식은 짝수 패리티와 반대로, 1의 개수를 홀수로 만드는 것이다.
* 송신 호스트와 수신 호스트는 짝수 패리티나 홀수 패리티 중 동일한 한 간지 방식을 사용해야 한다.
</br>

### 1.2 블록 검사
* 패리티 방식을 이용한 오류 검출 기법은 1비트 오류에 간단히 적용할 수 있다.
* 그러나 짝수 개의 비트에서 오류가 발생하면 오류가 검출되지 않는 문제점이 있다.
```
예를 들어, 2비트의 데이터가 깨지면, 1의 개수는 원래의 데이터와 같은 짝수나 홀수를 유지한다.
```

<img src="https://user-images.githubusercontent.com/83942393/129146471-5a484bc1-8a86-49f9-a243-c93046906896.png" width="80%" height="80%"></img></br>
</br>
</br>

* 다수의 비트에서 오류가 발생할 때 오류를 검출하는 방법으로는 패리티 방식을 개선한 **블록 검사** (Block Sum Check) 가 있다.
* 이 방식은 아래 그림과 같이, 여러 개의 바이트를 하나의 블록으로 구성한 후, 교차 검사를 한다.
* 즉, 블록 데이터의 수평과 수직 방향에 모두 패리티 비트를 둠으로써 오류 검출 확률을 높인다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/129148634-df6f3fd9-5b1f-4c80-8057-e3d48f5b60da.png" width="60%" height="60%"></img></br>
</br>

* 그림에서 오른쪽에 표시된 패리티 비트는 수형 방향으로 홀수 패리티를, 아래쪽에 블록 검사 비트로 표시한 데이터는 수직 방향으로 짝수 패리티를 적용한 것이다.
* 따라서, 수평 방향으로 짝수 개의 비트가 꺠지면 수직 방향의 블록 검사 비트로 오류를 검출하고, 수직 방향으로 짝수 개의 비트가 꺠지면 수평 방향의 패리티 비트로 오류를 검출한다.
* 이 방식의 문제점은 전송되는 데이터의 양과 비교해 오류 검출을 위한 오버헤드가 크다는 점이다.
* 또, 수평과 수직 방향에서 모두 사각형 형태로 짝수 개의 데이터 오류가 발생하면 이를 검출하지 못한다.
</br>

### 2. 다항 코드



















