### 🔆 Preview
네트워크 계층은 전송 데이터인 패킷을 목적지까지 올바른 경로로 전달해준다.    
패킷은 최종목적지까지 전달되는 과정에서 라우터를 거치는데, 이때 적절한 경로를 선택해 패킷을 전달하는 라우팅 기능이 수행된다.   
패킷을 적절한 경로로 전송하려면 네트워크 계층에서 네트워크의 연결 구성에 관한 정보를 관리해야 한다.    

네트워크 계층의 또 다른 역할은 네트워크의 특정 경로로 트래픽이 집중되지 않게 하는 것이다.    
특정 경로에 혼잡이 발생하면 네트워크의 전체 성능이 떨어지므로 올바른 경로를 선택해 특정 지역에 과부하가 발생하지 않도록 해야 한다.    

인터넷은 전 세계의 모든 컴퓨터가 촘촘하게 연결된 거대한 컴퓨터 통신망이다.    
송신자가 전송한 데이터가 올바른 경로로 전달될 수 있는 이유는 네트워크 계층에 라우팅 기능이 있기 때문이다.   
따라서 라우팅 기능을 이해하면, 거대 인터넷에서 데이터가 올바르게 목적지까지 전달되는 원리를 파악할 수 있다.   
특히, IP 프로토콜의 구조를 이해함으로써, 실제 인터넷 환경에서 사용자 데이터가 어떤 원리로 전송되는지 확인할 수 있다.    

7장에서는 네트워크 계층의 중요한 기능인 라우팅의 원리와 관련 프로토콜에 대하여 학습한다.
라우팅은 혼잡 제어 기능과 함께 네트워크 계층의 중요한 역할에 속한다.    
더불어 인터넷에서 실제로 사용하는 IP 프로토콜의 구조와 동작 방식을 학습함으로써, 네트워크 계층에 대한 이해를 높인다.    
</br>

## 💎 01 네트워크 계층의 기능
네트워크 계층의 기본 기능은 송수신 호스트 사이의 패킷 전달 경로를 선택하는 라우팅이다.   
라우팅 과정에서 일어나는 문제도 네트워크 계층에서 처리한다.   
이와 관련된 대표적인 기능이 네트워크의 특정 지역에 트래픽이 몰리는 현상을 다루는 혼잡 제어와 라우터 사이의 패킷 중개 과정에서 다루는 패킷의 분할과 병합이다.   
</br>

네트워크 계층에서 제공하는 주요 기능을 정리하면 다음과 같다.    
</br>

> 라우팅
* 네트워크의 구성 형태에 대한 정보는 **라우팅 테이블** (Routing Table)이라는 기억 장소에 보관된다.
* 이 정보를 이용해 패킷이 목적지까지 도달하기 위한 경로를 선택한다.
* 송수신 호스트 사이의 패킷 전달 경로를 선택하는 과정을 라우팅이라 하고, 라우팅 테이블 정보는 네트워크 관리자나 네트워크 자신의 판단에 의해 계속 변경될 수 있다.
</br>

> 혼잡 제어
* 네트워크에 패킷 수가 과도하게 증가하는 현상을 **혼잡** (Congestion) 이라 하고, 혼잡 현상을 예방하거나 제거하는 기능을 **혼잡 제어** (Congestion Conrol)이라 한다.
* 혼잡이 발생하면, 네트워크 전체의 전송 속도가 급격히 떨어지므로 혼잡이 발생하지 않도록 관리해야 한다.
* 특히 네트워크의 특정 지역에서 혼잡이 발생하면, 혼잡의 특성상 주위로 빠르게 확산될 가능성이 높다.
</br>

> 패킷의 분할과 병합
* 상위 전송 계층에서 송신을 요구한 데이터는 최종적으로 MAC 계층의 프레임 구조에 정의된 형식으로 캡슐화되어 물리적으로 전송된다.
* 따라서 전송 계층에서 보낸 데이터가 너무 크면, 여러 개의 패킷으로 작게 쪼개 전송해야 한다.
* 이와 같이 큰 데이터를 여러 패킷으로 나누는 과정을 패킷 **분할** (Segmentation)이라 하고, 반대로 목적지에서 분할된 패킷을 다시 모으는 과정을 **병합** (Reassembly)이라 한다. 
* 패킷의 분할과 병합 과정이 양 끝단 시스템 사이에서 이루어지는 경우라면, 전송 계층이 동작하는 종단 수신 시스템에 분할된 패킷을 보내고, 네트워크 계층에서 이루어지는 경우라면 중간의 각 라우터에서 분할과 병합을 반복한다.
</br>

### 1. 연결형 서비스와 비연결형 서비스
네트워크 계층이 전송 계층에 제공하는 서비스는 크게 두 가지이다.    

그림처럼 패킷을 전송하기 전에 송수신 호스트 사이에 연결을 설정하는 연결형 서비스와,   
연결 없이 데이터를 패킷 단위로 전송하는 비연결형 서비스이다.   

<img src="https://user-images.githubusercontent.com/83942393/130536796-0f5df2fc-28a5-41b4-a5f2-9ebec9ac2a79.png" width="60%" height="60%"></img></br>
</br>

### 1.1 비연결형 서비스
* 비연결형 서비스(Connectionless Service)는 패킷의 전달 순서, 패킷 분실 여부 등에서 연결형 서비스보다 신뢰성이 떨어지는 전송 방식이다.
* 따라서 전송 계층에서 네트워크 계층의 비연결형 서비스를 이용할 떄는 연결형 서비스를 이용하는 경우보다 자체적으로 오류 제어와 흐름 제어 기능을 더 많이 수행해야 한다.
* 패킷이 서로 다른 경로를 통해 목적지 호스트로 전달되기 때문에 패킷이 전달되는 순서가 일정하지 않을 수 있다.
* 따라서 상위 계층인 전송 계층은 수신한 패킷의 순서를 재조정하는 기능이 필요하다.
* 인터넷 환경에서 네트워크 계층의 기능을 지원하는 IP 프로토콜은 비연결형 서비스의 대표적인 예이다.
* IP 프로토콜 위에서 동작하는 전송 계층 프로토콜인 TCP 는 연결형 서비스를 지원하고, 또 다른 전송 계층 프로토콜인 UDP 는 비연결형 서비스를 지원한다.
</br>

### 1.2 연결형 서비스
* 연결형 서비스(Connection-oriented Service)는 상대적으로 신뢰성이 높은 서비스로, 패킷을 전송하기 전에 연결을 미리 설정하여 송신하는 방식이다.
* 비연결형 서비스와 달리 전달되는 패킷들이 모두 동일한 경로를 이용하기 때문에 목적지에 도착하는 패킷의 순서가 송신된 순서와 동일하다는 특성이 있다.
</br>

### 2. 라우팅
* 라우팅은 네트워크 계층에서 가장 중요한 역할이다.
* 라우팅은 들어온 패킷을 어느 출력 경로를 통해 다음 호스트로 전달해야 가장 효과적인지 결정하는 것이다.
* 가상 회선 방식을 사용하는 연결형 서비스에서 송수신 호스트 사이의 경로 선택은 연결이 설정되는 시점에 한 번만 결정하고, 이후의 패킷들은 이 경로를 따라 목적지까지 전달된다.
* 따라서 전송되는 모든 패킷이 동일 경로를 거치고, 패킷의 전달 순서도 일정하게 유지된다.
* 그러나 비연결형 방식인 데이터그램을 사용하면 연결 설정 과정이 없기 때문에 송수신 호스트 사이에 고정 경로가 존재하지 않는다.
* 따라서 전송 패킷마다 독립적인 전달 경로를 선택해야 한다.
</br>

* 패킷의 전송 경로를 결정할 때는 고려할 사항이 많은데,
* 특정 패킷을 우선 처리하려고 다른 패킷들에 손해를 입히지 않는 정책도 이 중 하나이다.
* 이 정책은 모든 전송 패킷에 대해 라우팅 과정이 공평해야 한다는 원칙에 따른다.
* 그러나 이와 상반되는 조건으로 전체 네트워크의 성능과 관련해 효율성 문제도 함께 고려해야 한다.
* 네트워크 이용의 효율성과 관련된 요소에는 패킷의 평균 지연 시간, 전체 네트워크의 성능에 대한 영향, 중개 과정에서 거치는 라우터 수의 최소화 등이 있다.
</br>

### 2.1 정적·동적 라우팅
의도적 혹은 비의도적으로 발생하는 네트워크의 구성의 변화에 효과적으로 대처할 수 있는 신뢰성 확보도 라우팅 경로 선택 시 중요하게 고려할 사항이다.(라우팅 테이블 갱신 유무)   

라우팅 경로는 정적 라우팅이나 동적 라우팅 방식으로 선택한다.   
</br>

> 정적 라우팅
* 정적 라우팅(Static Routing)은 송수신 호스트 사이에서 패킷 전송이 이루어지기 전에 경로 정보를 라우터에 미리 저장하여 중개하는 방식이다.
* 패킷을 중개하기 위한 최적의 경로 정보는 라우터별로 저장하여 관리하는데, 운용 중인 네트워크의 구성에 변화가 생기면, 이에 적절하게 대처할 수 없다는 문제점이 있다.
* 즉, 라우터에 보관된 경로 정보가 고정되어, 변화된 정보를 갱신하기가 쉽지 않으며, 특히 네트워크 내부의 혼잡도를 반영할 수 없다는 단점이 있다.
</br>

> 동적 라우팅
* 동적 라우팅(Dynamic Routing)은 라우터에서 사용하는 경로 정보를 네트워크 상황에 따라 적절하게 변경하는 방식으로, 경로 정보의 변경 주기에 따라 계속 보완할 수 있다.
* 따라서 현재의 네트워크 상황을 고려해 최적의 경로 정보를 선택할 수 있지만, 경로 정보를 수집하고 관리하는 등의 복잡한 작업이 추가로 필요하다.
* 이는 네트워크에 새로운 부하를 가해 성능에 부정적인 영향을 미친다.
* 동적 라우팅 방식을 사용하려면 현재의 네트워크 링크 상태를 점검해 이를 새로운 경로 배정 시 적용해야 한다.
* 우선 각 라우터에서는 이웃 라우터의 존재 유무와 전송 지연 시간 등을 확인할 수 있어야 한다.
* 또한 각각의 라우터가 획득한 경로 정보를 다른 라우터들에 통보함으로써, 네트워크의 최신 경로 정보를 신속하게 공유하고 갱신해야 한다.
</br>

### 2.2 HELLO/ECHO 패킷
* 라우터의 초기화 과정에서 가장 먼저 할 일은, 이웃 라우터의 경로 정보를 파악하는 것이다.
* 각 라우터는 이웃에 연결된 라우터에, 초기화를 위한 HELLO 패킷을 전송해 경로 정보를 얻는다.(어떤 이웃들이 있는지)
* 라우터 사이의 전송 지연 시간을 측정하기 위해서 ECHO 패킷을 전송하는데, ECHO 패킷을 수신한 호스트는 송신 호스트에 즉각 회신하도록 설계되어 있고, 이러한 과정을 반복하여 측정값의 평균을 구해 해당 라우터까지의 전송 * 지연 시간을 유추할 수 있다.
* 지연 시간을 측정하는 과정에서, 측정 시점의 네트워크 트래픽 정도에 따라 결과가 달라질 수 있기 때문에 측정 오차의 차이를 어떻게 해석할지는 신중히 판단해야 한다.
</br>

* 앞에서 언급했듯이, 임의의 라우터가 획득한 정보를 다른 라우터에 통보하여 경로 정보를 공유한다.
* 그런데 경로 정보가 개별 라우터에 도착하는 시간이 서로 일치하지 않기 때문에 특정 시점에서 각각의 라우터가 바라보는 네트워크 상태는 같지 않을 수 있다.
* 특히, 여러 라우터에서 정보가 생성되는 경우에는 네트워크 내부의 경로 정보를 일관성 있게 유지하기 어렵다.
</br>

### 2.3 라우팅 테이블
* 패킷 전송 과정에서 라우터들이 적절한 경로를 쉽게 찾도록 하기 위한 가장 기본적인 도구로 라우팅 테이블(Routing Table)을 사용한다.
* 라우팅 테이블에 포함해야 하는 필수 정보는 (목적지 호스트, 다음 홉) 의 조합이다.
* '목적지 호스트'에는 패킷의 최종 목적지가 되는 호스트의 주소 값을, '다음 홉'에는 목적지 호스트까지 패킷을 전달하기 위한 이웃 라우터를 지정한다.
* 즉, 목적지까지 도달하는 여러 경로 중에서, 효과적인 라우팅을 지원하는 경로가 있을 수 있는데, 이 경로에서 바로 다음 홉(hop)에 위치한 라우터의 주소를 기록한다.
</br>

그림은 목적지 호스트와 다음 홉의 조합을 설명한다.    
* (a)의 네트워크 연결 구성의 예에서 호스트 1이 관리하는 라우팅 테이블의 정보는 (b)와 같다.
* 라우팅 테이블 정보는 네트워크에 연결된 모든 호스트에 존재하며, 호스트마다 관리하는 정보의 내용은 다르다.
</br>

<img width="575" alt="스크린샷 2021-08-24 오전 9 32 23" src="https://user-images.githubusercontent.com/83942393/130536800-822810fa-7c5d-4df2-bb86-7fd290555c77.png">
</br>

```
라우팅 테이블 정보를 경로 선택 과정에서 어떻게 이용하는지 설명하기 위해, 호스트 1에서 목적지 호스트 11로 향하는 패킷을 가정해보자.
라우팅 테이블에 목적지가 호스트 11일 때의 다음 홉 값이 4번 라우터로 지정되어 있으므로 호스트 1은 패킷을 4번 라우터에 전송한다.
4번 라우팅은 그림에 표시하진 않았지만, 다시 자신의 라우팅 테이블 정보를 이용해 전송 경로에 있는 다음 홉의 호스트에 패킷을 전달한다.
패킷이 최종 목적지에 도착할 때까지 이러한 과정을 반복한다.

이와 같이 네트워크 계층에서 패킷 라우팅은 라우팅 테이블 정보를 이용해 라우터의 단계별 중개 과정을 거쳐서 이루어진다.
```
</br>

### 2.4 라우팅 정보의 처리
라우팅을 효과적으로 수행하려면 라우팅 정보가 네트워크의 **현재 상황을 정확히 반영할 수 있도록 관리** 해야 한다.   
라우팅 정보 관리와 관련된 처리 방법에는 소스 라우팅, 분산 라우팅, 중앙 라우팅, 계층 라우팅 등이 있다.   
</br>

> 소스 라우팅
* 패킷을 전송하는 호스트가 목적지 호스트까지 전달 경로를 스스로 결정하는 방식을 소스 라우팅(Source Routing)이라 한다.
* 소스 라우팅을 지원하려면 송신 호스트의 라우팅 테이블에서 패킷을 수신 호스트까지 전달하기 위한 경로 정보를 관리해야 하며, 이러한 경로 정보를 전송 패킷에 기록해야 한다.
* 소스 라우팅 방식은 모든 라우팅 정보를 송신 호스트가 관리하므로 중간에 있는 라우터들은 라우팅 테이블을 따로 관리할 필요가 없다.
* 중간 라우터에서는 전송 패킷에 포함된 경로 정보를 이용해 패킷을 중개함으로써 최종 목적지까지 올바르게 전달할 수 있다.
</br>

* 소스 라우팅은 데이터그램과 가상 회선 방식에서 모두 이용할 수 있다.
* 가상 회선 방식에서는 연결의 초기화 과정에서 경로 정보를 담은 특수 연결 패킷을 사용한다.
* 중간 라우터는 패킷의 경로 정보를 해석함으로써 전달 경로를 선택할 수 있다.
* 데이터그램 방식에서는 전송되는 모든 패킷의 헤더에 경로 정보가 들어가므로 일반적인 데이터그램 방식에 비하여 신뢰성을 향상시킬 수 있다.
</br>

> 분산 라우팅
* 분산 라우팅(Distributed Routing)은 라우팅 정보가 분산되는 방식으로 패킷의 전송 경로에 위치한 각 라우터가 효율적인 경로 선택에 참여한다.
* 분산 라우팅은 데이터그램 방식에서 많이 사용한다.
* 이 방식의 장점은 네트워크에 존재하는 호스트의 수가 많아질수록, 다른 방식보다 효과적일 수 있다는 것이다.
* 라우터가 관리하는 경로 정보는 다음 경로를 선택하기 위한 내용을 포함하는데, 네트워크 상황에 따라 적절히 변경하는 동적 특징이 있다.
</br>

> 중앙 라우팅
* 중앙 라우팅(Centeralized Routing)은 RCC(Routing Control Center) 라는 특별한 호스트를 사용해 전송 경로에 관한 모든 정보를 관리하는 방식이다.
* 패킷 전송을 원하는 송신 호스트는 반드시 RCC로부터 목적지 호스트까지 도착하기 위한 경로 정보를 미리 얻어야 한다.
* 이 정보를 이용해 송신 호스트는 소스 라우팅과 동일한 원리로 패킷을 전송한다.
</br>

* 중앙 라우팅의 장점은 경로 정보를 특정 호스트가 관리하기 때문에 다른 일반 호스트가 경로 정보를 관리하는 부담을 줄일 수 있다.
* 그러나 네트워크의 규모가 커짐에 따라 RCC 에 과중한 트래픽을 주어 전체 효율이 떨어질 수 있다는 단점이 있다.
</br>

> 계층 라우팅
* 계층 라우팅(Hierarchical Routing) 은 분산 라우팅 기능과 중앙 라우팅 기능을 적절히 조합하는 방식으로, 전체 네트워크의 구성을 계층 구조 형태로 관리한다.
* 일반적으로 네트워크 규모가 계속 커지는 환경에 효과적이다.
</br>

### 3. 혼잡 제어
네트워크에 존재하는 전송 패킷의 수가 많아질수록 네트워크의 성능은 자연스럽게 감소한다.    
이와 같은 성능 감소 현상이 급격하게 악화되는 현상을 혼잡(Congestion)이라 하고, 혼잡 문제를 해결하기 위한 방안을 혼잡 제어(Congestion Control)이라 한다.   

흐름 제어(Flow Control)는 송신 호스트와 수신 호스트 사이의 논리적인 점대점 전송 속도를 다룬다.   
반면, 혼잡 제어는 더 넓은 관점에서 호스트와 라우터를 포함한 서브넷에서 네트워크의 전송 능력 문제를 다룬다.   


<img width="567" alt="스크린샷 2021-08-24 오전 10 16 00" src="https://user-images.githubusercontent.com/83942393/130540197-1f3e19bf-1627-4de2-8e24-e2ba719c4f33.png">
</br>

* 혼잡이 발생하는 원인은 다양한데, 기본적으로 네트워크의 처리 능력보다 지나치게 많은 패킷이 입력되면 혼잡이 발생한다.
```
개별 라우터 관점에서 보면, 라우터의 출력 선로를 통한 전송 용량이 부족해 아직 전송하지 못한 패킷이 버퍼에 저장되고,
입력 선로로 들어오는 패킷이 늘면서, 버퍼 용량은 더 부족해진다.
결과적으로 라우터의 내부 버퍼 용량 부족이 심화되어 더 이상 패킷을 보관할 수 없어 버리게 된다.
전송 패킷이 버려지면, 송신 호스트는 타임아웃 동작을 통해 패킷을 재전송하므로 네트워크로 송신되는 패킷의 양이 점점 늘어난다.

라우터에서 패킷을 잃어버리지 않으려면 버퍼 용량을 늘려야 하는데, 버퍼 용량이 늘면 패킷의 전송 지연 시간도 함께 늘어난다.
패킷의 전송 지연 시간이 송신 호스트가 설정한 타임아웃 시간보다 크면 재전송 과정이 증가할 수 있다.
그러면 네트워크로 보내지는 패킷의 양과 중복 패킷을 수신하는 현상도 증가하여 네트워크 혼잡도가 계속 증가하는 악순환을 초래한다.
```
</br>

### 3.1 혼잡의 원인
* 앞서 언급한 것처럼 혼잡이 일어나는 주요인은 전송 시간 초과에 의한 타임아웃 기능을 통해 패킷들이 재전송되는 데 있다.
* 특히 혼잡 초기에 패킷의 전송 지연이 점점 증가할 때, 타임아웃 값이 너무 작으면 혼잡도가 급격히 증가할 우려가 있다.
* 따라서 네트워크에 혼잡 징후가 보이면 이를 감지해 타임아웃 시간을 늘리는 방안이 필요하다.
</br>

* 패킷의 도착 순서가 뒤바뀌면 수신 호스트는 패킷을 보관하거나 그냥 버릴 수도 있다.
* 그런데 패킷을 버리면 패킷 재전송 현상이 발생해 네트워크 혼잡도를 높이는 원인이 된다.
</br>

* 패킷이 제대로 수신되었는지를 송신 호스트에 알려주는 응답 알고리즘도 혼잡에 영향을 준다.
* 즉, 수신한 패킷들에 대해 즉시 응답하는 방식을 사용하면 수신 패킷 모두에 대하여 개별 응답 패킷이 발생한다. 
* 따라서 패킷 여러 개를 모아 하나의 응답으로 처리하는 방식이나 피기배킹을 사용하는 방식과 비교하면 혼잡도가 미치는 영향이 다륻다.
* 그렇지만, 피기배킹 방식을 이용하는 응답 방식은 혼잡이 발생했을 때 송신 호스트의 타임아웃 기능을 통한 재전송을 유발하여 혼잡을 오히려 가중시킬 우려도 있다.
</br>

* 라우팅 알고리즘도 혼잡에 영향을 미칠 수 있다.
* 예를 들어, 혼잡이 발생되고 있는 경로보다는 전송 트래픽이 적은 경로를 찾아 패킷을 전송하면 혼잡도를 줄일 수 있다.
</br>

* 네트워크에서 전송 중인 패킷은 수신 호스트에 도착할 때까지 목적지를 향해 무한정 라우팅되지는 않는다.
* 패킷별로 네트워크에 존재할 수 있는 일정한 생존 시간을 지정해 이 시간을 초과하지 않도록 설계하는 것이 일반적이다.
* 생존 시간의 처리는 각 라우터를 통과할 때마다 홉수를 증가시켜 계산하는데( 논리적으로 볼 때 전송 과정에서 거쳐 온 홉의 개수가 증가한다는 의미이고, 일반 구현 과정에서는 패킷의 특정 필드 값을 감소시키는 방식으로 동작한다. ) 일정한 개수 이상의 라우터를 통과하면 엉뚱한 경로를 떠도는 것으로 판단하여 해당 패킷을 네트워크에서 제거한다.
* 수신 호스트에 도착할 가능성이 희박한 패킷의 생존 시간을 너무 크게 설정하면 네트워크에 불필요한 부하를 주는 문제점이 있고, 너무 작게 설정하면 수신 호스트에 도달하기도 전에 패킷을 강제로 제거하여 타임아웃을 통한 재전송이 발생할 수 있다.
</br>

### 3.2 트래픽 성형
* 혼잡은 트래픽이 특정 시간에 집중되는 버스트(Burst) 현상에서 기인하는 경우가 많다.
* 즉, 송신 호스트에서 전송하는 패킷의 양이 시간대별로 일정하게 발생하는 경우보다 짧은 시간동안 많이 발생하는 경우에 혼잡이 일어날 확률이 높다.
* 따라서 송신 호스트가 전송하는 패킷의 발생 빈도가, 네트워크에서 예측할 수 있는 전송률로 이루어지게 하는 기능(일정한 전송률로 발생하게 하는 기능)이 필요한데, 이를 트래픽 성형(Traffic Shaping) 이라 한다.
</br>

* 송신 호스트는 사전에 네트워크와 협상하여 네트워크로 유입되는 패킷의 특성을 조율할 수 있다.
* 협상을 통해 네트워크로 유입되는 패킷의 분포 특성을 미리 정해두면, 네트워크에서는 전체 트래픽의 혼잡도를 예측하여 혼잡 제어를 효율적으로 수행할 수 있다.
* 송신 호스트가 사전에 약속한 트래픽보다 과도한 양의 패킷을 전송하면, 네트워크에서 적절히 통제해야 한다.
* 예를 들어, 네트워크에서 처리하기에 과도한 트래픽이 발생하면, 협상 내용의 위반에 따라 패킷 처리를 거부할 수 있다.
* 이와 같은 트래픽 성형과 관련된 알고리즘 중에서 유명한 것이 **리키 버킷** (Leaky Bucket)이다.
</br>

그림은 리키 버킷 알고리즘의 동작 과정을 설명한다.   

<img width="660" alt="스크린샷 2021-08-24 오전 10 46 50" src="https://user-images.githubusercontent.com/83942393/130542516-34deff84-4824-4a23-a205-7c6c43e42927.png">

* 먼저 송신 호스트와 네트워크 사이에는 송신 호스트가 협상에서 제시한 전송 특성을 반영하는 적절한 크기의 깔때기가 위치한다.
* 깔때기의 출구 크기는 협상 결과를 의미하므로, 크기가 고정되어 있다.
* 따라서 송신 호스트가 협상 값보다 많은 양의 패킷을 전송해도 깔때기 크기 이상의 패킷이 네트워크에 유입될 수 없다.
* 과도하게 입력된 패킷은 깔때기의 부피 범위 내에서 내부 버퍼에 임시 저장된다.
* 깔때기에 저장할 수 있는 패킷의 양은 일정하며, 한계치를 초과하면 패킷이 넘쳐 패킷 분실 오류가 발생한다.
</br>

> 리키 버킷 알고리즘을 사용하면 송신 호스트로부터 입력되는 패킷이 시간대별로 일정하지 않아도, 즉 가변적이어도 깔때기를 통과하면서 일정한 전송률로 변경된다.
</br>

### 3.3 혼잡 제거











