### 1.2 패킷 분할 관련 필드
IP 프로토콜은 상위 계층에서 내려온 전송 데이터가 패킷 하나로 전송하기에 너무 크면 분할(Fragmentation)해 전송하는 기능을 제공한다.
다음은 패킷 분할과 관련된 필드이다.

* Identification(식별자 혹은 구분자) : IP 헤더의 두 번째 워드에는 패킷 분할과 관련된 정보가 포함된다. 이 중 Identification 필드는 송신 호스트가 지정하는 패킷 구분자 기능을 수행한다. IP 프로토콜이 분할한 패킷들에 동일한 고유 번호를 부여함으로써, 수신 호스트가 Identification 번호가 같은 패킷을 다시 병합(Reassembly) 할 수 있도록 해준다. 패킷을 분할하지 않으면 패킷을 전송할 때마다 이 필드의 값을 하나씩 증가시킨다.
* DF(Don't Fragment) : 패킷이 분할되지 않도록 한다. 즉, 값을 1로 지정하면 패킷 분할을 막을 수 있다. 수신 호스트가 분할되어 입력된 패킷들을 병합하는 기능이 없을 때 사용한다. 따라서 중간 경유 네트워크에서는 자신이 처리 가능한 패킷의 크기보다 큰 IP 패킷에 DF 필드가 설정되어 있으면 분할 기능을 수행하지 않고 패킷을 버린다.
* MF(More Fragment) : 분할된 패킷을 전송할 때는 여러 개의 분할 패킷이 연속해서 전송되므로 MF 필드 값을 1로 지정하여, 분할 패킷이 뒤에 계속됨을 표시해주어야 한다. 분할 패킷 중 마지막 패킷은 MF 비트를 0으로 지정하여 분할 패킷이 더 없음을 표시한다.
* Fragment Offset(분할 옵셋) : 패킷 분할이 이루어지면 12비트의 Fragment Offset 필드를 사용한다. 지정되는 값은 분할된 패킷의 내용이 원래의 분할 전 데이터에서 위치하는 상대 주소 값이다. 값은 8바이트의 배수이므로, Fragment Offset 값이 64라면 원래 데이터에서 64x8 = 512 번 째에 위치한다.
</br>

### 1.3 주소 관련 필드
* Source Address 는 송신 호스트의 IP 주소이고, Destination Address 는 수신 호스트의 IP 주소이다. 
* IP 주소 체계는 다음 그림과 같이 크게 다섯 종류이다.
* 클래스 A, B, C는 유니 캐스팅에서 이용하고, 클래스 D 는 멀티 캐스팅에서 이용한다. 
* 클래스 E 는 향후의 새로운 응용 환경을 위하여 잠정적으로 예약된 클래스이다.
</br>

* 클래스 A, B, C는 주소를 network 와 host 필드로 구분해 관리함으로써, 클래스별로 네트워크 크기에 따라 주소 관리를 다르게 한다.
* **network(네트워크)** : 네트워크 주소이다. 전 세계적으로 유일한 번호가 모든 컴퓨터 네트워크에 할당된다. 현재 이 주소의 할당은 NIC(Network Information Center) 에서 담당한다.
* **host(호스트)** : 네트워크 주소가 결정되면 하위의 호스트 주소를 의미하는 host 비트 값을 개별 네트워크의 관리자가 할당한다. 클래스 A는 host 비트의 크기가 크기 때문에 규모가 큰 네트워크에서 사용하고, 클래스 C 는 규모가 작은 네트워크에서 사용한다.
</br>

* 그림에서 유추할 수 있는 것처럼, 표와 같이 IP 주소 값을 통해 이 주소가 속한 클래스를 알 수 있다. 
* 이진수로 표현되면 그림에서 맨 왼쪽 비트와 비교해 바로 알 수 있다.
* 십진수로 표현되면, A1.A2.A3.A4 의 표현 방식에서 맨 왼쪽의 A1 값이 표의 주소 대역 중 어디에 속하는지에 따라 결정된다.
* 예를 들어, 211.223.201.30은 클래스 C 의 주소이다.

<img src="https://user-images.githubusercontent.com/83942393/131069307-44e5785c-9e3f-41e2-ac0b-82533f3eea1c.png" width="60%" height="60%"></img></br>
</br>

<img src="https://user-images.githubusercontent.com/83942393/131064725-7d22047a-8cf8-4d77-9620-27eedf46f2ff.png" width="50%" height="50%"></img></br>
</br>

### 1.4 기타 필드
앞서 설명한 필드 외에도 IP 프로토콜에서는 다음과 같은 다양한 필드를 정의한다.   

* **Version Number(버전 번호)** : IP 프로토콜의 버전 번호이다. 현재 인터넷 환경에서 사용하는 IP 프로토콜은 버전 4이다. IP 프로토콜의 새로운 버전인 IPv6 과 구분하기 위해 기존 IP 프로토콜을 IPv4 로 표현하기도 한다. 
* **Header Length(헤더 길이)** : IP 프로토콜의 헤더 길이를 32비트 워드 단위로 표시한다. 일반 패킷을 전송하는 경우에 헤더의 Options, Padding 필드가 빠지므로 IP 헤더의 최소 크기는 5(워드)이다.
* **Packet Length(패킷 길이)** : IP 헤더를 포함하여 패킷의 전체 길이를 나타낸다. 패킷 길이 필드의 크기가 16비트(15~31)이므로 IP 프로토콜에서 지원하는 패킷의 최대 크기는 2^16-1 바이트이다. 그러나 이는 이상적인 최댓값으로, IP 프로토콜에서 65,535 바이트의 IP 패킷을 전송해도 대부분 데이터 링크 계층에서 분할해 전송한다. 따라서 실제 환경에서 IP 프로토콜은 IP 패킷을 더 작은 단위로 만든다. IP 패킷의 크기는 일반적으로 8,192 바이트를 넘지 않는다.
* **Time To Live(생존 시간)** : 패킷 전송 과정에서 패킷이 올바른 목적지를 찾지 못하면 수신 호스트에 제대로 도착하지 않고, 네트워크 내부에서 떠돈다. 이런 현상을 방지하려고 Time To Live 필드를 사용한다. 송신 호스트가 패킷을 전송하기 전에 네트워크에서 생존할 수 있는 시간을 지정하고, 각 라우터에서는 패킷이 지나갈 때마다 필드 값을 감소시키면서 패킷을 중개한다. 임의의 라우터에서 Time To Live 값이 0으로 감소하면 패킷은 자동으로 버려지고, 패킷 송신 호스트에 ICMP 오류 메시지가 전달된다.
* **Transport(전송 프로토콜)** : 그림과 같이 IP 프로토콜에 데이터 전송을 요구한 전송 계층의 프로토콜을 가리킨다. 전송 계층의 TCP 세그먼트와 UDP 데이터그램, 네트워크 계층의 ICMP 패킷은 모두 IP 패킷의 데이터를 의미하는 페이로드(Payload) 부분에 캡슐화되어 전송된다. 왼쪽의 숫자는 Transport 필드 값을 의미하며, TCP는 6, UDP는 17, ICMP는 1의 값이 저장된다. 따라서 패킷 수신자는 페이로드 내부에 어느 프로토콜 정보가 있는지 판단할 수 있다.
</br>

<그림 p.251>   

* **Header Checksum(헤더 체크섬)** : 전송 과정에서 발생할 수 있는 헤더 오류를 검출하는 기능으로, 데이터의 오류는 검출하지 않는다. 이와 달리 계층 4 프로토콜인 TCP, UDP 헤더는 데이터와 헤더 오류를 모두 검출한다. 체크섬 계산 과정은 다음과 같다. 먼저 Header Checksum 필드의 비트 값을 모두 0으로 설정한 후, 전체 헤더가 16비트 워드의 연속이라 가정하고 1의 보수 합을 수행한다. 이 값을 체크섬으로 하여 패킷을 전송하고, 수신 호스트는 1의 보수 합을 계산하여 계산 결과가 모두 1이면 전송 과정에서 오류가 없다고 판단한다. 전송 과정에서 오류가 발생하면 해당 패킷을 버리고, 이를 복원하는 일은 상위 계층에서 담당한다(수신 호스트의?). IP 헤더 값은 라우터의 중개 과정을 거치는 동안에 계속 변경되므로 라우터를 거치는 과정에서 체크섬을 검증하고 재계산하는 과정이 반복적으로 이루어진다.
* **Options(옵션)** : 네트워크 관리나 보안처럼 특수 용도로 이용할 수 있다.
* **Padding(패딩)** : IP 헤더의 크기는 16비트 워드의 크기가 4의 배수가 되도록 설계되어 있다. 앞서 설명한 필드 전체의 크기가 이 조건에 맞지 않으면 이 필드를 사용해 조정할 수 있다.
</br>

### 2. 패킷 분할
* 다양한 유형의 네트워크를 통해 패킷을 중개하려면, IP 프로토콜이 패킷을 각 네트워크에서 처리하기 편한 크기로 분할해야 한다.
```
예를 들어, X.25 프로토콜에서의 프레임 크기와 이더넷에서의 프레임 크기는 다르다.
```
* 따라서 상위 계층에서 더 큰 데이터 전송을 요구하면, IP 프로토콜에서 패킷 분할 과정을 먼저 수행해 전송한다.
</br>

### 2.1 분할의 필요성
* 하부 계층의 관점에서 보면, TCP 에서 설정되는 논리적인 가상 연결은 여러 종류의 네트워크를 거쳐서 설정된다.
* 그러나 TCP 프로토콜은 패킷 전송 과정에 위치하는 네트워크 유형에 따라 패킷 크기를 조절하기가 쉽지 않으므로 IP 프로토콜에서 이 기능을 수행해야 한다.
</br>

그림은 패킷 분할의 필요성을 설명한다.   
* 맨 밑에 위치한 데이터 링크 계층 프로토콜의 프레임은 크기가 프로토콜마다 다르다. 
* 따라서 상위 계층에서 내려온 데이터를 계층 2의 프레임 틀에 담을 수 있도록 IP 프로토콜에서 분할 과정을 거친 후에 전송하고, 수신 측에서는 이를 다시 합치는 병합 작업을 수행한다.
</br>

<img width="733" alt="스크린샷 2021-08-27 오후 12 57 04" src="https://user-images.githubusercontent.com/83942393/131069562-a17facde-3baf-42cb-82f7-f4f09521f96b.png">
</br>

* IP 프로토콜의 분할 기능은 전송 경로에 위치한 라우터에 의해 수행된다.
* 라우터의 좌우에 연결된 LAN이 서로 다를 수 있기 때문에 그림의 데이터 링크 계층에 위치한 프레임마다 크기가 프로토콜마다 달라진다.
* 따라서 데이터를 수신한 이후에 패킷을 중개하는 방향에 위치한 LAN 에 맞도록 프레임을 분할해 주어야 한다.
</br>

### 2.2 분할의 예
그림은 IP 프로토콜의 패킷 분할 과정을 예를 들어 보여준다.    
IP 헤더를 제외한 전송 데이터의 크기는 380 바이트이고, 패킷은 최대 크기가 128바이트, 헤더의 크기는 20바이트라고 가정하였다.    

<img src="https://user-images.githubusercontent.com/83942393/131070173-f68434e2-f455-4739-8fca-ca25eabccf52.png" width="60%" height="60%"></img></br>

* 먼저 Fragment Offset 필드를 계산해야 하는데, 이 값에 8을 곱한 크기가 분할 전의 데이터 위치이다. 
* 패킷 전체의 크기인 128바이트에서 헤더인 20바이트를 빼면 108바이트가 되므로, 분할 패킷에 보관할 수 있는 데이터의 최대 크기는 (108을 8로 나눈 몫 x 8 = ) 104 바이트이다.
* 따라서 분할된 패킷의 개수는 4개(= 380을 108로 나눈 몫 +1 ) 이며, 각 패킷의 Fragment Offset 필드 값은 0, 13, 26, 39가 된다.
* 분할 패킷인 분할 1, 분할 2, 분할 3은 데이터 크기 104 바이트에 헤더 크기 20바이트를 더해 124가 되므로, 패킷의 전체 크기 Packet Length = 124 바이트이다. 
* 마지막 분할 패킷은, 전체 데이터의 크기 380에서 세 개의 분할 패킷 크기 3x104 를 빼면 68 바이트의 여분을 얻을 수 있는데, 이 값에 헤더 크기인 20바이트를 더해 Packet Length = 88 바이트이다.
</br>

* 분할한 패킷의 Identification 필드에는 동일한 번호를 부여해야 한다.
* 그림에서는 임의로 1254번을 가정하였다. 
* MF 필드는 마지막 패킷만 제외하고 1을 지정해 분할 패킷이 이어지고 있음을 표시해주어야 한다.
</br>

### 3, DHCP 프로토콜
* 특정 네트워크를 관리하는 네트워크 관리자는 개별 호스트들에 수동으로 고정 IP 주소를 할당할 수 있다. 
* 그러나 IP 주소 부족 등의 사유로 DHCP(Dynamic Host Configuration Protocol) 를 사용하여 자동으로 할당할 수도 있다.
```
예를 들어, 대학 내의 여러 실습실에 1,000 대의 컴퓨터가 설치되어 있다고 가정하면 1,000개의 고정 IP 주소를 할당해야 한다. 
그러나 실습 수업이 동시에 이루어지지 않기 때문에 DHCP를 사용하여 현재 사용하는 컴퓨터에만 IP 주소를 자동으로 할당하는 것이 가능하다.
이렇게 IP 주소를 여러 컴퓨터가 공유해서 사용하면 더 적은 수의 IP 주소만으로도 1,000 대의 컴퓨터가 시간 분할 방식으로 인터넷에 접속할 수 있다.
```
* 자동으로 할당 가능한 IP 주소는 DHCP 서버가 관리하는 풀(Pool)에 저장되어 관리하며, 클라이언트로부터 IP 주소 요청이 오면 풀에서 하나의 IP 주소를 할당한다.
* 이후 사용이 끝나면 다시 IP 주소 풀로 반환되어 다른 호스트가 사용할 수 있다.
</br>

### 3.1 DHCP 메시지
* IP 주소를 원하는 클라이언트는 DHCP 서버에 요청 메시지를 전송하고, 서버는 이에 대한 응답 메시지를 회신한다.
* 이때 사용하는 DHCP 메시지의 형식은 다음과 같다.
</br>

<그림 p.254>   

* **OPcode** : 요청 메시지는 1을 지정하고, 응답 메시지는 2를 지정한다.
* **HardwareType** : 이더넷 등과 같은 하위 계층의 하드웨어 유형을 지정한다.
* **HardwareLength** : 하드웨어 주소의 길이를 지정한다.
* **HOPCount** : 패킷이 전달되는 최대 홉의 수를 지정한다.
* **Transaction Identifier** : 클라이언트의 요청이 있을 때 지정하는 임의의 숫자이며, 서버는 지정된 번호로 응답한다. DHCP 메시지는 브로드캐스팅 방식으로 전송되기 때문에 클라이언트와 서버의 논리적인 세션을 형성하는 목적으로 사용한다.
* **Time Elapsed** : 클라이언트가 부팅된 이후의 경과 시간을 지정한다. 
* **Flag** : 현재 첫 번째 비트만 사용되며, 유니캐스트인지 멀티캐스트인지를 구분한다.
* **Client IP Address** : 클라이언트가 자신의 IP 주소를 지정한다. 주소를 모르면 0으로 표시한다.
* **Your IP Address** : 서버가 응답 메시지로 권고해주는 클라이언트의 IP 주소이다.
* **Server IP Address** : 서버의 IP 주소를 지정하는떼, 주소를 모르는 경우는 0으로 표시한다.
* **Gateway IP Address** : 클라이언트의 디폴트 라우터 IP 주소를 지정한다.
* **Client Hardware Address** : 클라이언트의 하드웨어 주소를 지정하며, 크기는 Hardware-Length 필드에 표시된다.
* **Server Name** : 서버의 도메인 네임을 지정하며, 크기는 64바이트이다.
* **Boot File Name** : 추가 정보를 관리하고 있는 파일 경로명을 지정하며, 크기는 128바이트이다.
* **Options** : 필요한 추가 정보를 지정하며, 크기는 64바이트이다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/131072024-a1a15ddf-a161-4d2b-8ffd-7521bcd00045.png" width="80%" height="80%"></img></br>
 -wireshrk상의 DHCP 캡쳐화면-     
 </br>
 
① 클라이언트가 broadcast로 DHCP 메시지를 보내어 IP요청 서버를 찾는다.    
② 서버는 192.168.43.110의 IP 를 제공한다.    
③ 클라이언트는 IP주소로 사용하겠다는 request를 breadcast한다.    
④ 서버는 DHCP request메시지를 받고 클라이언트의 구성할 IP DHCP Ack 메시지에 보낸다. 
</br>

### DHCP 프로토콜 주요 메시지








