### 🔆 Preview
전송 매체에는 트위스티드 페어(Twisted Pair), 동축케이블, 광케이블 등의 유선 매체와 적외선, 레이저, 마이크로파, 라디오 등의 무선 매체가 있다.
전화망은 아날로그 방식을 이용하는 음성 데이터 전송망으로, 통신 시스템 중 가장 먼저 개발되고 현재도 폭넓게 사용하고 있다.
디지털 방식의 컴퓨터가 전화망에 연결해 통신하려면 전화망과 컴퓨터 단말기 사이에 모뎀이 필요하다.

무선 휴대 통신 기기와 인터넷이 폭넓게 보급되면서 디지털 통신 환경이 보편화되고 있다.
디지털 통신 방식은 아날로그 방식보다 오류율은 낮고 전송률은 높다.
또 음성, 영상, 컴퓨터 데이터 등 멀티미디어 데이터 처리에 효과적이다.

네트워크 표준 모델은 **LAN 환경에 한하여** 특별히 계층 2의 역할을 LLC와 MAC 계층으로 구분하여 설명한다.
이와 같은 구분을 이해하려면, WAN과 LAN 환경에서 계층 2의 역할에 어떤 차이가 있는지 알아야 한다.
한편, LAN의 네트워크 연결 구조가 바뀜에 따라 MAC 계층 역시 다양한 구조를 필요로 한다.
따라서 주요 MAC 프로토콜의 구조를 이해함으로써 WAN과 LAN 환경의 차이와 네트워크 동작 원리를 이해할 수 있다.

5장에서는 OSI 7계층 모델의 계층 2에 해당하는 데이터 링크 계층에 대하여 설명한다.
LAN 환경에서 데이터 링크 계층은 LLC 계층과 MAC 계층으로 역할이 구분된다.
또한 LAN 의 종류에 따라 MAC 계층도 여러 종류가 존재한다.
따라서 이러한 다양한 프로토콜이 표준안에서 서로 어떤 연관을 갖는지 이해할 필요가 있다.
마지막으로 LAN 환경에서 사용하는 주요 MAC 프로토콜인 이더넷, 토큰 버스, 토큰 링의 구조와 동작 원리에 대하여 상세하게 설명한다.    
</br>

### 💎 01 MAC 계층과 IEEE 802 시리즈

원거리에 있는 호스트를 연결하는 WAN 과 달리 LAN 환경은 근거리에 분포된 호스트를 연결한다.   
따라서 LAN 환경에서는 WAN 환경에서보다 효율적인 전송 관리를 통해 네트워크의 이용 효율을 극대화해야 한다.   
네트워크 전송 효율은 주로 전송 매체의 성능에 좌우되지만, 연결 방식이나 전송 방법에도 영향을 많이 받는다.   
이 절에서는 LAN 환경의 계층 2 기능에 대한 표준안을 다루는 IEEE 802 시리즈를 알아본다.   
IEEE 802 시리즈는 LLC 계층뿐 아니라 MAC 계층에 대한 다양한 표준안을 정의하고 있다.   
</br>

### 1. MAC 계층의 이해
LAN 환경에서는 네트워크 자원을 효율적으로 활용하려고 그림 (a)와 같이 데이터 링크 계층의 기능을 LLC 계층과 MAC 계층으로 나누어 처리한다.    
즉, OSI 7계층 모델에서 정의한 데이터 링크 계층의 기본 기능은 주로 LLC 계층에서 다루고, 물리적인 전송 선로의 특징과 특정 매체 간의 연결 방식에 따른 제어 부분은 MAC 계층에서 처리한다.   
(b)의 WAN 환경과 비교해 보면, LAN의 LLC 계층이 WAN 의 데이터 링크 계층과 역할이 비슷하기 때문에, LAN 환경에 MAC 계층이 추가된 것으로 볼 수 있다.   

<img src="https://user-images.githubusercontent.com/83942393/129463562-581cc45c-dc41-442a-993e-354e9ad38786.png" width="60%" height="60%"></img></br>
</br>

### 1.1 MAC 계층
* MAC(Medium Access Control) 계층은 전송 선로의 물리적인 특성을 반영하므로, LAN의 종류에 따라 특성이 구분된다.
* LAN 환경을 위한 MAC 계층은 종류가 다양한데, 공유 버스 방식을 지원하는 이더넷과 링 구조 방식을 지원하는 토큰 링 방식이 대표적인 예이다.
* 컴퓨터 네트워크에서 가장 많이 사용하는 이더넷(Ethernet)은 공유 버스를 이용해 호스트를 연결한다.
* 이더넷에서는 데이터를 전송하기 전에, 전송 선로를 먼저 확인해 다른 호스트가 데이터를 전송 중인지 여부를 파악해야 한다.
* 다른 호스트가 선로를 사용하지 않으면, 데이터 프레임을 전송할 수 있지만, 사용하고 있다면 정해진 정책에 따라 나중에 다시 시도해야 한다.
* 둘 이상의 호스트에서 동시에 데이터 프레임 전송을 시도하면, 충돌(Collision)이 발생한다.
* 충돌이 생기면 호스트는 이를 감지하고, 일정 시점이 지난 후에 재전송해야 한다. (사후 예방 방법)
* 토큰 링(Token Ring) 방식에서는 토큰(Token)이라는 특정 패턴의 제어 데이터가 링을 순환한다.
* 데이터 프레임을 전송하려면, 먼저 토큰을 확보해야 하며, 전송을 완료하자마자 토큰을 링에 내놓아야 한다. (사전 예방 방법)
* 토큰 링 방식에서는 각 호스트에 전송 우선순위(Priority)를 부여할 수 있다.
</br>

### 1.2 LLC 계층
* LAN 환경에서 LLC(Logical Link Control) 계층은 WAN 환경의 데이터 링크 계층과 기능이 거의 유사하다.
* 그러나 LAN 종류에 따라 MAC 계층의 설계 형태가 영향을 받는 것처럼, LLC 계층도 LAN의 특성에 부분적으로 영향을 받을 수 있다.
* 그러므로 이더넷에서 사용하는 LLC와 토큰 링에서 사용하는 LLC는 약간 다를 수 있다.
```
예를 들어, 이더넷의 LLC 계층은 프레임을 전송하는 과정에서 슬라이딩 윈도우 프로토콜을 사용한다.
반면, 토큰 링이나 토큰 버스 구조에서는 송신 호스트가 수신 호스트의 도움 없이, 보낸 프레임의 전송 오류를 검출하고 재전송하는 기능을 수행할 수 있어 슬라이딩 윈도우 프로토콜이 불필요하다.
```
</br>

### 2. IEEE 802 시리즈
국제 표준화 단체인 IEEE 에서 데이터 링크 계층과 관련된 다양한 LAN 표준안 연구 결과를 IEEE 802 시리즈로 발표하였다.   

* IEEE 802.1 : 관련 표준안 전체를 소개, 인터페이스 피리미티브에 대한 정의
* IEEE 802.2 : 데이터 링크 계층의 상위 부분인 LLC 프로토콜의 정의
* IEEE 802.3 : 물리 계층과 MAC 계층에 대한 내용
  * IEEE 802.3 : 이더넷으로 알려진 CSMA/CD 방식
  * IEEE 802.4 : 토큰 버스 방식
  * IEEE 802.5 : 토큰 링 방식   

에 관한 내용을 규정한다.   

그림은 계층 구조 모델에서 LLC 계층과 MAC 계층의 관계를 설명하며, IEEE 표준안에서 정의된 계층의 역할을 보여준다.   

<img src="https://user-images.githubusercontent.com/83942393/129463850-2db3933e-0364-4b9f-8a9f-eaac18555d30.png" width="60%" height="60%"></img></br>
</br>

네트워크 계층과 LLC 계층의 기능은 LAN 종류에 큰 영향을 받지 않으므로, 공통의 프로토콜인 IEEE 802.2 표준안을 사용한다.   
그러나, MAC 계층은 물리 계층의 종류에 따라서 다양하게 사용될 수 있으므로, 각각에 대하여 별도의 표준안이 정의되어 있다.  
</br>

### 2.1 CSMA/CD
* 다중 접근 채널(Multiple Access Channel) 방식을 이용하여 공유 매체에 프레임을 전송하는 방식에서는 데이터 충돌 가능성이 항상 존재한다.
```
충돌 문제를 해결하는 방법은 크게 두 가지이다.

하나는 다수의 호스트가 송신한 프레임이 공유 매체에서 충돌하는 현상을 허용하는 방식으로, 충돌이 발생한 후에 문제를 해결한다.
다른 하나는 충돌이 발생할 가능성을 원천적으로 차단하는 방식이다. - 충돌 회피
```
* 충돌을 허용하는 방식의 대표적인 예는 이더넷으로 더 많이 알려진 CSMA/CD (Carrier Sense Multiple Access/Collision Detection) 이다.
* 충돌 허용 방식에서는 충돌로 깨진 프레임을 복구하는 작업(재전송)이 필요하기 때문에, 프레임을 송신한 호스트에서 충돌을 감지하는 기능이 반드시 필요하다.
* CSMA/CD 방식에서 충돌이 자주 발생하면, 오류 복구 과정에 따라 재전송도 많이 이루어진다.
* 따라서, 동일한 프레임을 여러 번 재전송하는 과정을 반복하므로, 네트워크의 전체 성능이 떨어진다.
* 일반적으로 공유 매체의 길이가 길수록, 전송 지연이 증가하여 충돌이 발생할 가능성도 높아진다.
</br>

```
충돌 회피 방식은 종류가 다양하다.
가장 간단한 방법은, 각 송신 호스트에 서로 다른 전송 시간대를 지정하는 타임슬롯(Time Slot)을 배정하는 방법이다.
```
</br>

전송 프레임은 버스 구조에 연결된 모든 호스트에 전송되기 때문에 (b)와 같이 프레임의 목적지가 아닌 호스트 2, 3, 4에도 도착한다.   
호스트 1을 제외한 나머지 호스트는 이 프레임을 수신할 이유가 없으므로 버려야 한다.   
이 기능을 지원하려고, 각 호스트에는 고유 주소가 할당되고, 전송 프레임에는 (a)와 같이 목적지 주소를 호스트 1로 지정한 후, 프레임을 전송해야 한다.   
결과적으로 그림 (c)와 같이 호스트 5에서 호스트 1까지 프레임을 올바르게 전송할 수 있다.   

<img src="https://user-images.githubusercontent.com/83942393/129464149-ff86e830-8db5-4b80-8742-f79f85a11673.png" width="60%" height="60%"></img></br>
</br>

### 2.2 토큰 버스
토큰 버스(Token Bus) 방식은 그림과 같이 물리적인 버스 구조(점선)로 연결되지만, 논리적인 프레임 전달은 링 구조(실선)이다.   

* 이 방식은 프레임을 전송하기 전에 버스 신호를 감지하는 CSMA/CD 방식과 다른 형태의 전송 메커니즘을 사용한다.   
* 즉, 데이터 프레임 전송이 호스트 사이에 순차적으로 이루어지도록 토큰(Token)이라는 제어 프레임을 사용한다.   
</br>

<img src="https://user-images.githubusercontent.com/83942393/129464244-8c724074-59d8-48cd-a83e-f7ba3fad7dfb.png" width="60%" height="60%"></img></br>

#### <토큰 방식>
* 프레임을 전송하려면 반드시 토큰을 확보해야 한다.
* 프레임 전송을 원하는 호스트는 토큰이 도착할 때까지 기다려서 도착한 토큰을 획득한 뒤 프레임을 전송한다.
* 프레임 전송을 완료하면 이웃 호스트에 토큰을 넘겨준다
* 호스트가 이웃하는 순서는, 물리적인 수서가 아니라 각 호스트의 고유 번호와 관련이 있다.
* 높은 번호부터 네트워크에 연결되고, 토큰 전달도 먼저 이루어진다.
</br>

### 2.3 토큰 링
그림과 같은 순환 구조의 전송 매체와 연결되는 링 인터페이스의 동작은 대기 모드와 전송 모드로 구분된다.   
</br>

> 대기 모드 : 입력단으로 들어온 비트를 출력단으로 즉시 내보낸다.

따라서, 호스트가 다운되거나 기타 장애가 발생하면 대기 모드가 되어 네트워크의 동작에 영향을 주지 않는다.   
대기 모드에서 호스트는 링 네트워크를 유지하는 역할만 수행한다.   

<img src="https://user-images.githubusercontent.com/83942393/129464364-61531530-937e-4290-bfca-2c75bb7f0e4c.png" width="40%" height="40%"></img> <img src="https://user-images.githubusercontent.com/83942393/129464352-902321c7-a4bb-4533-aecb-d39cf6548b7c.png" width="50%" height="50%"></img></br>
</br>

> 전송 모드 : 호스트가 토큰을 획득해 프레임을 전송할 수 있는 권한을 보유한 상태이다.

이때는 네트워크의 입력단과 출력단의 논리적인 연결이 끊어지는 대신, 네트워크가 호스트의 중개를 거쳐서 연결된다.   
호스트는 전송하고자 하는 프레임을 출력단을 통해 링으로 보낼 수 있다.   
</br>

**토큰 링** (Token Ring)
* 송신 호스트가 전송한 프레임이 링을 한 바퀴 돈 후 송신 호스트에 되돌아오도록 설계된다.
* 이 과정에서 프레임의 목적지 주소가 자신의 주소와 동일한 호스트는 해당 프레임을 수신하고, 프레임 내부의 특정 위치에 올바르게 수신했다고 표시한다.
* 송신 호스트는 자신에게 되돌아온 프레임의 특정 위치 값을 확인하여, 프레임이 올바로 전송되었음을 확인한 뒤, 데이터 프레임을 회수하고 토큰 프레임을 링에 회수한다.
</br>

### 💎 02 이더넷
* IEEE 802.3 은 1-persistent CSMA/CD 방식의 LAN 환경에 관해 규정한 표준안이며, 공유 버스로 연결한 호스트 간의 데이터 전송에 관한 사항을 다룬다.
* 이더넷은 원래 IEEE 802.3 표준안을 실제로 구현한 제품이지만, 현재는 더 일반화된 용어로 사용한다.
</br>

### 1. 이더넷과 신호 감지 기능
* 공유 버스 구조에서 호스트 간의 프레임 충돌을 방지하려면, 프레임을 전송하기 전에 다른 호스트가 공유 버스를 사용하고 있는지 확인해야 한다.
* 이는 전송 선로에 흐르는 전기 신호를 감지하는 기능으로 구현할 수 있다. 
* 전송 매체의 신호를 감지해, 프레임의 전송 여부를 결정하는 프로토콜을 신호 감지(Carrier Sense) 프로토콜이라 한다.
* 신호 감지 프로토콜에서는 선로의 전달 지연이 성능에 영향을 많이 준다.
* 다음은 신호 감지 프로토콜의 종류이다.
</br>

#### CSMA에서 매체가 빈(free) 직후 어떤 행동양식들을 취할까?

### 1.1 1-persistent CSMA
* 신호 감지 프로토콜 중에서 가장 간단한 형태는 1-persistent CSMA 방식이다.
* 이 방식은 일반 신호 감지 프로토콜처럼 프레임을 전송하기 전에 전송 채널이 사용 중인지 확인한다.
* 다른 호스트에서 채널을 사용 중이라고 판단하면, 유휴 상태가 될 때까지 대기한다.
* 그러다가 임의의 순간에 채널이 유휴 상태로 변경되면, 확률 1의 조건으로 프레임을 무조건 전송하기 때문에 1-persistent CSMA 라 한다.
* 둘 이상의 호스트에서 동시에 전송 채널의 유휴 상태를 기다렸다가, 유휴 상태로 판단하면 프레임 전송 과정에서 충돌이 발생할 수 있다.
* 충돌이 발생하면, 임의의 시간 동안 대기한 후에 채널을 감지하는 과정을 다시 반복한다.
```
* 낙천형
* 충돌되지 않으리라는 확률 1 을 갖고 사용중이지 않은 것을 감지하자마자 즉시 매체 접근하여 데이터 프레임 송출
* 충돌 발생 가능성이 가장 크므로, 채널 사용률이 낮은 대신에, 대기시간은 짧음
* 유선 LAN 이더넷에서는 이렇게 행동함
```
</br>

### 1.2 Non-persistent CSMA
* Non-persistent CSMA 방식에서는 전송 채널의 신호를 감지해, 채널이 사용 중이라고 판단하면 더는 채널의 유휴 상태를 확인하지 않는다.
* 대신 임의의 시간 동안 기다린 후에 다시 채널 감지를 시작하기 때문에, 1-persistent 방식보다 충돌이 발생할 확률을 줄일 수 있다.
```
1-persistent CSMA 방식에서는 여러 호스트가 채널이 유휴 상태가 되기를 기다리다가 동시에 프레임을 전송할 수 있기 때문에, 
충돌이 발생할 가능성도 높다.
```
```
* 비관형
* 반드시 충돌될 것이라고 비관하여 비록 사용중이지 않은 것을 감지하여도, 확률분포에서 얻어진 임의의 시간 만큼 무조건 기다린 후 매체 접근
* 충동이 적어 채널 사용률은 좋아지나, 대기 시간이 길어짐
```
</br>

### 1.3 p-persistent CSMA
* p-persistent CSMA 방식은 슬롯 채널 방식에서 많이 사용한다.
* 채널이 유휴 상태이면 p 확률로 프레임을 전송하고(?), 채널이 사용 중이면 다음 슬롯을 기다린 후 앞의 과정을 반복한다.
```
* 의심 염려형
* 사용중이지 않은 것을 감지하면,
* 전체중 확률 p 가 충돌되지 않을 것으로 판단하여, 매체 접근하고, 
* 의심을 갖는 나머지 확률 (1-p)는 한 단위시간 만큼(다음 slot) 기다린 후, 매체에 접근
* nonpersistent 처럼 충돌은 줄이고, 1-persistent 처럼 대기 시간을 줄이고자 하는 위 두 가지에 대한 타협안임.
```
</br>

### 1.4 CSMA/CD
CSMA 방식은 프레임 전송 과정에서 충돌이 발생할 가능성이 크다.   
공유 버스에서 충돌이 발생하면, 해당 프레임의 내용이 깨지고, 각 호스트에서 전송한 프레임의 내용이 변형되므로 프레임을 더 전송하는 것이 의미가 없다.   
따라서, 향상된 방식인 CSMA/CD 에서는 **충돌 감지**(Collision Detection) 기능을 사용해 충돌 여부를 확인한다.   
일단 호스트가 충돌을 감지하면, 진행중인 프레임의 전송을 중지한다.   
</br>

그림은 이더넷 방식을 이용하는 고전적인 LAN 접속 방법을 보여준다.  

![image](https://user-images.githubusercontent.com/83942393/129465050-a8dc4695-f891-4449-8fb1-ed733f6939f6.png)   

* 굵고 긴 전송 케이블로 된 전송 매체에 트랜시버 장비로 보조선을 연결해 각 호스트를 연결한다.
```
트랜시버(Transceiver)는 호스트를 전송 케이블에 연결하기 위한 송수신 장치로, 전송 선로의 신호를 감지하는 기능과 함께 충돌 현상을 감지하는 기능도 제공한다.
```
* 임의의 트랜시버가 충돌을 감지하면, 이를 특정 신호의 형태로 변환해 전송 케이블에 다시 전송해야 한다.
* 이처럼 트랜시버는 충돌이 발생했음을 알려줌으로써 무의미한 프레임 전송을 억제한다.
</br>

* IEEE 802.3 표준안은 전송 케이블의 최대 길이를 일정 범위 이내로 제한하는데, 이는 케이블의 길이가 너무 길면 신호 감쇄 현상에 의해 오류가 발생할 가능성도 높아지기 때문이다.
* 또한 케이블에 연결되는 호스트 간 간격이 너무 좁아지지 않도록 일정 간격 이상으로 규정하고 있다.
* 이더넷 케이블 하나에 연결되는 두 호스트 수가 증가하면, 케이블을 두 개로 나누어 **리피터** (Repeater)로 연결해야 한다.
```
리피터는 단순히 신호를 증폭하여 이웃하는 케이블로 넘겨주는 기능을 한다.
```
* 예를 들어, 그림의 왼쪽 케이블에서 전송되는 신호는 리피터를 통해 오른쪽으로 전달되고, 반대 방향으로도 신호를 증폭해 전달한다. 
</br>

### 2. 프레임의 구조
상위 계층인 LLC 에서 내려온 프레임을 상대 호스트에 전송하려면, MAC 계층에서 정의된 프레임 구조에 맞게 포장해야 한다.   
MAC 계층 프로토콜에 정의된 MAC 헤더와 트레일러 정보를 추가한 것을 MAC 프레임(MAC Frame)이라 하며, 이더넷 프로토콜에서는 이더넷 프레임이라 한다.   
LLC 계층에서 보낸 모든 정보를 전송 데이터로 취급하며, 데이터 앞에는 헤더가, 뒤에는 트레일러가 위치한다.   

그림은 이더넷 프로토콜에서 사용하는 **이더넷 프레임** 구조이다.   
필드의 단위는 바이트로, Source Address 와 Destination Address는 6바이트의 MAC 주소를 사용하며, Data와 Padding 필드는 가변 길이를 지원한다.   

<img src="https://user-images.githubusercontent.com/83942393/129467291-20b592a7-c69b-479e-9c66-97d861fd5611.png" width="60%" height="60%"></img></br>
<img src="https://user-images.githubusercontent.com/83942393/129466866-cc511596-66a1-47c3-ab29-cc12e4276379.png" width="60%" height="60%"></img></br>

이더넷 프레임의 Data 필드 왼쪽에 위치한 필드들은 헤더에 속하고, 오른쪽은 트레일러에 속한다.
헤더와 트레일러에서 정의한 필드의 의미는 다음과 같다.

* Preamble(프리엠블) : 7바이트 크기로, 수신 호스트가 송신 호스트의 클록과 동기를 맞출 수 있도록 시간 여유를 제공하는 것이 목적이다. 각 바이트는 10101010 비트 패턴을 포함한다. 
* Start Delimiter(시작 구분자) : 프레임이 시작된다는 의미로 사용되며, Preamble 필드와 구분하기 위해 10101011의 값을 갖는다. Preamble 패턴의 마지막 2비트는 10이지만, Start Delimiter의 값은 11로 끝난다.
* Source Address/Destination Address( 송신 호스트 주소 / 수신 호스트 주소 ) : MAC 게층에서는 호스트를 구분하는 고유의 MAC 주소를 사용한다. MAC 주소 값은 일반적으로 LAN 카드에 내장되어 제공된다. 두 필드는 전송되는 프레임의 송신 호스트와 수신 호스트 주소를 표현한다. 수신 호스트 주소는 최상위 비트가 1이면 그룹 주소를 의미하고, 0이면 일반 주소이다. 그룹 주소에는 특정 그룹에 속한 호스트에 프레임을 전송하는 멀티캐스팅과 네트워크에 연결된 모든 호스트에 전송하는 브로드캐스팅이 있다. 브로드캐스팅에는 주소부의 모든 비트가 1이다.
* Length/Type : 필드 값이 1,500 이하이면 Data 필드의 데이터 크기를 의미하는 Length 로 해석하고, 그렇지 않으면 Type으로 해석한다.
* Length(길이) : Data 필드에 포함된 가변 길이의 전송 데이터 크기를 나타내며, 최댓값은 1500이다. IP 패킷의 크기가 이 값을 초과하면, 먼저 분할 과정이 이루어져야, MAC 프레임의 내부에 캡슐화될 수 있다. Data와 Padding을 합한 데이터의 최소 크기는 46바이트이다. Length 값이 46보다 작으면 Padding 필드에 해당하는 크기만큼 0으로 채운다.
* Type(종류) : 이더넷 프레임에 캡슐화된 상위 프로토콜의 패킷 종류를 구분한다.
* Checksum(체크섬) : 데이터 전송 과정에서 데이터 변형 오류의 발생 여부를 수신 호스트가 확인할 수 있도록 송신 호스트가 값을 기록해준다. Preamble, Start Delimiter, Checksum 을 제외한 나머지 필드에 대한 CRC 값이다. 
</br>

### 3. LLC 프레임의 캡슐화
OSI 7계층 모델에서는 데이터 전송 시, 최상위 계층인 응용 계층에서 시작해 물리 계층까지 내려오는 과정에서 각 계층의 프로토콜이 정의한 헤더 정보를 계속 추가한다.   

그림의 이더넷 프레임에서 Data 필드를 제외한 필드들이 MAC 계층에서 추가하는 정보이다.   

<img width="616" alt="스크린샷 2021-08-15 오후 1 51 26" src="https://user-images.githubusercontent.com/83942393/129467534-2a74cebb-5cc2-4950-8006-bc047be1da45.png">

* 좀 더 자세히 설명하자면, 그림과 같이 네트워크 계층에서 전송을 요구한 패킷은 LLC 계층으로 내려오면서, LLC 헤더 정보를 추가해 LLC 프레임이 된다.
* LLC 프레임은 다시 MAC 계층으로 내려오는데, 이 과정에서 MAC 헤더와 MAC 트레일러 정보를 추가한다.
* 이후 MAC 계층에서는 MAC 프레임을 물리 계층을 사용하여 수신 호스트에 전송한다.
</br>

### 4.허브와 스위치 
CSMA/CD 방식에서 트랜시버를 이용해 전송 케이블에 호스트를 연결하는 방식은 더 이상 사용하지 않는다.   
대신, 허브라는 박스 형태의 장비에 잭을 사용해 호스트를 연결하기 때문에 LAN 케이블의 구성이 이전보다 간단해졌다.   
허브의 성능 문제를 개선한 스위치 허브도 많이 보급되는 추세이다.   

그림은 이더넷 환경에서 사용하는 공유 버스, 일반 허브, 스위치 허브의 차이점을 설명한다.   

![image](https://user-images.githubusercontent.com/83942393/129467797-5fce435a-3ea3-4b51-8e92-aef7502e49c3.png)

(a)는 공유 버스 구조를 사용하는 이더넷의 전형적인 원리를 보여준다.   
임의의 호스트에서 전송한 프레임은 버스에 연결된 모든 호스트에 전송되고, 목적지의 주소에 해당하는 호스트만 프레임을 수신한다.   
초기의 CSMA/CD 방식에서는 10Mbps 의 전송 속도를 지원했지만, 요즘은 100Mbps, 10Gbps의 이더넷이 주로 사용된다.   
</br>

### 4.1 허브
* 그림의 (b)와 같은 허브(Hub) 구조에서는 박스 형태의 장비에 호스트를 연결하는 다수의 포트를 지원하므로, 각 호스트는 외형상 허브에 스타형 구조로 연결된다.
* 그러나 내부의 동작 원리는 버스형 구조를 지원하기 때문에 임의의 호스트에서 전송한 프레임을 허브에 연결된 모든 호스트에 전달한다.
* 허브의 내부 동작은 공유 버스 방식으로 이루어지므로, 여러 호스트가 동시에 프레임을 전송하면 충돌이 발생할 수 있다.
* 허브 구조의 LAN 에서는 전체 전송 용량이 각 호스트를 연결하는 전송 선로 용량의 제한을 받는다.
* 따라서 그림처럼 허브의 최대 전송 용량은 10Mbps로 제한된다.
```
NOTE_전송 용량
전송 시스템에서, 하나의 전송 회선으로 동시에 전송할 수 있는 데이터의 용량.
```
</br>

### 4.2 스위치
* 그림의 (c)에 보이는 스위치 허브(Switch Hub)는 일반 허브와 형태가 동일하지만, 성능 면에서 장점이 있다.
* 중앙에 위치한 허브에 스위치 기능이 있어, 임의의 호스트로부터 수신한 프레임을 모든 호스트에 전송하지 않고 해당 프레임의 목적지로 지정한 호스트에만 전송한다.
* 따라서 이들 사이에 프레임 전송이 진행되고 있어도, 다른 호스트끼리 프레임을 전송할 수 있다.
```
예를 들어, (c)의 호스트 1이 호스트 2로 프레임을 전송하는 동안에 다른 호스트가 프레임을 전송할 수 있다.
```
* 따라서, 전체 정송 용량이 증가하는 효과가 생긴다. 
* 스위치 허브의 장점을 정리하면 다음과 같다.
</br>

* 스위치 허브가 자신에게 연결된 호스트를 모두 수용할 수 있는 충분한 전송 용량을 지원하면, 각 호스트는 할당된 LAN 전송 용량을 모두 사용할 수 있다.
* 일반 허브를 스위치 허브로 교체하는 과정에서 연결된 호스트는 하드웨어나 소프트웨어를 교체할 필요가 없다.
</br>

### 💎 03 토큰 버스

IEEE 802.3 표준안의 문제점은 네트워크 트래픽이 심할 때 특정 호스트가 오랫동안 프레임을 전송하지 못할 염려가 있다는 점과 프레임의 우선순위가 규정되지 않아 프레임의 중요도를 표현하기 어렵다는 점이다.   
이러한 문제를 해결하려면 호스트가 순서를 정해 차레대로 프레임을 전송하는 기능이 필요한데, 링 구조의 통신망이 이를 지원한다.   

### 1. 프레임의 구조
LLC 계층에서 내려온 LLC 프레임을 물리 계층을 통해 수신 호스트에 전달하려면, 토큰 버스 프로토콜에서 정의한 프레임에 맞게 토큰 버스 프레임을 만들어야 한다.   
(*이때 LLC 프레임은 토큰 버스 프레임의 전송 데이터로 취급된다.*)   

그림은 토큰 버스 프로토콜에서 정의한 토큰 버스 프레임(Token Bus Frame)의 구조이다.    
(상단의 숫자는 각 필드의 크기로, 단위는 바이트이다.)     

<img src="https://user-images.githubusercontent.com/83942393/129468225-1757285c-03e3-477e-8819-391d042befd3.png" width="60%" height="60%"></img></br>   

* 토큰 버스의 프레임 구조는 CSMA/CD 프레임 구조와 거의 비슷하나 중요한 **차이점** 이 있다.
* 토큰 버스 프레임에는 데이터 프레임과 토큰 프레임을 구분하기 위한 Frame Control 필드가 추가되어 있다.
* Length 대신 End Delimiter를 추가해 Start Delimiter와 함께 시작과 끝을 의미하는 경계로 전체 크기를 가늠할 수 있다.
</br>

헤더와 트레일러에 정의된 필드의 기능은 다음과 같다.
* **Start Delimiter/End Delimiter(시작 구분자/끝 구분자)** : 프레임의 시작과 끝을 의미하는 경계를 표시한다. 이더넷 프레임에는 Length 필드가 있어서 프레임의 전체 크기를 가늠하지만, 토큰 버스에서는 End Delimiter가 이 역할을 대신한다.
* **Preamble/Source Address /Destination Address/Checksum(프리엠블/송신 호스트 주소/ 수신 호스트 주소/ 체크섬)** : 이더넷 프레임과 기능이 동일하다.
* **Frame Control(프레임 제어)** : 데이터 프레임과 제어 프레임을 구분해준다. 데이터 프레임에서는 프레임 우선순위와 수신 호스트의 응답 확인이 필요할 때 사용하고, 제어 프레임에서는 토큰의 전달, 링 관리와 같은 용도로 사용한다.
</br>

그림은 Frame Control 필드의 용도를 보여준다.   
<img width="321" alt="스크린샷 2021-08-15 오후 2 41 33" src="https://user-images.githubusercontent.com/83942393/129468433-6277b709-002f-4049-923b-0e9e46d1a852.png">

첫 번째 2비트 값에 따라 역할이 구분된다.   
* TT=00으로 정의된 제어용 MAC 프레임의 종류는 CCCCCC 비트 값으로 구분하는데, 00001000이 토큰 프레임이다.
* TT=01인 경우는 데이터 프레임, LLC 프레임으로 정의되므로 상위 계층인 LLC 계층에서 내려온 전송 데이터이다.
* 따라서 토큰 버스 프로토콜에서 상대 호스트에 전송할 데이터 프레임에 해당한다.
</br>

* Control Frames
<img width="653" alt="스크린샷 2021-08-15 오후 2 45 19" src="https://user-images.githubusercontent.com/83942393/129468482-0a75f560-7458-4c15-a7d8-ad6c84dddef9.png">

토큰 버스에서 우선순위는 값이 0, 2, 4, 6인 네 개의 클래스로 나누며, 숫자가 클수록 우선순위가 높다.   
따라서 각 호스트에서는 네 개의 클래스를 관리하기 위한 논리적인 큐를 만들어야 하며, 토큰 프레임은 우선순위가 6이다.   
</br>

### 2. LLC 프레임의 캡슐화
![image](https://user-images.githubusercontent.com/83942393/129468566-bd2370c3-ddab-4989-8e8f-82105930910a.png)   

LLC 프레임의 좌우에 토큰 버스 프레임의 헤더와 트레일러 정보가 채워지면 물리 계층이 수신 호스트로 전송한다.   
수신 호스트의 MAC 계층은 토큰 버스 프레임의 헤더와 트레일러 정보를 해석하여 이들을 떼어내고, 상위 계층인 LLC 프로토콜에는 LLC 프레임 정보만 올려준다.   
</br>

### 💎 04 토큰 링
토큰 링 구조에서는 점대점으로 연결한 호스트가 순환 구조 형태로 LAN 을 구성한다.    
링 네트워크 주위에는 항상 토큰이라 불리는 제어 프레임이 일정한 방향으로 순환한다.   
데이터 프레임을 전송하고자 하는 호스트는 먼저 토큰을 획득해야 하고, 토큰을 확보한 호스트만 데이터를 전송할 수 있다.   
</br>

### 1. 프레임 구조
토큰 링 프레임은 데이터 프레임과 토큰 프레임으로 구분할 수 있다.   

(a) SD, AC, ED 필드 세개로 구성된 토큰 프레임의 구조   
(b) 데이터 프레임의 구조   

<img width="677" alt="스크린샷 2021-08-15 오후 2 57 28" src="https://user-images.githubusercontent.com/83942393/129468723-cebe4e92-adfc-44ff-8092-4e79945bff83.png"></br>

**모니터(Monitor)**   
* 링에 연결된 호스트 중에는 다른 호스트와 구별되는 특별한 기능을 수행하는 관리 호스트가 존재하는데, 이를 모니터라 부른다.
* 모니터로 지정된 호스트는 네트워크 관리와 관련된 기능을 수행하는데, 주로 네트워크의 정상 동작을 방해하는 예기치 않는 오류를 복구한다.
```
예를 들어, 현재 데이터 프레임을 전송하는 호스트가 없는데도 링에 토큰 프레임이 없어지는 오류가 발생할 수 있다.
이때는 모니터 호스트에서 토큰 프레임을 새로 생성해 다른 호스트가 데이터 프레임을 정상적으로 전송할 수 있도록 해야 한다.

또 다른 오류 예는, 일반 호스트에서 전송한 데이터 프레임이 링을 한 번 순환하면 송신 호스트에 의해 링에서 제거되어야 하는데, 그렇지 않고 무한정 순환하는
경우이다.

이와 같이 네트워크를 운용하는 과정에서 발생하는 오류를 정정하는 일은 모두 모니터가 담당한다.
```
</br>

### 2. LLC 프레임 캡슐화

<img src="https://user-images.githubusercontent.com/83942393/129468936-eae7c926-84a2-49e0-b55c-f7150b21b485.png" width="60%" height="60%"></img></br>
</br>

### 3. 프레임 필드의 의미
필드 내용 중에서 송신 호스트의 주소, 수신 호스트의 주소, 데이터, 체크섬 등은 이더넷, 토큰 버스 프로토콜에서의 용도와 같고, 나머지 필드의 역할은 다음과 같다.    
</br>

### 3.1 Start Delimiter/End Delimiter
* SD/ED 필드는 프레임의 시작과 끝을 구분한다.
* End Delimiter 필드에는 I와 E라는 두 종류의 비트가 정의되어 있다.
* I 비트는 데이터 프레임을 여러 개로 나누어 전송하는 경우에 사용된다.
* 즉, 데이터의 처음과 중간 프레임은 I 비트의 값을 1로 지정해 전송하고, 마지막 프레임의 값은 0으로 지정함으로써, 수신 호스트가 연속 데이터를 구분하여 수신할 수 있게 해준다.
* E 비트는 오류 검출용으로 이용한다.
</br>

### 3.2 Access Control
* AC 필드는 여러 가지 제어 기능을 수행하기 위해 사용된다.
* 그림처럼 우선순위 비트, 토큰 비트, 모니터 비트, 예약 비트로 나뉜다.

<img width="575" alt="스크린샷 2021-08-15 오후 3 12 29" src="https://user-images.githubusercontent.com/83942393/129469028-79ccf2db-1d50-4094-a92d-a50b04d7c9e7.png">

Access Control 필드에 정의된 비트 플래그의 역할은 다음과 같다.   
* 우선순위 비트 : 토큰의 우선순위보다 높은 프레임을 전송할 수 있도록 해준다. 000이 우선순위가 가장 낮고, 111이 가장 높다.
* 토큰 비트 : 토큰 프레임과 일반 프레임을 구분하는데, 토큰 프레임은 값이 0이다.
* 모니터 비트 : 네트워크에 오류가 발생하면 특정 프레임이 링 주위를 무한정 순환하는 현상이 발생할 수 있다. 이를 방지하기 위해 링에 연결한 호스트 중에서 특정 호스트를 모니터로 지정한다. 모니터 호스트는 데이터 프레임이 자신을 지나갈 때 M 비트를 1로 지정한다. M 비트가 1인 프레임이 다시 모니터 호스트를 지나가면 해당 프레임이 한 번 이상 링을 순환했다는 의미가 된다. 따라서 모니터 호스트는 이 프레임을 링에서 제거함으로써, 특정 데이터 프레임이 링을 무한정 순환하는 현상을 방지할 수 있다.
</br>

### 3.3 Frame Control
토큰 링 프레임의 FC 필드는 그림과 같이 LLC 계층에서 목적지 호스트로 전송해줄 것을 요청한 LLC 프레임과 토큰 링 프로토콜에서 사용하는 제어용 프레임을 구분하는 데 사용한다.   

<img src="https://user-images.githubusercontent.com/83942393/129469141-420bf1de-b4fe-4602-83c0-3c1d09565865.png" width="40%" height="40%"></img></br>

TT 비트 값에 의한 프레임 구분은 다음과 같다.
* TT 비트 = 00 : 제어 기능을 수행하기 위한 프레임을 위해 정의되며, CCCCCC 비트의 코드 값으로 제어 명령의 종류를 구분한다.
* TT 비트 = 01 : 상위 계층인 LLC 계층에서 전송을 요구한 LLC 프레임을 의미한다.
</br>

### 3.4 Frame Status
FS 필드는 토큰 링 프레임의 맨 마지막에 위치하며, 프레임의 수신 호스트가 송신 호스트에 응답할 수 있도록 한다.   

<img src="https://user-images.githubusercontent.com/83942393/129469308-96443f16-ac28-4eaa-a38d-675a240b8e82.png" width="40%" height="40%"></img></br>

그림처럼 두 개의 플래그 비트 A, C 필드로 정의되며, 두 필드의 값이 쌍으로 존재한다.   
따라서 한 쌍의 값이 동일한 경우에만 유효한 응답으로 정의되고, 다르면 0으로 처리되어 무시된다.   

* A 비트 : 목적지로 지정한 호스트에서 데이터 프렝임이 링 인터페이스를 통해 자신에게 전달되면 해당 프레임에 접근(Access)했다는 표시로 A 비트를 1로 지정한다. 데이터 프레임의 수신 호스트 주소가 자신의 주소와 다르면 링 인터페이스를 그냥 통과시킨다. 따라서 A 비트의 용도는 목적지 호스트가 링 네트워크에서 제대로 동작하는지 확인하는 것이다.
* C 비트 : 입력된 데이터 프레임의 수신 호스트 주소가 자신의 주소와 동일한 프레임이 지나가면 프레임을 내무 버퍼에 보관하고, C(copy) 비트를 1로 지정한다. C비트가 1로 지정된 프레임이 다시 송신 호스트에 돌아가면 송신 호스트는 A와 C 비트를 점검해 수신 호스트가 데이터 프레임을 제대로 수신했는지 확인할 수 있다.



