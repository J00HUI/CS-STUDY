### 3.3 혼잡 제거
* 가상 회선 방식을 사용하는 서브넷(Subnet)에서 혼잡을 감지했을 때 이를 완화하는 가장 간단한 방법 중 하나는 혼잡이 사라질 때까지 연결 설정을 허락하지 않는 것이다.    
* 그러나 실제 네트워크에서는 전체보다 일부 지점에서 혼잡이 발생하는 경우가 많다.    
* 따라서 특정 지역에 혼잡이 발생하면 패킷의 전송 경로를 적절히 조정해줌으로써 혼잡이 발생한 곳을 거치지 않도록 가상 회선을 연결하는 방안이 필요하다.   
</br>

* 혼잡을 처리하는 또 다른 방식은 호스트와 서브넷이 가상 회선 연결 과정에서 협상하는 것이다.    
* 즉, 전송 과정에서 사용하는 대역을 미리 할당받음으로써, 네트워크에서 수용 불가능한 정도로 트래픽이 발생하는 일을 사전에 예방하는 것이다.    
* 이 방식의 문제점은 개별 연결을 예약한 전송 대역을 해당 사용자가 이용하지 않더라도 다른 사용자가 이용하지 못한다는 점이다.     
* 따라서 이러한 **자원 예약** (Resource Reservation) 방식은 통신 자원을 낭비할 염려가 있다.     
</br>

* 혼잡 처리와 관련된 또 다른 방식은 그림과 같은 **ECN** (Explicit Congestion Notification) 패킷을 사용하는 것이다.   
* 라우터는 자신의 출력 선로 방향으로 전송되는 트래픽의 양을 모니터할 수 있으므로 출력 선로의 사용 정도가 한계치를 초과하면, 주의 표시를 해둔다.
* 그리고 주의 표시한 방향의 경로는 혼잡이 발생할 가능성이 높기 때문에 특별 관리한다.
</br>

p.235 그림

* 혼잡 지역 위치한 라우터는 입력 선로로 들어온 패킷이 주의 표시된 출력 선로로 라우팅 되는 경우에 패킷의 송신 호스트에 ECN 패킷을 전송한다.(1)   
* ECN 패킷을 수신한 송신 호스트는 데이터 패킷이 전송되는 경로에서 혼잡이 발생할 가능성이 있음을 인지하였으므로 전송 패킷의 양을 줄인다.(2)   
</br>

* 특정 라우터에서 주의 표시를 시작하면, 이후 경로에 위치한 라우터에서도 주의 표시할 가능성이 높아지고, ECN 패킷이 여러 라우터에서 동시에 발생할 가능성이 높다.   
* 따라서 최초로 ECN 패킷을 발생시킨 라우터에서는 전송되는 패킷의 헤더 내부에 ECN-Echo 와 같은 임의의 표시를 하여 목적지까지 도착하는 동안에 거치는 라우터가 ECN 패킷을 더 이상 발생하지 않도록 해야 한다.   
</br>

* ECN 패킷을 받은 송신 호스트는 정해진 비율에 따라 송신 패킷의 양을 줄여서 전송해야 한다.    
* 임의의 시간이 경과한 후에도 ECN 패킷이 계속 들어오면 송신 패킷의 양을 추가로 줄이며, 이러한 과정은 ECN 패킷이 발생하지 않을 때까지 계속된다.   
</br>

## 💎 02 라우팅 프로토콜
인터넷에는 수많은 호스트가 연결되므로 관리해야 할 라우팅 정보도 매우 많다.   
그러다보니 라우팅 정보를 적절히 관리하여 효과적으로 라우팅하는 작업이 생각보다 쉽지 않다.    
이 절에서는 다양한 라우팅 관련 프로토콜을 알아본다.(경로 탐색 프로토콜)   
</br>

### 1. 간단한 라우팅 프로토콜
네트워크에서 의미하는 거리의 기준은 다양하지만, 라우팅과 관련해 가장 보편적으로 이용하는 기준은 전송 경로의 중간에 위치하는 라우터의 개수, 즉 **홉** (Hop) 의 수로 판단하는 것이다.    
</br>

### 1.1 최단 경로 라우팅
* 최단 경로 라우팅 방식은 패킷이 목적지에 도달할 때까지 거치는 라우터의 수가 최소화될 수 있도록 경로를 선택한다.
* 장점은 비교적 간단한 형식으로 쉽게 적용할 수 있다는 것인데, 전송 패킷이 목적지까지 도착하는 여러 경로 중 가장 짧은 경로를 선택한다.
</br>

<img width="558" alt="스크린샷 2021-08-24 오후 1 46 10" src="https://user-images.githubusercontent.com/83942393/130557183-85c2666e-8e15-4f08-90f6-cc7c4ca6eec8.png">

```
예를 들어, 그림의 경우 호스트 a 에서 호스트 g 까지 도달하는 경로는 여러 개이지만,
가장 짧은 경로는 라우터 c 만 거치는 것이다.

또 다른 예로 호스트 a 에서 호스트 d 까지 도달하기 위한 최단 경로는 라우터 b 나 c 를 통과하는 것이다.
두 경로는 홉을 기준으로 하면 거리가 동일하다.
```
* 홉 수 위에 거리 기준이 될 수 있는 요소에는 패킷의 전송 지연 시간, 전송 대역폭, 통신 비용 등이 있다.
* 이들 요소를 개별적으로 적용하거나 적절한 비율로 함께 적용할 수 있다.
</br>

### 1.2 플러딩
* 플러딩(Flooding)은 라우터가 자신에게 입력된 패킷을 출력 가능한 모든 경로로 중개하는 방식이다.
* 이 방식에서는 원본 패킷과 동일한 패킷이 무수히 생성되고, 모든 경로를 통해 반복하여 전송하므로 네트워크에 패킷이 무한 개 만들어질 수 있다.
* 패킷이 무한정 증가하는 현상을 방지하려면 각 패킷의 홉 수를 일정 범위로 제한해 라우터에서 이를 확인하여 제거해야 한다.
* 플러딩 방식의 라우팅은 많이 사용하지 않고, 중요한 데이터를 모든 호스트에 동시에 전달하는 환경에서 제한적으로 사용한다.
</br>

### 2. 거리 벡터 라우팅 프로토콜
* 거리 벡터(Distance Vector) 라우팅 프로토콜은 라우터가 자신과 직접 연결된 이웃 라우터와 라우팅 정보를 교환하는 방식이다.
```
정보를 교환하는 라우터는 거리 벡터 프로토콜을 사용하는 호스트나 라우터들이다.
```
* 교환 정보는 각각의 라우터에서 전체 네트워크에 소속되는 개별 네트워크까지 패킷을 전송하는 데 걸리는 거리 정보이다.
* 거리 벡터 알고리즘을 구현하려면 라우터가 링크 벡터, 거리 벡터, 다음 홉 벡터라는 세 가지 필수 정보를 관리해야 한다.
</br>

* **링크 벡터** : 이웃 네트워크에 대한 연결 정보
* **거리 벡터** : 개별 네트워크까지의 거리 정보
* **다음 홉 벡터** : 개별 네트워크로 가기 위한 다음 홉 정보
</br>

### 2.1 링크 벡터
* 링크 벡터 L(x) 는 라우터 x 와 직접 연결된 이웃 네트워크에 대한 연결 정보를 보관한다.   
* 라우터 x 와 직접 연결된 네트워크가 M 개일 때 링크 벡터 정보는 다음과 같이 나타낸다.
```
링크 벡터 L(x) = [ 포트(1), 포트(2), ..., 포트(M) ]
```
* 링크 벡터에 보관된 정보는 라우터 x 가 해당 네트워크와 연결하기 위해 할당한 라우터 포트 번호라고 생각할 수 있다.
</br>

예를 들어, 그림의 네트워크에서 라우터 R1 의 링크 벡터 정보를 구하려면 R1 에 직접 연결된 네트워크가 무엇인지 알아야 한다.   
그림에서는 Net.1 과 Net.2 가 직접 연결되어 있으며, 이는 라우터 R1 의 1번과 3번 포트에 각각 연결되어 있다.   
따라서 라우터 R1 의 링크 벡터 정보는 다음과 같다.    

* L(R1) = \[ 포트(Net.1)=1, 포트(Net.2)=3 ]
</br>

<img src="https://user-images.githubusercontent.com/83942393/130558563-e32e3a9d-394e-4282-9390-aa2e7b911db9.png" width="50%" height="50%"></img></br>
</br>

```
라우터 R2와 R7도 동일한 원리로 다음과 같이 링크 벡터 정보를 구할 수 있고, 다른 라우터들도 같은 방식을 적용할 수 있다.

* L(R2) = [ 포트(Net.1) = 1, 포트(Net.4) = 8 ]
* L(R7) = [ 포트(Net.3) = 6, 포트(Net.5) = 9 ]
```
* 링크 벡터는 자신과 직접 연결된 이웃 라이터가 누군인지를 판단하기 위한 자료이며, 이들에게 거리 벡터 정보를 제공하기 위하여 사용한다.
</br>

### 2.2 거리 벡터





