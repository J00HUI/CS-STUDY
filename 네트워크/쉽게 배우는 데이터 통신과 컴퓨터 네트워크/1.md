### 3.3 혼잡 제거
* 가상 회선 방식을 사용하는 서브넷(Subnet)에서 혼잡을 감지했을 때 이를 완화하는 가장 간단한 방법 중 하나는 혼잡이 사라질 때까지 연결 설정을 허락하지 않는 것이다.    
* 그러나 실제 네트워크에서는 전체보다 일부 지점에서 혼잡이 발생하는 경우가 많다.    
* 따라서 특정 지역에 혼잡이 발생하면 패킷의 전송 경로를 적절히 조정해줌으로써 혼잡이 발생한 곳을 거치지 않도록 가상 회선을 연결하는 방안이 필요하다.   
</br>

* 혼잡을 처리하는 또 다른 방식은 호스트와 서브넷이 가상 회선 연결 과정에서 협상하는 것이다.    
* 즉, 전송 과정에서 사용하는 대역을 미리 할당받음으로써, 네트워크에서 수용 불가능한 정도로 트래픽이 발생하는 일을 사전에 예방하는 것이다.    
* 이 방식의 문제점은 개별 연결을 예약한 전송 대역을 해당 사용자가 이용하지 않더라도 다른 사용자가 이용하지 못한다는 점이다.     
* 따라서 이러한 **자원 예약** (Resource Reservation) 방식은 통신 자원을 낭비할 염려가 있다.     
</br>

* 혼잡 처리와 관련된 또 다른 방식은 그림과 같은 **ECN** (Explicit Congestion Notification) 패킷을 사용하는 것이다.   
* 라우터는 자신의 출력 선로 방향으로 전송되는 트래픽의 양을 모니터할 수 있으므로 출력 선로의 사용 정도가 한계치를 초과하면, 주의 표시를 해둔다.
* 그리고 주의 표시한 방향의 경로는 혼잡이 발생할 가능성이 높기 때문에 특별 관리한다.
</br>

p.235 그림

* 혼잡 지역 위치한 라우터는 입력 선로로 들어온 패킷이 주의 표시된 출력 선로로 라우팅 되는 경우에 패킷의 송신 호스트에 ECN 패킷을 전송한다.(1)   
* ECN 패킷을 수신한 송신 호스트는 데이터 패킷이 전송되는 경로에서 혼잡이 발생할 가능성이 있음을 인지하였으므로 전송 패킷의 양을 줄인다.(2)   
</br>

* 특정 라우터에서 주의 표시를 시작하면, 이후 경로에 위치한 라우터에서도 주의 표시할 가능성이 높아지고, ECN 패킷이 여러 라우터에서 동시에 발생할 가능성이 높다.   
* 따라서 최초로 ECN 패킷을 발생시킨 라우터에서는 전송되는 패킷의 헤더 내부에 ECN-Echo 와 같은 임의의 표시를 하여 목적지까지 도착하는 동안에 거치는 라우터가 ECN 패킷을 더 이상 발생하지 않도록 해야 한다.   
</br>

* ECN 패킷을 받은 송신 호스트는 정해진 비율에 따라 송신 패킷의 양을 줄여서 전송해야 한다.    
* 임의의 시간이 경과한 후에도 ECN 패킷이 계속 들어오면 송신 패킷의 양을 추가로 줄이며, 이러한 과정은 ECN 패킷이 발생하지 않을 때까지 계속된다.   
</br>

## 💎 02 라우팅 프로토콜
인터넷에는 수많은 호스트가 연결되므로 관리해야 할 라우팅 정보도 매우 많다.   
그러다보니 라우팅 정보를 적절히 관리하여 효과적으로 라우팅하는 작업이 생각보다 쉽지 않다.    
이 절에서는 다양한 라우팅 관련 프로토콜을 알아본다.(경로 탐색 프로토콜)   
</br>

### 1. 간단한 라우팅 프로토콜
네트워크에서 의미하는 거리의 기준은 다양하지만, 라우팅과 관련해 가장 보편적으로 이용하는 기준은 전송 경로의 중간에 위치하는 라우터의 개수, 즉 **홉** (Hop) 의 수로 판단하는 것이다.    
</br>

### 1.1 최단 경로 라우팅
* 최단 경로 라우팅 방식은 패킷이 목적지에 도달할 때까지 거치는 라우터의 수가 최소화될 수 있도록 경로를 선택한다.
* 장점은 비교적 간단한 형식으로 쉽게 적용할 수 있다는 것인데, 전송 패킷이 목적지까지 도착하는 여러 경로 중 가장 짧은 경로를 선택한다.
</br>

<img width="558" alt="스크린샷 2021-08-24 오후 1 46 10" src="https://user-images.githubusercontent.com/83942393/130557183-85c2666e-8e15-4f08-90f6-cc7c4ca6eec8.png">

```
예를 들어, 그림의 경우 호스트 a 에서 호스트 g 까지 도달하는 경로는 여러 개이지만,
가장 짧은 경로는 라우터 c 만 거치는 것이다.

또 다른 예로 호스트 a 에서 호스트 d 까지 도달하기 위한 최단 경로는 라우터 b 나 c 를 통과하는 것이다.
두 경로는 홉을 기준으로 하면 거리가 동일하다.
```
* 홉 수 위에 거리 기준이 될 수 있는 요소에는 패킷의 전송 지연 시간, 전송 대역폭, 통신 비용 등이 있다.
* 이들 요소를 개별적으로 적용하거나 적절한 비율로 함께 적용할 수 있다.
</br>

### 1.2 플러딩
* 플러딩(Flooding)은 라우터가 자신에게 입력된 패킷을 출력 가능한 모든 경로로 중개하는 방식이다.
* 이 방식에서는 원본 패킷과 동일한 패킷이 무수히 생성되고, 모든 경로를 통해 반복하여 전송하므로 네트워크에 패킷이 무한 개 만들어질 수 있다.
* 패킷이 무한정 증가하는 현상을 방지하려면 각 패킷의 홉 수를 일정 범위로 제한해 라우터에서 이를 확인하여 제거해야 한다.
* 플러딩 방식의 라우팅은 많이 사용하지 않고, 중요한 데이터를 모든 호스트에 동시에 전달하는 환경에서 제한적으로 사용한다.
</br>

### 2. 거리 벡터 라우팅 프로토콜
* 거리 벡터(Distance Vector) 라우팅 프로토콜은 라우터가 자신과 직접 연결된 이웃 라우터와 라우팅 정보를 교환하는 방식이다.
```
정보를 교환하는 라우터는 거리 벡터 프로토콜을 사용하는 호스트나 라우터들이다.
```
* 교환 정보는 각각의 라우터에서 전체 네트워크에 소속되는 개별 네트워크까지 패킷을 전송하는 데 걸리는 거리 정보이다.
* 거리 벡터 알고리즘을 구현하려면 라우터가 링크 벡터, 거리 벡터, 다음 홉 벡터라는 세 가지 필수 정보를 관리해야 한다.
</br>

* **링크 벡터** : 이웃 네트워크에 대한 연결 정보
* **거리 벡터** : 개별 네트워크까지의 거리 정보
* **다음 홉 벡터** : 개별 네트워크로 가기 위한 다음 홉 정보
</br>

### 2.1 링크 벡터
* 링크 벡터 L(x) 는 라우터 x 와 직접 연결된 이웃 네트워크에 대한 연결 정보를 보관한다.   
* 라우터 x 와 직접 연결된 네트워크가 M 개일 때 링크 벡터 정보는 다음과 같이 나타낸다.
```
링크 벡터 L(x) = [ 포트(1), 포트(2), ..., 포트(M) ]
```
* 링크 벡터에 보관된 정보는 라우터 x 가 해당 네트워크와 연결하기 위해 할당한 라우터 포트 번호라고 생각할 수 있다.
</br>

예를 들어, 그림의 네트워크에서 라우터 R1 의 링크 벡터 정보를 구하려면 R1 에 직접 연결된 네트워크가 무엇인지 알아야 한다.   
그림에서는 Net.1 과 Net.2 가 직접 연결되어 있으며, 이는 라우터 R1 의 1번과 3번 포트에 각각 연결되어 있다.   
따라서 라우터 R1 의 링크 벡터 정보는 다음과 같다.    

* L(R1) = \[ 포트(Net.1)=1, 포트(Net.2)=3 ]
</br>

<img src="https://user-images.githubusercontent.com/83942393/130558563-e32e3a9d-394e-4282-9390-aa2e7b911db9.png" width="50%" height="50%"></img></br>
</br>

```
라우터 R2와 R7도 동일한 원리로 다음과 같이 링크 벡터 정보를 구할 수 있고, 다른 라우터들도 같은 방식을 적용할 수 있다.

* L(R2) = [ 포트(Net.1) = 1, 포트(Net.4) = 8 ]
* L(R7) = [ 포트(Net.3) = 6, 포트(Net.5) = 9 ]
```
* 링크 벡터는 자신과 직접 연결된 이웃 라이터가 누군인지를 판단하기 위한 자료이며, 이들에게 거리 벡터 정보를 제공하기 위하여 사용한다.
</br>

### 2.2 거리 벡터
거리 벡터 D(x)는 전체 네트워크에 소속된 개별 네트워크들까지의 거리 정보를 관리한다.   
네트워크가 N 개라고 가정하면, 거리 벡터 정보는 아래와 같이 표시할 수 있다.    
거리 벡터에서 관리하는 정보는 일반적으로 개별 네트워크까지 패킷을 전송하는 데 걸리는 최소 전송 지연 시간이다.   
```
거리 벡터 D(x) = [거리(1), 거리(2), ... , 거리(N) ]
```
</br>

예를 들어, \[그림 7-8]의 라우터 R1을 위한 거리 벡터 값은 다음과 같이 표시한다.   
전체 네트워크에 포함된 네트워크는 5개이므로, 보관 값도 5개이다. 표시된 거리 값은 홉 수를 가정해 임의의로 표기한 것이다.   
라우터 R1 외의 다른 라우터들도 거리 벡터 정보를 5개씩 보관한다.   

D(R1) = \[ 거리(Net.1) = 1, 거리(Net.2) = 1, 거리(Net.3) = 2, 거리(Net.4) = 2, 거리(Net.5) = 2 ]   
</br>

### 2.3 다음 홉 벡터
아래의 다음 홉 벡터 H(x)는 개별 네트워크까지 패킷을 전송하는 경로에 있는 다음 홉 정보를 관리한다.   
보관하는 정보의 수는 전체 네트워크에 속한 네트워크의 개수로, 거리 벡터의 경우와 같다.   

```
다음 홉 벡터 H(x) = [ 홉(1), 홉(2), ... , 홉(N) ]
```
</br>

예를 들어, \[그림 7-8]의 라우터 R1 을 위한 다음 홉 벡터 값은 다음과 같이 표시할 수 있다.   
보관하는 값은 거리 벡터의 개수와 같은 5개이다.    
'다음 홉(Net.4)'의 경우는 라우터 R2가 될 수도 있지만, 라우터 R3의 경로가 더 빠르다는 전제로 값이 결정되었다.   

H(R1) = \[ 다음 홉(Net.1) = -, 다음 홉(Net.2) = -, 다음 홉(Net.3) = R4, 다음 홉(Net.4) = R3, 다음 홉(Net.5) = R6 ]    
</br>

### 2.4 RIP 프로토콜
* RIP(Routing Information Protocol) 는 거리 벡터 방식을 사용하는 **내부 라우팅 프로토콜** 중에서 가장 간단하게 구현된 것이다.
* 소규모 네트워크 환경에 적합하며, 현재 가장 많이 사용하는 라우팅 프로토콜 중 하나이다.
* RIP가 제대로 동작하려면, 이웃 라우터가 제공하는 거리 벡터 정보가 임의의 짧은 시간 내에 모두 도착해야 한다.
* 하지만 현실적으로 구현이 쉽지 않다.
* 특히 RIP 패킷은 UDP 프로토콜을 사용하는데, UDP 는 비신뢰성 전송을 제공하므로 RIP 패킷이 전송 과정에서 사라질 수도 있다.
* 이런 이유 때문에 RIP 는 다음과 같은 제한을 두어 개별 거리 정보가 라우팅 테이블에 순차적으로 적용되도록 한다.
* 첫 번째와 두 번째는 자신이 관리하는 거리 벡터 정보에 대한 내용이고, 세 번째는 다른 라우터로부터 받는 거리 벡터 정보이다.
</br>

* 입력되는 거리 벡터 정보가 새로운 네트워크의 목적지 주소이면 라우팅 테이블에 적용한다.
* 입력되는 거리 벡터 정보가 기존 정보와 비교하여 목적지까지 도착하는 지연이 더 적으면 대체한다. 즉, 이전 정보와 홉 수가 같아도 추가 지연 측정을 통해 지연 시간이 더 적으면 새로운 경로를 선택한다.
* 임의의 라우터로부터 거리 벡터 정보가 들어왔을 때, 라우팅 테이블에 해당 라우터를 다음 홉으로 하는 등록 정보가 있으면 새로운 정보로 수정한다.
</br>

예를 들어, \[그림 7-8] 에서 라우터 R1의 라우팅 테이블에 다음 표와 같은 정보가 기록되어 있다고 가정한다.   

| 목적지 네트워크 | 다음 홉 | 거리 |
|:----------:|:----------:|:----------:|
| Net.1 | - | 1 |
| Net.2 | - | 1 |
| Net.3 | R4 | 2 |
| **Net.4** | **R4** | **3** |
| Net.5 | R6 | 2 |

값 중에서 주목해야 할 사항은 네트워크 Net.4를 목적지로 하는 패킷은 라우터 R4를 거쳐서 네트워크 Net.3 과 라우터 R5의 경로를 선택하도록 되어 있다.    
(이는 극단적으로 나쁜 상황을 가정한 것으로, 라우터 R3을 통한 우회 경로가 빠른 전송을 지원한다. )   

라우터 R1 과 **직접 연결된 주변 라우터** R2, R3, R4, R6 으로부터 라우팅 정보가 주기적으로 입력된다.   
임의의 시점에 다음의 거리 벡터 정보가 들어온다고 가정해보자.   
각 값은 순서대로 Net.1, Net.2, Net.3, Net.4, Net.5 까지의 거리이다.   

R2 = \[1, 2, 2, 1, 2]   
R3 = \[2, 1, 2, 1, 2]   
R4 = \[2, 1, 1, 2, 2]   
R6 = \[2, 1, 2, 2, 1]   

이 값을 해석하면, 네트워크 Net.4 로 갈 때 라우터 R4 나 R6을 거치면 거리가 2이지만, 라우터 R2나 R3 을 거치면 1이다.    
라우터 R2와 R3을 이용하는 것이 거리가 짧으므로 이 중 하나를 선택하는데, 라우터 R1 에서 라우터 R2나 R3으로 가는 거리 1을 더하면 최종 거리는 2이다.    
결과적으로 위의 표보다 패킷을 빠르게 전송할 수 있는 새로운 경로를 찾았으므로 이를 라우팅 테이블에 반영한다.    
라우터 R3을 선택했다고 가정하면 새로 수정한 라우터 R1의 라우팅 테이블은 다음 표와 같다.    
   
표 7-2 수정 후 라우터 R1 의 라우팅 테이블    
| 목적지 네트워크 | 다음 홉 | 거리 |
|:----------:|:----------:|:----------:|
| Net.1 | - | 1 |
| Net.2 | - | 1 |
| Net.3 | R4 | 2 |
| **Net.4** | **R3** | **2** |
| Net.5 | R6 | 2 |
</br>

### RIP 패킷의 구조
* RIP는 라우터 사이에서 링크 벡터, 거리 벡터, 다음 홉 벡터 등의 정보를 교환하려고 아래 그림과 같은 패킷 구조를 사용한다. 
* 각 필드의 의미는 다음과 같다.
* 두 번째 줄부터는 개별 네트워크에 대한 거리 정보를 묶음 단위로 기술하는데, RIP 패킷 하나는 최대 25개의 묶음 정보를 포함할 수 있다.
</br>

![image](https://user-images.githubusercontent.com/83942393/130733167-ce74371a-832d-46bc-9f81-6d5752244fd0.png)
</br>

* **Command(명령)** : 값이 1이면 RIP 요청을, 2이면 RIP 응답을 의미한다. 라우터가 초기화되는 과정에서 RIP 요청이 브로드캐스팅되면 이 패킷을 받은 라우터들은 즉각 응답한다.
* **Version(버전)** : RIP 프로토콜의 버전 번호이다.
* **Address Family Identifier( 주소 패밀리 구분자 )** : IP 프로토콜의 주소는 2로 설정된다.
* **IP Address(IP 주소)** : 특정한 네트워크를 지칭하는 용도로 사용되기 때문에 IP 주소의 네트워크 부분의 값만 사용하고, 호스트 부분은 0으로 채운다.
* **Metric(거리)** : 해당 라우터에서 목적지 네트워크까지의 거리이다.
</br>

### 3. 링크 상태 라우팅 프로토콜
* 두 번째 방식은 링크 상태(Link State) 라우팅 프로토콜은 라우터 간의 정보 교환 원리가 거리 벡터 방식와 반대이다.
* 개별 라우터가 이웃 라우터까지의 거리 정보를 구한 후, 이를 네트워크에 연결된 모든 라우터에 통보한다.
* 거리 벡터 라우팅 프로토콜에서는 각 라우터가 상당한 양의 정보를 요구받고, 특히 링크 상태가 많이 변하면 동작 과정에서 시간이 많이 소요될 수 있다.
* 링크 상태 알고리즘은 이와 같은 단점을 극복하려고 고안된 방식이다.
* 거리 벡터 라우팅 프로토콜은 알고리즘의 특성상 정보가 주기적으로 전달되지만, 링크 상태 라우팅 프로토콜에서는 이웃 라우터와 연결된 상황에 변화가 있을 때만 정보 전달이 이루어진다.
* 링크 상태 라우팅 프로토콜은 정보 전달을 위해 플러딩(Flooding) 기법을 사용한다.
* 임의의 라우터가 이웃한 모든 라우터에 정보를 전달하고, 다시 이들 라우터가 주변의 모든 라우터에 정보를 전달하는 방식으로 동작한다.
* 이때 정보가 입력된 선로를 통해 출력되지 않도록 주의해야 한다.
* 플러딩 방식을 사용하면 특정 패킷이 네트워크에서 무한히 순환될 수 있다는 점을 고려해야 한다.
* 간단한 해결 방법은 각 라우터가 전송된 패킷을 기억했다가 해당 패킷이 다시 도착하면 무시하고 버리는 것이다.
* 링크 상태 방식을 사용하는 라우팅 프로토콜에는 TCP/IP 기반의 인터넷에서 사용하는 OSPF(Open Shortest Path First)가 있다.
* 링크 상태 라우팅 프로토콜과 거리 벡터 라우팅 프로토콜은 모두 다음과 같은 가정을 전제로 동작한다.
* 각 라우터는 이웃 라우터의 주소 정보와 함께 이들 라우터까지 패킷을 전송하는 데 필요한 비용 정보를 알고 있으며, 이때 비용의 종류는 패킷 전송 지연 등을 비롯해 여러 가지가 될 수 있다.
</br>

### 4. 외부 라우팅 프로토콜
* 거리 벡터 방식을 사용하는 RIP 프로토콜이나 링크 상태 방식을 사용하는 OSPF 프로토콜은 내부 라우팅 용도로 개발되었다.
* 따라서 이 방식을 **외부 라우팅 프로토콜** 에서 사용하기는 적합하지 않다.
</br>

* 외부 라우팅 프로토콜에서 사용하는 **경로 벡터** (Path Vector) 프로토콜은 경로에 관한 거리 정보 값이 필요 없는 방식이다.
* 단순히 해당 라우터에서 어느 네트워크가 연결 가능한지에 대한 정보만을 제공한다.
* 이는 근거리의 경로 정보를 관리하는 내부 라우팅 프로토콜이 효율의 문제를 고려하지만, 원거리의 경로 정보를 관리하는 외부 라우팅 프로토콜은 경로의 존재 유무에 초점을 맞추기 때문이다.
</br>

* 경로 벡터 방식은 거리 벡터 방식과 두 가지 면에서 다르다.
* 첫째, 거리에 대한 처리 과정이 이루어지지 않는다.
* 둘째, 관리하는 라우팅 정보에는 목적지 네트워크에 도착하기 위한 자율 시스템에 관한 내용만 포함한다.
</br>

* BGP(Border Gateway Protocol)은 외부 라우팅 프로토콜로, 인터넷에서 많이 사용된다.
* BGP는 서로 다른 종류의 자율 시스템에서 동작하는 라우터가 라우팅 정보를 교환할 수 있도록 해준다.
* 이와 같이 종류가 다른 환경에서 동작하는 라우터를 일반적으로 게이트웨이(Gateway)라 한다.
</br>

* BGP는 TCP 프로토콜을 이용해 메시지를 교환한다.
* 프로토콜에서 제공하는 메시지의 종류는 다음과 같다.
</br>

| 메시지 | 설명 |
|:----------|:----------|
| Open | 다른 라우터와 연관(Relationship)을 설정한다. |
| Update | 라우팅 관련 정보를 전달한다. |
| KeepAlive | Open 메시지에 대한 응답 기능과 주변 라우터와의 연관을 주기적으로 확인한다. |
| Notification | 오류 상태를 통보한다. |
</br>

## 💎 03 IP 프로토콜
인터넷 환경에서 네트워크 계층의 데이터 전송 프로토콜로 이용되는 IP 는 호스트 주소 표기, 패킷 분할에 관한 기능을 지원하지만, 단대단 형식의 오류 제어나 흐름 제어 기능은 제공하지 않는다.    
IP 프로토콜의 라우터간의 패킷을 중개할 때는 Best Effort 라는 원칙에 따라 전송되는데, 이 방식은 전송 패킷이 수신 호스트에 100% 도착하는 것을 보장하지 않는다.     
따라서 IP 프로토콜에서 제공하지 않는 전송 오류 문제를 상위 계층에서 제공해야 한다.    

*(이 부분 이해 안간다.... 전송 오류라면 패킷 분실과 변형이 있을 텐데, 패킷 분실이면 데이터 링크 계층에도 프레임이 도착안했을테니 패킷을 재전송 받고, 변형이면 (데이터 체크섬은 제공하지 않는댔으니까 헤더 변형 오류가 발생하면) NAK 응답 프레임을 보내던가 타임아웃 기능으로 인한 패킷 재전송이 이루어지는데, 이 응답 프레임을 하위 계층에 전달하는 걸 전송 계층에서 한다는 의미인가...? 네트워크 계층에서 헤더를 제거한 데이터가 전송 계층으로 올라오지 않으면 전송 오류가 났다고 판단하고 재전송을 요구하는 건가...)*     

IP 프로토콜의 주요 특징은 다음과 같다.     
* 비연결형 서비스를 제공한다.
* 패킷을 분할/병합하는 기능을 수행하기도 한다.
* 데이터 체크섬은 제공하지 않고, 헤더 체크섬만 제공한다.
* Best Effort 원칙에 따른 전송 기능을 제공한다.
</br>

### 1. IP 헤더 구조
그림은 IP 프로토콜에서 정의된 **패킷의 IP 헤더 구조** 이다.   
상단의 숫자는 비트 수이다.     

![image](https://user-images.githubusercontent.com/83942393/130743222-ee275986-7d6d-43fe-a8b3-ba6adcb449c6.png)
</br>

여기서는 헤더 필드를 연관된 종류별로 묶어 설명한다.    
</br>

### 1.1 DS/ECN
* DS(Differentiated Services)와 ECN(Explicit Congestion Notification) 필드가 도입되기 전에는 8비트의 Service Type(DS+ECN) 필드로 정의되어, 우선 순위, 지연(ECN?), 전송률, 신뢰성 등의 값을 지정할 수 있었다.
* Service Type 필드는 IP 프로토콜이 사용자에게 제공하는 서비스의 품질에 관련된 내용을 표현하는데, 각 비트 값의 의미는 다음과 같다.
</br>

| 비트 번호 | 각 비트의 값 | |
|:----------|:----------|:----------|
| | 0 | 1 |
| 0~2 | 우선순위( 111 : 가장 높음 ) | |
| 3 | 보통의 지연 | 낮은 지연 |
| 4 | 보통의 전송률 | 높은 전송률 |
| 5 | 보통의 신뢰성 | 높은 신뢰성 |
| 6~7 | 예약 | |
</br>

* 차등 서비스 개념이 도입되면서 Service Type 필드는 6비트의 DS 필드와 2비트의 ECN 필드로 새로 정의되었다.
* 이는 인터넷에서 다양한 트래픽 요구 조건을 필요로 하는 서비스들에 대하여 서로 다른 수준의 Qos(Quality of Service) 를 지원하기 위함이다.
```
DS를 사용하기 위해 사전에 서비스 제공자와 서비스 이용자 사이에 서비스 등급에 대한 합의가 이루어지며, 동일한 DS 값을 갖는 트래픽들은 동일한 서비스 등급으로 처리한다.
이러한 처리 과정은 라우터에 의해 이루어지므로, 기존 응용 프로그램들을 변경할 필요가 없다.
```
* ECN 필드 값의 의미는 다음의 표와 같다. </br> (여기서 ECT 0과 ECT 1은 동일한 의미이며, 어느 것을 사용해도 무관하다. )
* 송신 호스트가 라우터에게 IP 패킷에 캡슐화된 TCP 프로토콜이 ECN 기능을 지원한다고 알려주기 위하여 사용한다. *(전송 계층에서 전송하는 데이터를 늦추는 것 같다. 데이터 링크 계층은 단대단 흐름 제어 기능을 담당하고)*
* ECN 기능을 위하여 TCP 프로토콜의 헤더에 ECE 필드와 CWR 필드가 추가되었다. 
</br>

표 7-5 ECN 필드 값의 의미    
| 필드 값 | 의미 |
|:-----------|:----------|
| 00 | IP 패킷이 ECN 기능을 사용하지 않음을 의미한다. |
| 01(ECT 1) | TCP 프로토콜도 ECN 기능을 지원한다는 의미이다. |
| 10(ECT 0 ) | TCP 프로토콜도 ECN 기능을 지원한다는 의미이다. |
| 11(CE: Congestion Experienced) | 라우터가 송신 호스트에 혼잡을 통지할 때 사용한다. |
</br>

* DS 코드 포인트(Code point) 라고도 하는 DS 필드 값은 차등 서비스의 기준이 되는 레이블 값으로 64 개의 트래픽 클래스를 정의할 수 있다. 
* DS 서비스는 비교적 단순한 원리에 의하여 차등화된 서비스를 제공하지만, 내부적인 처리 과정은 복잡한 구조에 의하여 이루어진다.
</br>

### 1.2 패킷 분할












