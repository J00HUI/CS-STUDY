### 2. 다항 코드
CRC(Cyclic Redundancy Code)라고도 알려진 다항 코드(Polynomial Code) 방식은 현재의 통신 프로토콜에서 가장 많이 사용하는 오류 검출 기법이다.   
특히, 일반 네트워크에서 발생하는 오류는 특정 위치에서 집중적으로 발생하는 버스트 에러(Burst Error) 형태인 경우가 많은데, 다항 코드 방식은 이런 오류를 검출하는 확률이 높은 것으로 알려져 있다.   
</br>

### 2.1 생성 다항식
* 다항 코드 방식은 게수가 0과 1인 다항식 형태를 기반으로 한다.
```
예를 들어, 100101의 다항 코드를 다항식으로 표시하면 1 x x^5 0 x x^4 + 0 x x^3 + 1 x x^2 + 0 x x^1 + 1 x x^0 이 되므로, 
줄여서 생성 다항식 x^5 + x^2 + 1 로 표현할 수 있다.
```

다항 코드 방식을 이용한 오류 검사의 동작 원리는 아래 그림과 같다.   
<그림 p.147>

* 송신 호스트가 전송할 데이터가 m 비트의 M(x)라면, 데이터 전송 과정에서 n+1 비트의 생성 다항식 G(x)를 사용해, 오류 검출 코드를 생성함으로써 오류 제어 기능을 수행한다.
* 먼저 송신 호스트는 전송 데이터 M(x)를 생성 다항식 G(x)로 나누어, 체크섬(Checksum) 정보를 얻는다.
* 그림처럼 나누기 연산 과정에서는 전송 데이터 뒤에 나머지를 보관할 n 비트의 공간을 확보하고, 이 자리를 모두 0으로 채운 후에 나누기 연산을 수행한다.
* 연산에서 얻은 나머지 값을 체크섬이라 정의하며, 체크섬을 전송 데이터의 뒤에 추가해 수신 호스트에 전달해야 한다.
```
체크섬 계산인 나누기 과정에서 발생하는 다항 연산은 모듈로-2 방식으로 이루어진다.
따라서 덧셈의 자리 올림이나 뺄셈의 자리 빌림 과정이 이루어지지 않으므로, 덧셈과 뺄셈은 배타적 논리합(Exclusive OR) 연산과 동일한 결과를 얻는다.
```
<그림 p.147>

* 수신 호스트는 전송 오류가 발생했는지를 판단하기 위해 수신한 m+n 비트의 데이터를 생성 다항식 G(x)로 나누는 연산을 수행한다.
* 연결 결과로 얻은 나머지가 0이면 전송 오류가 없다고 판단하고, 0이 아니면 오류가 발생했다고 판단한다.
</br>

### 2.2 체크섬의 예
> CRC 기법의 코드워드 계산 과정
* 예를 들어, 생성 다항식 G(x) = x^8 + x^2 + x + 1 (CRC-8, 9 bit)이 주어지고, 전송 데이터가 01101011인 경우의 체크섬 계산 과정은 아래 그램과 같다.
* 계산을 통해 얻은 나머지는 00010110(8 bit)이므로, 송신 데이터는 01101011**00010110** 이 된다.

![image](https://user-images.githubusercontent.com/83942393/129151319-c3515d25-1dba-4a83-be14-b503f984e546.png)
</br>
</br>

> CRC 기법의 에러 검증 과정
* 수신 호스트는 수신 데이터 0110101100010110을 생성 다항식 100000111로 나누기 연산을 수행한다.
* 이때 나머지가 0이면 전송 오류가 없고, 0이 아니면 오류가 발생한 것으로 판단할 수 있다.

![image](https://user-images.githubusercontent.com/83942393/129151899-fedbab44-eae8-42d8-ab76-1876fb2ec37f.png)
</br>
</br>

> 현재 국제 표준으로 널리 이용되는 생성 다항식의 일부
```
* CRC-12 : x^12 + x^11 + x^3 + x^2 + x^1 + 1
* CRC-16 : x^16 + x^15 + x^2 + 1
* CRC-CCITT : X^16 + x^12 + x^5 + 1
```

