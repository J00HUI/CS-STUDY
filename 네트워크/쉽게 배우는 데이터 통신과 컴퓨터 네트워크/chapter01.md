## Chapter 01. 네트워크의 기초 용어와 기능

<img src="https://user-images.githubusercontent.com/83942393/127731691-ee85ee75-5d8e-46b1-a91e-9913f05b739f.png" width="70%" height="70%"></img> 
<img src="https://user-images.githubusercontent.com/83942393/127731722-34f629a0-e348-49fe-affa-8482abc89bfb.png" width="70%" height="70%"></img>


### 🔆 Preview   
단어의 의미에 대한 부분적인 이해 부족과 그에 따른 왜곡이 여러 단어 표시되는 전체 시스템을 이해하는 데 방해 요인이 될 수 있다.    
인터넷 용어를 정확히 이해하고, 이를 바탕으로 전체 시스템을 파악하는 일이 선행되어야 한다.    
특히 전문용어를 기존 단어의 사전적인 의미로 막연히 짐작하면 편견의 우물에 갇히는 오류를 범할 수 있다.    

컴퓨터 네트워크는 OSI 7계층 모델이라는 표준화된 정책에 따라 계층마다 고유한 독릭접 기능을 수행한다.    
따라서, 7계층 모델의 대강을 살펴보고, 마지막으로 네트워크에 연결된 시스템에 부여되는 주소의 개념에 대해 알아본다.    
</br>

### 💎 01 네트워크 관련 기초 용어
용어의 의미를 올바르게 이해하려면, 단어가 지닌 사전적 의미에 대해 선입견을 가지면 안 된다.   
새로운 기술에 용어를 부여할 때는 보통 의미가 가장 유사한 기존 단어를 재활용한다.    
그러다 보니, 단어의 원래 의미를 토대로 새로운 용어를 이해하는 경향이 나타나는데, 이는 새로운 학문을 접하는 데 커다란 장애 요소가 되기도 한다.   
그러므로 이 부분을 경계하며, 이 장의 핵심 주제인 네트워크의 기초 용어부터 하나씩 알아보자.   
</br>

### 1. 네트워크 기초 용어  

* **인터넷(Internet)** 은 연구소, 기업, 학교 등의 소규모 조직에서 사용하기 시작한 작은 단위의 네트워크(Network)들을 서로 연결하면서 발전하였다.   
* 그 과정에서, 자연스럽게 연결 방식의 표준화를 요구하게 되었고, 오늘날 전 세계로 확산되어 거대한 인터넷으로 성장하였다.   
* **네트워크(network)** 는 전송 매체(transmission media)를 매개로 서로 연결되어 데이터를 교환하는 시스템(system)의 모음이며,    
* 시스템과 전송 매체의 연결 지점에 대한 규격이 **인터페이스(Interface)** 이다.   
* 시스템이 데이터를 교환할 때는, 임의의 통신 규칙인 **프로토콜(Protocol)** 을 따른다.   
* 프로토콜처럼 서로 다른 시스템을 상호 연동해 동작시키려면, 연동 형식의 통일이 필요하고, 이 통일을 **표준화(Standardization)** 라 한다.   
</br>

그림은 시스템과 전송 매체로 네트워크를 구성한 예이다.   
* 시스템은 반드시 컴퓨터일 필요는 없지만, 보통 컴퓨터 시스템으로 가정한다. 
* 시스템들은 물리적으로 공유하는 전송 매체에 의하여 서로 연결된다.   
* 시스템이 전송 매체를 통해 데이터를 교환하려면, 반드시 표준화된 프로토콜을 사용해야 한다.
* 흔히 사용하는 인터넷은 IP(Internet Protocol)라는 네트워크 프로토콜을 사용하는 네트워크의 집합체이다.
```    
여기서 IP는 프로토콜의 의미가 포함된 약자이지만, 보통 IP 프로토콜이라 부릅니다.
```
</br>

<img src="https://user-images.githubusercontent.com/83942393/127486110-18acf36f-4040-4713-bc2a-9744df0aad55.png" width="60%" height="60%"></img></br>
그림 1-1 네트워크의 구성   
</br>

네트워크의 구성 요소의 개념을 좀 더 자세히 알아보자.   

### 1.1 시스템
* 시스템(system) 은 **내부 규칙에 따라 능동적으로 동작하는 대상** 을 가리킨다.
* 자동차, 커피 자판기, 컴퓨터, 마이크로 프로세서, 하드디스크와 같은 물리적인 대상뿐 아니라, 
* 신호등으로 교통을 제어하는 운영 시스템, MS 윈도우즈 등의 운영체제, 프로그램의 실행 상태를 의미하는 프로세스 같은 논리적인 대상들도 시스템이다.   
* 시스템의 동작에 필요한 외부에 입력이 있을 수 있으며, 내부 정보와 외부 입력의 조합에 따른 출력(시스템 실행의 결과물)이 있을 수 있다.
* 한편, 작은 시스템이 여러 개 모여 더 큰 시스템을 구성할 수 있으므로, 크기를 기준으로 시스템을 나누지는 않는다.
</br>

### 1.2 인터페이스
* 인터페이스(Interface)는 **시스템과 시스템을 연결하기 위한 표준화된 접근 방법** 이다.
* 예를 들어, 컴퓨터 본체와 키보드를 연결하여 제대로 동작하게 하려면, 키보드의 잭을 본체의 정해진 위치에 꽂아야 한다.
* 이렇게 하려면, 상호 간의 데이터 교환을 위한 RS-232C, USB 등과 같은 논리적 규격뿐만 아니라, 잭의 크기와 모양 같은 물리적인 규격도 표준화되어야 한다.
* 인터페이스를 이용해 연결하는 시스템은 능력과 권한이 같은 경우도 있지만, 서로 서비스를 주고 받는 상하 관계일 수도 있다. 
</br>

### 1.3 전송 매체
* 시스템끼리 정해진 인터페이스를 통해 연동해 데이터를 전달하려면, **물리적인 전송 수단** 인 전송 매체(Transmission Media) 가 반드시 있어야 한다.
* 전송 매체는 동축 케이블을 포함하여, 소리를 전파하는 공기, 무선 신호 등 다양하게 존재한다.
* 인터페이스는 시스템간의 연동을 위한 논리적인 규격이고, 인터페이스에서 정해진 규격은 매체를 통해 전송됨으로써 구현되고 동작된다고 볼 수 있다.
</br>

### 1.4 프로토콜
* 상호 연동되는 시스템이 전송 매체를 통해 데이터를 교환할 때는 **표준화된 특정 규칙** 을 따르는데, 이 규칙을 프로토콜(Protocol) 이라 한다.
* 일반적으로 프로토콜은 주종 관계가 아닌, 동등한 위치에 있는 시스템 사이의 규칙이라는 측면이 강조되어 인터페이스와 구분된다.
* 인터페이스는 두 시스템이 연동하기 위한 특정한 접촉 지점(Access Point)을 의미하는 경우가 많지만, 프로토콜은 **주고받는 형식과 그 과정에서 발생하는 일련의 절차적 순서** 에 무게를 둔다.
</br>

### 1.5 네트워크
* 통신용 매체를 공유하는 여러 시스템이 프로토콜을 사용하여 데이터를 주고받을 때, 이들을 하나의 단위로 통칭하여 **네트워크(Network)** 라 부른다.
* 일반적인 컴퓨터 네트워크에서는 물리적인 통신 매체로 연결된 컴퓨터들이 **동일한 프로토콜**을 이용해 서로 데이터를 주고받는다.
* 소규모 네트워크가 모여 더 큰 네트워크를 구성할 수 있는데, 네트워크끼리는 **라우터(Router)** 라는 중개 장비를 사용해서 연결한다.
</br>

### 1.6 인터넷
* 인터넷(Internet)은 **전 세계** 의 모든 네트워크가 유기적으로 연결되어 동작하는 **통합 네트워크** 이다. 
* 인터넷으로 연결된 시스템, 인터페이스, 전송 매체, 프로토콜 은 그 종류가 매우 복잡하고 다양하지만, 데이터 전달 기능에 한해서는 공통으로 IP 프로토콜을 사용한다.
```
인터넷이라는 용어는 IP 의 첫 단어인 Internet에서 유래했습니다.
```
</br>

### 1.7 표준화
* 서로 다른 시스템이 상호 연동해 동작하려면, 표준화(Standardization)라는 **연동 형식의 통일** 이 필요하다.
* 예를 들어, 프린트 용지를 생각해보자.
* 일반적으로 프린터와 프린터 용지를 만드는 회사는 다르다. 하지만, 사전에 A4 규격이라는 통일된 틀을 만들어두었기 때문에, 서로 다른 회사에서 생산한 프린터와 프린트 용지를 자유롭게 사용할 수 있는 것이다.

![image](https://user-images.githubusercontent.com/83942393/127645497-bf8d87cf-3253-4c3a-bd3a-e9436b715ab1.png)
</br>

* 현대 산업사회가 눈부시게 성장한 배경에는 증기기관의 개발에 따른 에너지 동력원의 발전이 있었다.
* 그러나 이와 다른 관점에서 더 근원적으로 살펴보면, 표준화 원리를 바탕으로 한 레고의 조합 개념이 산업 전반에 존재해왔기 때문임을 이해해야 한다.
</br>

### 2. 시스템 기초 용어
그림과 같이 네트워크는 외형적으로 **시스템** 과 **전송 매체** 의 조합으로 구성된다.    
데이터 통신을 위한 **전송 매체** 는 전송 대역, 전송 속도, 전송 오류율 같은 물리적인 특성이 주 관심사이므로, 논리적인 기능은 비교적 단순하다.    

그러므로 여기서는 **시스템** 에 대해서만 자세히 살펴본다.    
시스템은 전송 매체를 이용해 다양한 연동 형태로 구성할 수 있으므로, 개념이 폭이 넓고 복잡하다.    

### 2.1 시스템의 구분
네트워크를 구성하는 시스템이 반드시 컴퓨터처럼 복잡한 기능을 수행해야 하는 것은 아니지만, 일반적으로 컴퓨터 시스템으로 가정한다.    
네트워크 시스템은 수행 기능에 따라 다음과 같이 다양한 명칭으로 부를 수 있다.    
</br>

> 노드
* 노드(Node)은 인터넷에 연결된 시스템을 가장 일반화한 용어이다.
* 데이터를 주고 받을 수 있는 모든 시스템을 통칭하여 사용한다.
</br>

> 호스트
* 호스트(Host)는 일반적으로 컴퓨팅 기능이 있는 시스템을 의미한다.
* 일반 사용자가 호스트 내의 응용 프로그램을 실행하므로, 사용자가 네트워크에 접속하는 창구 역할을 한다.
</br>

> 클라이언트
* 호스트를 세분할 때는, 호스트 사이에 제공되는 서비스를 기준으로 클라이언트와 서버로 나눌 수 있다.
* 클라이언트(Client)는 서비스를 이용하는 시스템이고, 서버(Server)는 서비스를 제공하는 시스템이다.
* 호스트는 다양한 서비스를 주고 받기 떄문에 임의의 호스트가 클라이언트나 서버로 고정되지 않는다.
* 이용하는 서비스의 종류에 따라서 클라이언트가 될 수도 있고, 서버가 될 수도 있다.
* 그러므로 특정 서비스를 기준으로 상대적인 관점에서 클라이언트와 서버라는 용어를 사용한다.
</br>

> 서버
* 서버(Server)는 서비스를 주고받는 호스트의 관계에서 임의의 서비스를 제공하는 시스템이다.
* 일반적으로 서버는 클라이언트보다 먼저 실행 상태가 되어 클라이언트의 요청에 대기해야 한다.
* 그리고 영원히 종료되지 않으면서 클라이언트의 요청이 있을 때마다 서비스를 반복해서 제공해야 한다.
</br>

### 2.2 클라이언트와 서버
* 그림은 임의의 서비스를 기준으로 클라이언트와 서버의 상대적인 관계를 설명한다.    
* 그림에서 호스트 2 는 파일 송수신 기능을 제공하는 FTP(File Transfer Protocol) 서비스를 제공하며, 호스트 3 은 원격 단말기 기능은 텔넷(Telnet) 서비스를 제공한다.   
</br>

<img src="https://user-images.githubusercontent.com/83942393/127646933-938a21e1-4ac5-4023-b5e3-091695b06587.png" width="40%" height="40%"></img> 그림 1-3 클라이언트와 서버
</br>
</br>

* FTP 서비스를 기준으로 하면, 호스트 1이 클라이언트가 되고, 호스트 2는 서버가 된다.
* 반면, 텔넷 서비스를 기준으로 하면, 호스트2가 클라이언트이고, 호스트 3는 서버이다.
* 따라서 호스트 2는 사용하는 서비스의 종류에 따라 클라이언트가 되기도 하고 서버가 되기도 한다.
* 결론적으로 클라이언트와 서버라는 용어는 서비스 이용의 상대적인 위치에 따라 결정됨을 알 수 있다.
</br>

* 클라이언트와 서버의 명칭을 호스트 시스템에 부여해서 사용할 수도 있다.
* 특히, 다양한 서비스 기능을 제공하는 대형 시스템을 서버로 설정해, 다수의 클라이언트가 접속해서 서비스를 이용하도록 할 수 있다.
* 그러나 기능적인 관점에서는 위의 그림처럼 호스트에서 실행되는 응용 서비스별로 구분하는 것이 더 정확하다.
* 인터넷에서 네트워크 서비스의 기능은 대부분 응용 프로그램으로 구현되므로, 보통 클라이언트 프로세스, 서버 프로세스라는 호칭이 더 자연스러울 수 있다.
</br>

### 💎 02 네트워크의 기능

네트워크는 다수의 시스템을 전송 매체로 연결해 구성한 시스템들의 집합체이다.    
소규모의 네트워크들은 전송 매체로 연결되어 더 큰 네트워크로 확장될 수 있다.   

컴퓨터 네트워크는 외형상, 호스트 시스템과 전송 매체로 구분된다.    
하지만 이런 물리적인 형태와는 별도로, 그들이 수행하는 내부 기능을 기초로 하여 다양한 구조로 세분화할 수 있다.   
특히, 호스트가 제공하는 복잡한 네트워크 기능을 연관된 그룹으로 묶어 계층 모델로 설명할 수 있다.     

### 1. 계층 모델

* 특징이 다른 여러 호스트들을 서로 연결해서 통신하려면, 연결 방식을 표준화해야 한다.   
* 국제 표준화 단체인 ISO(International Standard Organization)에서는 OSI(Open System Interconnection) 7 계층 모델을 제안하여, **네트워크에 연결된 시스템이 갖추어야 할 기능을 상세히 정의** 하고 있다.   

### 1.1 OSI 7계층 모델 소개
* OSI 7 계층 모델(OSI 7 Layer Model)에 따르면, 네트워크에 연결된 호스트들은 그림과 같이 7개의 계층으로 모듈화된 통신 기능을 갖춰야 한다.
* 일반 사용자는 OSI 7계층 맨 위에 있는 응용 계층을 통해 데이터의 송수신을 요청하며, 이 요청은 하위 계층에 순차적으로 전달되어 맨 아래에 있는 물리 계층을 통해 상대 호스트에 전송된다.
* 그리고 요청이 각 계층으로 하달되는 과정에서 계층 별로 자신이 담당하는 기능을 수행하여 데이터를 안전하게 전달해준다.
* 데이터를 수신하는 호스트에서는 송신 호스트와는 반대 방향으로 처리가 이루어진다.
* 즉, 물리 계층으로 들어온 데이터는 순차적인 상향 전달 과정을 거쳐 응용 계층으로 올라간다. 
* 수신 호스트에서 처리가 완료된 결과를 회신할 떄는 반대 과정을 순차적으로 밟아서 송신 호스트로 되돌아간다.
* 데이터를 송수신하는 최종 주체는 송수신 호스트 양쪽에 위치한 응용 계층이며, 하부의 계층들은 응용 계층을 지원하기 위하여 데이터 전송에 필요한 기능을 나누어 처리한다.
* 이와 같은 원리는 모든 계층에 대하여 상대적으로 적용된다.
</br>

![image](https://user-images.githubusercontent.com/83942393/127648831-71c08054-3a7e-4df1-9dd8-2d7a5c7775ea.png)    
그림 1-4 OSI 7계층 모델   
</br>

### 1.2 OSI 7계층 모델의 계층별 기능
OSI 7계층 모델의 각 계층은 독립적인 고유 기능을 수행하며, 하위 계층이 바로 위 계층에 서비스를 제공하는 형식으로 동작한다.    
*여기서는 각 계층에서 제공하는 기능에 대하여 간단히 살펴보고 자세한 내용은 2장에서 설명한다.*    
</br>

> 물리 계층
* 네트워크에서 호스트들이 데이터를 전송하려면 반드시 전송 매체로 연결되어 있어야 한다.
* 물리 계층(Physical Layer)은 호스트를 전송 매체와 연결하기 위한 인터페이스 규칙과 전송 매체의 특성을 다룬다.
</br>

> 데이터 링크 계층
* 물리 계층으로 데이터를 전송하는 과정에서 잡음(Noise) 등과 같은 여러 외부 요인에 의하여 물리적인 오류가 발생할 수 있다.
* 데이터 링크 계층(Data Link Layer)은 물리적인 전송 오류를 감지(Sense)하는 기능을 제공해 송수신 호스트가 오류를 인지할 수 있도록 해준다.
* 대표적인 물리적 오류로는 데이터가 도착하지 못하는 데이터 분실과 내용이 깨져서 도착하는 데이터 변형이 있다.
* 일반적으로 컴퓨터 네트워크에서 오류 제어(Error Control)는 송신자가 원래의 데이터를 재전송(Retransmission)하는 방식으로 처리한다.
</br>

> 네트워크 계층
* 송신 호스트가 전송한 데이터가 수신 호스트까지 안전하게 도착하려면 여러 개의 중개 시스템을 거쳐야 한다.
* 이 과정에서 데이터가 올바른 경로를 선택할 수 있도록 지원하는 계층이 네트워크 계층(Network Layer)이다.
* 중개 시스템의 기능은 일반적으로 라우터(Router)가 수행한다.
* 네트워크 부하가 증가하면 특정 지역에 혼잡(Congestion)이 발생할 수 있는데, 혼잡 제어(Congestion Conrol)도 데이터의 전송 경로와 관계되므로 네트워크 계층이 담당한다.
</br>

> 전송 계층
* 컴퓨터 네트워크에서 데이터를 교환하는 최종 주체는 호스트 시스템이 아니고, 호스트 내부에서 실행되는 네트워크 프로세스이다.
* 전송 계층(Transport Layer)은 송신 프로세스와 수신 프로세스 간의 연결(Connection) 기능을 제공하기 때문에, 프로세스 사이의 안전한 데이터 전송을 지원한다.
* 전송 계층은 데이터가 전송되는 최종적인 경로상의 양 끝단 사이의 연결이 완성되는 곳이다.
* 일반적으로 계층 4까지의 기능은 운영체제에서 시스템 콜(System call) 형태로 상위 계층에 제공하며, 계층 5~7의 기능은 사용자 프로그램으로 작성된다.
</br>

> 세션 계층
* 세션 계층(Session Layer)은 전송 계층에서 제공하는 연결의 개념과 유사한 세션 연결을 지원하지만, 이보다는 더 상위의 논리적 연결이다.
* 즉, 응용 환경에서 사용자 간의 대화(Dialog) 개념의 연결로 사용되기 때문에 전송 계층의 연결과 구분된다.
</br>

> 표현 계층
* 표현 계층(Presentation Layer)은 전송되는 데이터의 의미(Semantic)를 잃지 않도록 올바르게 표현(Syntax)하는 방법을 다룬다.
* 즉 정보를 교환하는 시스템이 표준화된 방법으로 데이터를 인식할 수 있게 해준다.
* 또한 데이터의 표현이라는 본래의 기능에 더해, 현재의 표현 계층은 압축과 암호화라는 기능도 중요하게 다루고 있다.
* 동영상과 같은 대용량의 멀티미디어 데이터를 압축(Compression)하면 전송 데이터의 양을 줄일 수 있다.
* 암호화는 외부의 침입자로부터 데이터를 안전하게 보호하는 기능인데, 인터넷을 통한 개인 정보의 유통과 상거래가 증가하면서 중요성이 커지고 있다.
</br>

> 응용 계층
* 응용 계층(Application Layer)은 사용자를 위한 다양한 **네트워크 응용 환경** 을 지원한다.
* 그 기능은 특정 분야에 한정되지 않고 매우 광범위하다.
</br>

### 1.3 프로토콜과 인터페이스
네트워크 사용자가 통신한다는 것은 데이터를 서로 주고 받는다는 것을 의미한다.    
최종 사용자가 데이터를 보내고 받으려면 양쪽 호스트에서 실행되는 OSI 7 계층의 모듈이 **유기적으로 연동** 되어야 한다.        
즉, 호스트끼리 통신하는 과정에서는 각 계층의 모듈이 상대 호스트의 동일 계층과 개별적으로 논리적 통신을 수행해야 한다.        

예를 들어, 통신 양단의 한쪽 호스트의 계층 n 모듈은 상대 호스트의 계층 n 모듈과 통신한다.        
이와 같이 각각의 계층은 정해진 방식과 절차에 따라 상대 계층과 통신하는데, 이 과정에서 필요한 규칙을 프로토콜(Protocol)이라 한다.        

상하위의 계층 간에는 인터페이스(Interface)라는 규칙이 존재하고, 하위 계층이 상위 계층에 제공하는 인터페이스를 특별히 서비스(Service)라 부른다.        
그림은 서로 다른 호스트에 위치한 계층 모델에서 두 호스트의 통신을 지원하기 위한 모듈 간의 관계를 프로토콜, 인터페이스, 서비스의 관점에서 설명한다.      
</br>

![image](https://user-images.githubusercontent.com/83942393/127652376-2055d8a1-6125-40a5-8cba-b85abf1146ef.png)

* 호스트 1과 호스트 2의 계층 n 프로토콜이 서로 통신하려면, 계층 n-1 프로토콜의 도움이 필요하다.
* 즉, 호스트 1의 계층 n 이 호스트 2의 계층 n 에 데이터를 전송하는 과정은 계층 n-1을 통해 이루어진다.

1. 먼저, 호스트 1의 계층 n-1 에 전송할 데이터를 주어 호스트 2에 전송하도록 부탁한다.
2. 그러면 호스트 1의 계층 n-1은 다시 하위 계층의 도움을 받아 호스트 2의 계층 n-1에 데이터를 보낸다.
3. 마지막으로 호스트 2의 계층 n-1이 받은 데이터를 계층 n에 올려줌으로써 계층 n 사이의 통신이 완료된다.

* 이 원리는 7개 계층에 모두 적용되며, 상대 호스트에 물리적으로 데이터를 전송하는 것은 맨 아래의 물리 계층이다.
* 물리 계층에 위치한 계층 프로토콜들은 각자의 정해진 기능을 수행하면서 논리적인 통신을 하는 것이다.
</br>

### 1.4 인터넷 계층 구조
그림은 FTP 프로그램을 이용하는 경우를 예를 들어 계층 구조를 설명하고 있다.     
인터넷에서는 IP가 네트워크의 계층의 기능을 수행하며, TCP(Transmission Control Protocol) 와 UDP(User Datagram Protocol) 가 전송 계층의 기능을 수행한다.   
전송 계층 이하의 기능들은 호스트의 운영체제 내부에서 구현되며 FTP, 텔넷, 전자 메일 등과 같은 응용 프로그램은 사용자 프로그램 환경에서 계층 5~7 이 합쳐져 구현된다.    

<img src="https://user-images.githubusercontent.com/83942393/127653300-d10a2568-1a20-4380-a589-fb29a28d17e5.png" width="50%" height="50%"></img></br>

그림 1-6 FTP의 계층 구조

* 그림과 같이 양쪽 호스트에는 동일한 기능을 수행하는 프로토콜 스택(Stack)이 각각 존재한다.   
* 프로토콜 스택은 계층 구조로 이루어진 통신 프로토콜의 집합이다.   
* 그림에는 표시되지 않았지만 호스트 사이에는 중개 기능을 수행하는 라우터가 존재하며, 인터넷에서는 IP 프로토콜이 중개 기능을 수행하므로 라우터는 계층 3까지의 기능이 구현되어 있다.
</br>

* FTP 클라이언트가 FTP 서버에 데이터를 전송하려면 먼저 하위의 TCP 에 데이터를 보내야 한다.
* 하지만 TCP로 보내진 데이터는 IP 프로토콜과 LAN 카드를 거쳐서 FTP 서버가 위치하는 호스트의 LAN 카드에 전달된다.   
* 서버 호스트에 도착한 데이터는 송신 순서의 반대인 LAN 카드, IP 프로토콜, TCP 프로토콜을 거쳐서 FTP 서버 프로그램에 도착한다.   
</br>

### 2. 인터네트워킹
네트워크와 네트워크의 연결을 인터네트워킹(Internetworking)이라 하며, 연결되는 네트워크 수가 증가할수록 복잡도가 커진다.    
인터넷은 IP 프로토콜을 지원하는 전 세계의 모든 네트워크가 연결된 시스템을 의미하며, 라우터라는 중개 장비를 사용해서 네트워크들을 연결한다.   

### 2.1 네트워크의 연결
그림처럼 서로 **독립적으로 운영되는** 두 네트워크가 연동되어 정보를 교환하려면, 이를 적절히 연결하여 데이터를 중개할 수 있는 인터네트워킹 시스템이 필요하다.
여기에서 네트워크가 연동된다는 의미는 물리적인 연결뿐 아니라, 데이터 중개에 필요한 상위의 통신 프로토콜이 모두 지원됨을 뜻한다.

![image](https://user-images.githubusercontent.com/83942393/127727785-ed708dc8-f26e-45ad-8af5-bd0a818c1283.png)</br>

인터네트워킹 시스템으로 연결된 두 네트워크는 물리적으로 같은 종류일 필요가 없으며, 상위 계층 프로토콜들이 지원하는 논리적 기능도 다를 수 있다.    
하지만 인터네트워킹 시스템은 양쪽 네트워크에 대하여 물리적이고 논리적인 인터페이스를 모두 지원해야 한다.

즉, 그림에서 인터네트워킹 시스템의 왼쪽은 네트워크 1과 연동할 수 있고, 오른쪽은 네트워크 2와 연동할 수 있어야 한다.    
또한 이 과정에서 데이터 표현 방식을 포함해 양쪽 네트워크의 프로토콜이 서로 일치하지 않으면 필요한 변환 작업을 수행해야 한다.   
이러한 방식으로 인터네트워킹 시스템은 둘 이상의 네트워크를 유기적으로 연동할 수 있다.    
</br>

### 2.2 게이트웨이
인터네트워킹 기능을 수행하는 시스템을 일반적으로 게이트웨이(Gateway)라 부른다.   
<img src="https://user-images.githubusercontent.com/83942393/127727830-1a64d6b5-0504-4136-973f-80800333ce2c.png" width="45%" height="45%"></img></br>
게이트웨이는 기능에 따라 종류가 다양하지만 리피터, 브리지, 라우터 등이 가장 일반적인 구분 방식이다.   
</br>

> 리피터(Repeater) 
```
두 네트워크의 거리만 멀고 오류 발생 가능성도 없고 교환기능도 필요 없다면 사용 (공유버스, 링(브로드캐스팅) 방식)
```
* 물리 계층을 지원한다.
* 물리적 신호는 전송 거리가 멀수록 감쇄되기 때문에 중간에 이를 보완해주어야 한다.
* 따라서 리피터는 한쪽에서 입력된 신호를 물리적으로 단순히 증폭하여 다른 쪽으로 중개하는 역할을 한다.
</br>

> 브리지(Bridge)
```
두 네트워크의 거리가 멀고 오류발생 가능성은 있지만 교환은 필요 없을시 사용
```
* 리피터 기능에 데이터 링크 계층의 기능이 추가된 것으로 물리 계층에서 발생한 오류를 해결해준다.
</br>

> 라우터(Router)
```
두 네트워크의 거리도 멀고 오류 발생 가능성도 있으며 교환이 필요할 때 사용
```
* 물리 계층, 데이터 링크 계층, 네트워크 계층의 기능을 지원한다.
* 네트워크 계층은 경로 선택 기능을 제공해야 하므로 임의의 네트워크에서 들어온 데이터를 어느 네트워크로 전달할지 판단할 수 있어야 한다.
* 이를 위하여 라우터는 자신과 연결된 네트워크와 호스트들의 정보를 유지, 관리함으로써 특정 경로가 이용 가능한지 여부와 다수의 경로 중에서 어느 경로가 빠른 데이터 전송을 지원하는지 판단할 수 있어야 한다.
* 네트워크와 호스트에 대한 정보는 일반적으로 라우팅 테이블(Routing Tabel)에 보관된다.
</br>

### 3. 프로토콜
프로토콜은 통신 시스템이 데이터를 교환하기 위해 사용하는 통신 규칙이다.   
OSI 7 계층 모델에서는 각 계층에서 수행하는 프로토콜이 서로 독립적이라고 간주한다.   
따라서 계층 1에는 계층 1끼리 통신할 수 있는 프로토콜이 존재하고, 계층 2에는 계층 2끼리 통신할 수 있는 프로토콜이 존재한다.   

### 3.1 프로토콜의 예
그림은 일반인이 휴대폰으로 통화하는 규칙을 보여주고 있는데, 이러한 순서와 절차를 프로토콜이라 정의할 수 있다.   

시간은 위에서 아래로 흐르고, 왼쪽의 발신자가 오른쪽의 수신자에게 통화를 시도하고 있다.   
연결을 설정할 때는 항상 발신자의 요청에 의하여 시작되며, 수신자는 미리 연결 대기 상태에 있어야 한다.   
연결 설정은 상호 간의 합의 아래 이루어지지만, 종료는 한쪽의 일방적인 종결 선언으로도 가능하다.   

<img src="https://user-images.githubusercontent.com/83942393/127728110-594f77a6-b070-4ba3-90e0-beeee19bd853.png" width="60%" height="60%"></img></br>

*이런식으로 연결을 하겠다고 미리 정해놓은 규칙*   

1. 수신자는 휴대폰 전원을 켜서 발신자의 통화 요청보다 먼저 대기 상태에 있어야 한다.   
2. 발신자가 수신자의 전화번호를 누르면(또는 번호를 입력한 후 <통화> 버튼을 누르면   
3. 수신자 휴대폰의 핸드폰 벨이 울린다.
4. 수신자가 <통화> 버튼을 눌러 전화를 받으면 연결이 설정된다(수신자가 벨 소리를 무시하고 전화를 받지 않으면 연결되지 않으므로 연결 설정은 반드시 양자의 합의가 있어야 한다. )

5. 일단 연결이 설정되면 연결이 해제되기 전까지 데이터를 주고 받을 수 있다.
6. 연결 헤제는 외형상 한쪽의 일방적인 종료로 이루어지지만   
실제로는 대화 과정에서 쌍방의 합의로 이루어진다.   

이러한 상황은 컴퓨터에도 비슷하게 적용된다.   
</br>

### 3.2 데이터 단위
**네트워크 프로토콜을 사용해 데이터를 교환할 때는, 먼저 데이터를 특정 형태로 규격화하는 것이 필요하다.**   

예를 들어, 우편물을 보낼 때 정해진 규격 봉투를 사용하는 것과 같은 원리이다.</br>
규격 봉투에 보내는 사람 주소, 받는 사람 주소 등을 규칙에 따라 기입하는 것처럼 네트워크에서도 데이터를 프로토콜에 맞춰 묶어주어야 한다.</br>

OSI 7계층 모델의 각 계층에서 규격화된 데이터는 표와 같이 공유 명칭이 있다.   
계층에 상관없이 사용할 때는 통칭하여 **PDU(Protocol Data Unit)** 라 부른다.  

표 1-1 OSI 7계층 모델의 계층별 데이터 단위
| 데이터 단위 | 설명 |
|:----------|:----------|
| APDU</br>(Application Protocol Data Unit) | 응용 계층에서 사용한다. |
| PPDU</br>(Presentation Protocol Data Unit) | 표현 계층에서 사용한다. |
| SPDU</br>(Session Protocol Data Unit) | 세션 계층에서 사용한다. |
| TPDU</br>(Transport Data Unit) | 전송 계층에서 사용한다. </br> 인터넷에서 사용하는 전송 계층 프로토콜인 TCP 에서는 세그먼트(Segment)라 부르고, UDP 에서는 데이터그램(Datagram)이라 부른다. </br> 데이터그램은 일반적인 상황에서 계층 4 프로토콜의 전송 데이터를 가리킬 때도 사용한다. |
| NPDU</br>(Network Protocol Data Unit) | 네트워크 계층에서 사용하며, 보통 패킷(Packet)이라 부른다. </br> 패킷은 원래 네트워크 계층의 IP 프로토콜에서 유래했지만, 요즘은 네트워크 계층의 전송 데이터를 의미한다. |
| DPDU</br>(Data Link Protocol Data Unit) | 데이터 링크 계층에서 사용하며, 보통 프레임(Frame)이라 부른다. |
</br>

### 💎 03 네트워크 주소의 표현
시스템을 설계할 때는 기능이나 목적과 함께 고유의 구분자(Identifier)를 부여하는 방법에 대해서도 먼저 고려해야 한다.   
디지털화된 컴퓨터에는 구분자를 숫자로 된 주소로 표현할 수 밖에 없다.   
그러나 이러한 주소 표현 방식은 일반 사용자에게 불편하므로, 보통은 외우기 쉬운 기호 형식의 이름을 추가로 사용한다.   
주소와 이름은 일대일(1:1) 관계가 이루어지며, 이들을 연결하는 기능이 필요하다.   
대상을 유일하게 구분하는 구분자는 일반적으로 다음의 네 가지 특징이 있다.   
</br>

> 유일성
* 구분자의 가장 중요한 역할은 대상 시스템을 서로 구분하여 지칭하는 것이다.   
* 따라서 서로 다른 시스템이 같은 구분자를 갖지 않는 유일성을 보장해야 한다.   
</br>

> 확장성
* 시스템은 시간이 흐르면서 이용자가 증가하는 보편화 과정이 진행되므로, 자연스럽게 규모가 확장된다.   
* 따라서 사용하는 구분자의 양도 증가된다.    
* 시스템의 최대 수용 규모를 예측하여, 구분자의 최대 한계를 올바르게 설정하지 않으면, 표현할 수 있는 공간의 크기가 제한되어 시스템의 확장성도 제한받게 된다.   
</br>

> 편리성
* 시스템 설계 과정에서 부여되는 구분자는 시스템의 내부 처리 구조를 효율적으로 운용할 수 있도록 해주어야 한다.   
* 컴퓨터 시스템은 내부적으로 숫자에 기반해 처리되기 때문에 구분자의 체계도 숫자 위주이다.    
* 또한 배치, 검색 등을 원활하게 수행하기 위해 보통 일반인이 의미를 이해할 수 없는 형식을 갖는다.   
* 이처럼 시스템 내부 동작에 종속된 구분자의 주소 체계는 사용자가 이해하기 어려우므로 기호로 된 이름을 추가로 부여한다.    
* 따라서 숫자로 된 주소와 문자로 된 이름을 모두 가지므로, 이를 매핑(Mapping) 하는 기능이 필요하다.   
</br>

> 정보 함축
* 구분자는 응용 환경에 필요한 다양한 정보를 포함하는 경우가 많다.   
* 예를 들어, 주민번호는 생년월일, 성별 등을 알 수 있는 숫자로 구성되어 있다.   
* 집 주소도 광역시부터 시작해 지역을 소규모로 분할하는 구조로 되어 있어 집의 지리적인 위치를 쉽게 가늠할 수 있다.   
* 이처럼 구분자는 응용 환경에 적절히 대응할 수 있는 정보를 포함해야 한다.   
</br>

### 1. 주소와 이름 
시스템을 지칭하는 구분자는 내부에서 처리되는 숫자 기반의 **주소(Address)** 와 함께 사용자의 이해와 편리성을 도모하는 기호로 된 **이름(Name)** 을 제공해야 한다.   
일반 사용자는 내부 주소를 몰라도 이름만으로 시스템에 접근할 수 있어야 하며, 이름과 주소를 연결하는 방법은 시스템 내부적으로 처리되어야 한다.    

네트워크의 규모가 크지 않아서 관리하는 시스템의 개수가 적은 경우에는 간단한 형식의 주소와 이름을 사용할 수 있으므로 이를 관리하는 시스템도 크게 복잡하지 않다.   
그러나 관리 대상이 많아지면 주소와 이름의 공간이 커지고, 이를 관리하는 시스템의 기능도 복잡해진다.   

네트워크에는 여러 종류의 주소와 이름이 존재한다.   
이는 각 계층의 기능을 담당하는 프로토콜마다 주소를 독립적으로 관리하기 때문이다.   
예를 들어, IP 프로토콜은 호스트를 구분하기 위하여 IP 주소를 사용하며, 데이터 링크 계층에서는 LAN 카드별로 MAC 주소를 따로 부여한다.   
전송 계층을 수행하는 TCP 에서는 호스트에서 수행되는 네트워크 프로세스마다 별도의 포트(Port) 주소를 할당하고 관리한다.   
</br>

### 1.1 IP 주소 (IP Address)
* 네트워크 계층의 기능을 수행하는 IP 프로토콜이 호스트를 구분하기 위하여 사용하는 주소 체계이다.
* 임의의 호스트를 인터넷에 연결하려면 반드시 IP 주소를 할당받아야 한다.
* IP 주소는 32비트의 이진 숫자로 구성되는데, 보통 8비트씩 네 부분으로 나누어 십진수로 표현한다.
</br>

* 그림을 살펴보자. 32비트의 이진수 11001011 00000000 01110001 00101011 은 일반 사용자가 외우기 쉽지 않다.
* 따라서 이를 네 개의 십진수로 변환한 후 각각을 점(.)으로 구분한 203.0.113.43 으로 표기한다.

<img src="https://user-images.githubusercontent.com/83942393/127729570-69f6f5d3-d6ad-4f69-9c6c-72b93c7ad209.png" width="50%" height="50%"></img></br>
</br>

* IP 주소는 유일성을 보장하기 위해 국제 표준화 기구가 전체 주소를 관리하고 할당하기 때문에, 중복 주소의 사용을 원천적으로 차단한다.
* IP 프로토콜이 처음 개발될 당시에는 현재처럼 폭넓게 활용되리라 예측하지 못했다.
* 따라서 IP 주소로 표현할 수 있는 최대 주소 공간의 크기를 32비트로 제한함으로써 확장성에 많은 문제점이 야기되고 있다.
* 이를 해결하기 위하여 새로운 프로토콜인 **IPv6(Internet Protocol Version 6)** 에서는 주소 표현 공간을 **128비트** 로 확장했다.
* 그리고 현재의 IP 프로토콜은 IPv4로 표현한다.(IPv6와 구분하기 위해)
</br>

* IP주소는 임의로 할당되는 것이 아니라, 특정 규칙에 따라 인접한 숫자를 그룹으로 묶어 관리한다.
* 따라서 IP주소는 경로를 선택할 때 중요한 기준이 된다.
* 그림에서 네트워크 1에는 IP주소가 211.233.201로 시작하는 호스트들이 있고, 네트워크 2에는 211.233.202로 시작하는 호스트들이 있다.
* 왼쪽의 인터넷에서 임의의 호스트가 보낸 패킷이 중간의 라우터에 도착할 경우, 이 패킷의 목적지 주소가 211.233.201.30 이라면 당연히 **네트워크 1**로 중개해야 한다.
* 이처럼 인터넷에서 IP 주소는 패킷의 경로를 결정하는데 중요한 역할을 한다.

<img src="https://user-images.githubusercontent.com/83942393/127729908-a8084557-aa73-4ace-a618-1ef4d03acef2.png" width="60%" height="60%"></img></br>
</br>

### 1.2 호스트의 이름
인터넷에서 특정 호스트와 연결하려면 반드시 해당 호스트의 IP 주소를 알아야 한다. 그런데 숫자로 된 IP 주소는 기억하기 힘들다.    
그래서 의미 파악이 쉬운 문자로 된 호스트의 이름을 사용하는 것이 일반적이다.    

그림은 일반 사용자가 문자로 된 호스트 이름을 사용하였을 때, **IP 주소로 변환되는 과정** 을 보여준다.   
맨 밑에 있는 네트워크 계층의 IP 프로토콜은 호스트를 구분하는 용도로 IP 주소만을 사용한다.    
그에 비해 일반 사용자는 IP 주소보다는 문자로 된 호스트 이름을 사용하기 때문에 중간 계층에서 이를 변환하는 기능을 수행해야 한다.   
```
일반적으로 FTP, 텔넷과 같은 네트워크 응용 프로그램은 실행 과정에서 사용자로부터 호스트 이름을 명령어 인수로 입력받는다.
```
</br>

따라서 가장 먼저 수행할 작업은 DNS(Domain Name System)라는 이름과 주소 변환 기능을 이용해서 IP 주소를 얻는 것이다.   
</br>

<img src="https://user-images.githubusercontent.com/83942393/127730141-2a3f575c-250a-45a0-b1d0-d1101d35a42f.png" width="50%" height="50%"></img></br>
</br>

```
<호스트 이름>.<단체 이름>.<단체 종류>.<국가 도메인>
``` 
* DNS 시스템은 호스트 이름을 국가 도메인, 단체 종류, 단체 이름, 호스트라는 네 계층 구조로 나누고, 이들을 점(.)으로 구분해서 표기한다.
* 예를 들어, zebra.korea.co.kr 과 같은 호스트 이름은 대한민국(kr)에 있는 일반 회사(co) 중에서 korea 라는 이름의 회사에 소속된 zebra라는 호스트를 의미한다.  
</br>

* 국가 도메인은 호스트가 위치한 국가의 이름을 두 글자의 약자로 표시한다.    
* 표 1-2처럼 나라마다 고유한 국가 도메인이 존재한다.      
* 단체 종류는 기관의 성격에 따라 부여하며, 사용 예는 표 1-3과 같다.    
* 단체 이름은 보통 단체를 상징하는 이름을 사용한다. 예를 들어, 회사는 회사명을, 학교는 학교 이름을 사용한다.   
* 마지막으로 호스트는 소속 단체의 네트워크 관리자가 내부 규칙에 따라 개별 호스트에 부여한 이름을 사용한다.    
</br>

표 1-2 국가 도메인        
| 국가 도메인 | 해당 국가명 |
|:----------|:----------|
| kr | 한국 |
| jp | 일본 |
| us | 미국 |
</br>

표 1-3 단체 종류
| 단체 종류 | 기관 성격 |
|:----------|:----------|
| co(company) | 회사 |
| ac(academy) | 교육기관 |
| go(goverment) | 정부 소속 기관 |
</br>

### 2. 주소 정보의 관리 
일반 사용자가 호스트를 지칭할 때 사용하는 호스트 이름을 **도메인 이름(Domain Name)** 이라 하며, 인터넷에서는 이를 IP 주소로 변환하는 작업이 필요하다.   
초기 인터넷에서는 아주 간단한 방법으로 호스트 이름과 IP 주소를 변환하였으나, 지금은 **DNS** 라는 **분산 데이터베이스 시스템** 을 사용해서 보다 체계적인 방법으로 관리하고 있다.   

### 2.1 호스트 파일
* 호스트 이름과 IP 주소를 변환하는 **간단한 방법** 은 특정 파일(ex) UNIX 시스템의 /etc/hosts) 에 호스트 이름과 IP 주소의 조합을 기록 · 관리하는 것이다.    
* 네트워크 응용 프로그램에서는 사용자가 입력한 호스트 이름을 이 파일에서 검색하여 일대일로 대응된 IP 주소 정보를 쉽게 얻을 수 있다.   
* 호스트 파일은 한 줄에 하나의 호스트 정보가 기록되며, 일반 텍스트 문서 형식으로 보관된다.   
* 즉, 그림을 예로 들면, 호스트 이름이 white.korea.co.kr 인 시스템의 IP 주소는 211.223.201.27 이다.   
</br>

* 네트워크 관리자는 관리 대상이 되는 모든 컴퓨터의 호스트 정보를 주기적으로 갱신하고, 이 정보를 네트워크에 있는 모든 컴퓨터가 복사하도록 함으로써 정보의 일관성을 유지해야 한다.   
* 그림은 네트워크 관리자가 white.korea.co.kr 에서 호스트 정보를 갱신할 때, 갱신 정보를 다른 네 개의 호스트가 복사하여 저장하는 모습을 보여준다.   
* 호스트 파일을 갱신하고 복사하는 작업은 보통 시스템 관리자가 수작업으로 한다.   
</br>

<img src="https://user-images.githubusercontent.com/83942393/127731210-6415458e-e8a3-4419-b052-a14199df7ad4.png" width="60%" height="60%"></img></br>

* 호스트가 추가되거나 삭제되면, 먼저 네트워크 관리자의 호스트에서 갱신 작업이 이루어진다.
* 그런데 호스트 파일 갱신은 생각보다 자주 발생하지 않기 때문에 호스트 파일을 복사하는 작업도 흔하지는 않다.
* 또한 시스템 관리자가 잦은 변경을 원하지 않아서 급하지 않은 갱신은 부분적으로 늦추기도 한다.
</br>

### 2.2 DNS
호스트 파일로 주소와 이름 정보를 관리하는 것은 간단한 반면 대부분 수동으로 작업해야 한다는 단점이 있다.   
따라서 호스트 수가 증가할수록 네트워크 관리자가 호스트 파일을 갱신하고 복사하는 작업에 많은 시간과 노력을 들여야 한다.   
특히, 인터넷처럼 전 세계 컴퓨터가 연결된 네트워크 환경에서는 호스트 파일에 의한 주소와 이름의 변환 작업이 사실상 불가능하다고 볼 수 있다.   

이러한 문제점을 해결하기 위하여 고안된 DNS는 주소와 이름 정보를 자동으로 유지하고 관리하는 분산 데이터베이스 시스템이다.   
호스트 주소와 이름 정보는 네임 서버(Name Server)라는 특정한 관리 호스트가 유지하고, 주소 변환 작업이 필요한 클라이언트는 네임 서버에 요청해서 IP 주소를 얻는다.   

네트워크가 커지면, 네임 서버에 보관되는 정보의 양도 자연스럽게 많아진다.    
DNS는 하나의 집중화된 네임 서버가 전체 호스트의 정보를 관리하지 않고, 여러 네임 서버에 분산하여 관리하도록 설계되었다.   
계층 구조로 연결된 네임 서버는 자신이 관리하는 영역에 위치한 호스트 정보만 관리하며, 정보를 상호 교환하는 협력 관계를 통해서 전체 호스트 정보를 일관성 있게 유지한다.   
</br>
   
### 2.3 기타 주소
네트워크에서 사용하는 주소는 이를 사용하는 응용 프로그램에 따라 다양하다.   
OSI 7계층 모델의 각 계층에서도 각 목적에 따라 여러 형태의 주소가 사용된다.   
인터넷에서 일반 사용자가 접근할 수 있는 대표적인 주소는 다음과 같다.   
</br>

> MAC 주소
* MAC 주소는 계층 2의 MAC(Medium Access Protocol) 계층에서 사용하며, 일반적으로 LAN 카드에 내장되어 있다.
* 물리 계층을 통해 데이터를 전송할 때는 MAC 주소를 이용해서 호스트를 구분한다.
* 따라서 네트워크 계층에서 데이터 링크 계층으로 데이터를 전송할 때는 먼저 IP 주소를 MAC 주소로 변환해야 한다.
</br>

> IP 주소
* IP 주소는 네트워크 계층의 기능을 수행하는 IP 프로토콜에서 사용되며, IP 패킷이 지나가는 경로를 결정하는 라우팅의 기준이 된다.
</br>

> 포트 주소(Port Address)
* 전송 계층에서 사용하며, 호스트에서 실행되는 프로세스를 구분해준다.
* TCP 와 UDP 가 독립적으로 포트 주소를 관리하며, 포트 번호 또는 소켓 주소라는 용어를 사용하기도 한다.
</br>

> 메일 주소
* 메일 주소는 응용 계층의 메일 시스템에서 사용자를 구분하려고 사용한다.
* hong@korea.co.kr 처럼 사용자 이름과 호스트 이름을 @ 문자로 구분해 표기한다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/127731526-28b4334d-04f1-4490-a66b-7a58eb27c428.png" width="60%" height="60%"></img></br>
</br>

---
</br>

<img src="https://user-images.githubusercontent.com/83942393/127731812-94b9c231-b6bd-49a1-9504-f8d28d4f9119.png" width="60%" height="60%"></img></br>
<img src="https://user-images.githubusercontent.com/83942393/127731816-829789c2-9106-40c4-ab67-2ea6abe77230.png" width="60%" height="60%"></img></br>





