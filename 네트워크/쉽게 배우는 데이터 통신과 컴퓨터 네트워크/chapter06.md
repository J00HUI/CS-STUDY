### 🔆 Preview
데이터 링크 계층은 물리적으로 이웃하여 연결된 두 호스트 간의 신뢰성 있는 데이터 전송을 지원한다.   
이를 위해서는 물리 계층에서 발생하는 전송 오류를 감지하고, 복구하는 기능이 필요하다.   

데이터 링크 계층은 오류 복구 기능을 수행하여 상위 계층인 네트워크 계층에 전송 오류가 발생하지 않는 논리적인 전송 선로를 보장한다.   
오류 복구 기능을 제공하려면 일차적으로 물리 매체를 이용한 전송 과정에서 오류가 발생할 수 있는지 감지할 수 있어야 한다.   
오류를 감지하면 송수신 호스트 사이의 오류 복구 과정이 이루어져야 하는데, 컴퓨터 네트워크에서는 주로 재전송 기법을 사용한다.   

프로토콜은 네트워크에서 데이터 전송 기능을 수행한다.   
따라서 프로토콜을 이해하면, 인터넷 환경에서 데이터 전송이 어떤 원리에 의해 이루어지는지 파악할 수 있다.   
특히 프레임, 오류 제어, 흐름 제어의 기능에 대해 이해함으로써 데이터가 안전하게 전송되는 원리를 파악할 수 있다.   

6장에서는 네트워크에서 데이터 전송 기능을 지원하는 프로토콜의 기본 원리에 대하여 학습한다.   
프레임의 오류 제어, 흐름 제어에 대해 살펴보고, 슬라이딩 윈도우 프로토콜의 동작 방식에 대하여 알아본다.    
이어서 실제 구현된 프로토콜인 HDLC을 이용하여 이론과 실제가 어떻게 연결되는지 확인한다.   
</br>

### 💎 01 데이터 링크 계층 프로토콜의 기초
데이터 링크 계층에서 두 호스트가 통신하려면 그림의 (a)처럼 일대일(1:1) 형식의 점대점 방식으로 연결해야 한다.     
송신 호스트에서 전송한 프레임은 점대점으로 직접 연결된 수신 호스트에 라우팅 과정 없이 전달된다.   
기본적으로 데이터 링크 계층 프로토콜은 (a)와 같은 직접 연결 구조에서 둘 사이의 전송 오류를 감지하고, 이를 복구하는 기능을 지원한다.   
(b) 의 구조를 지원하려면 호스트 주소 개념이 추가로 필요하다.   

<img src="https://user-images.githubusercontent.com/83942393/129845838-8911ed63-4fbf-40c3-b3ca-a11dd9448d66.png" width="50%" height="50%"></img></br>

그림 (b)에서 하나의 호스트가 다수의 호스트와 연결된 **비대칭** 형태로, 이러한 구조를 **멀티 드롭** (Multi-Drop) 방식이라 한다.   
멀티 드롭에서는 하나의 물리 매체를 여러 호스트가 공유하므로, 임의의 호스트에서 전송한 프레임은 물리적으로 다른 모든 호스트에 전달된다.   

(a)에서는 전송 선로에 두 개의 호스트만 연결되므로, 호스트를 구분하기 위한 주소 개념이 필요 없다.   
그러나, (b)에서는 여러 수신 호스트 중에서 프레임의 목적지 호스트를 지칭하기 위한 주소 개념이 필요하다.   
</br>

### 1. 프레임의 종류
데이터 링크 계층의 동작 원리를 이해하려면 프로토콜에서 자주 언급되는 프레임을 먼저 이해해야 한다.   
데이터 링크 계층에서 전송 오류를 해결하는 과정에서 사용하는 프레임에는 정보 프레임, 긍정 응답 프레임, 부정 응답 프레임이 있다.   
</br>

> 정보 프레임(Information Frame)
* 상위 계층이 전송을 요구한 데이터를 수신 호스트에 전송하는 용도로 사용한다.
* 약칭하여 I 프레임으로도 표기하며, 상위 계층에서 보낸 데이터와 함께 **프레임의 순서 번호, 송수신 호스트의 주소 정보** 를 포함한다.
```
순서 번호는 각 정보 프레임에 부여되는 고유의 일련번호로, 수신 호스트가 중복 프레임을 구분할 수 있도록 해준다.
```
</br>

> 긍정 응답 프레임(Positive Acknowledgement Frame)
* 정보 프레임을 수신한 수신 호스트는 맨 먼저 프레임의 내용이 깨졌는지 확인해야 한다.
* 프레임 변형 오류가 발생하지 않으면, 송신 호스트에 해당 프레임을 올바르게 수신했다는 의미로 **ACK 프레임** , 즉, 긍정 응답(Positive Acknowledgement)을 회신한다.
* 긍정 응답 프레임을 수신한 송신 호스트는 데이터가 제대로 도착했음을 확인할 수 있다.
</br>

> 부정 응답 프레임(Negative Acknowledgement Frame)
* 정보 프레임의 전송 과정에서 프레임 변형 오류가 발생하면, 수신 호스트는 송신 호스트에 **NAK 프레임** 을 회신한다. 즉, 부정 응답(Negative Acknowledgement)을 전달하여 송신 호스트가 오류 발생을 인지하고 원래의 정보 프레임을 재전송하도록 요청하는 것이다.
* 재전송 요구를 받은 송신 호스트는 오류가 발생한 프레임을 동일한 순서 번호로 다시 전송해야 한다.

정보 프레임뿐 아니라, 긍정 응답, 부정 응답 프레임에도 회산하고자 하는 정보 프레임의 순서 번호가 포함된다.   
따라서 정보 프레임의 송신 호스트는 몇 번 프레임이 제대로 도착하고, 몇 번 프레임에서 오류가 발생했는지를 응답 프레임의 순서 번호로 판단할 수 있다.    

이 세 가지 프레임을 사용해 데이터 링크 계층의 전송 프로토콜을 작성할 수 있다.   
프로토콜의 설계 과정에서 다루는 내용은 주로 **오류 제어, 흐름 제어, 양방향·단방향 전송 방식** 등이다.  
일반 통신 환경에서 세 가지 기능을 순차적으로 적용하면서 통신 프로토콜이 어떻게 설계되는지 살펴보자. 
</br>

### 2. 오류·흐름 제어가 없는 프로토콜
먼저, 전송 프로토콜의 구조를 가장 단순하게 하기 위해, 통신 환경을 다음과 같이 정의한다.

- 매우 이상적인 경우를 가정한 것으로, 데이터 전송 과정에서 어떠한 오류도 발생하지 않기 때문에, 오류 제어 기능이 필요 없다.
- 수신 호스트의 버퍼 용량에 제한이 없으므로, 송수신 호스트 사이의 속도 차이로 인해 프레임을 분실할 염려가 없어 흐름 제어 기능도 필요 없다.
</br>

* **단방향 통신** : 데이터는 송신 호스트에서 수신 호스트로만 (한쪽 방향으로만) 전달된다.
* **전송 오류가 없는 물리 매체** : 통신 채널에서는 어떠한 형태의 전송 오류도 발생하지 않는다.
* **무한 개의 수신 버퍼** : 수신 호스트의 버퍼 수는 무한하다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/129848067-3a80b833-7031-4d39-ada0-bb9051de8a1f.png" width="50%" height="50%"></img></br>

송신 호스트가 전송한 프레임은 수신 호스트에 항상 안전하게 도착하므로, 송신 호스트가 프레임을 원하는 만큼 계속 전송할 수 있으며, 구조가 단순하다.   
송신 호스트는 수신 호스트로부터 전송 프레임에 대한 응답을 받지 않아도 되므로, 단순히 정보 프레임을 전송하는 것만으로 송신 호스트의 역할은 완료된다.   

흐름 제어 측면에서는, 수신 호스트의 버퍼 크기가 무한하므로, 분실 오류를 걱정할 필요가 없다.   
따라서 송수신 호스트 사이의 흐름 제어 기능이 필요 없어 상위 계층이 요청한 데이터를 수신 호스트에 송신하는 과정만 필요하다.   

```
그림에서 I(i) 형태로 표시한 내용은 순서 번호가 i인 정보 프레임을 의미하는데,
이것은 이해를 돕기 위한 것이지 순서 번호가 필요하다는 뜻이 아니다.

수신 호스트 입장에서는 프레임이 항상 오류 없이 도착하므로, 송신 호스트에 별도의 응답 프레임을 전송할 필요가 없다.
또한 프레임이 중복해서 도착할 염려도 없으므로 순서 번호로 프레임을 구분하는 기능도 필요 없다.

그림에서는 전송되는 각 프레임이 다르다는 의미에서 표기했을 뿐이며, 순서 번호를 생략해도 프로토콜의 동작에는 영향을 주지 않는다.
```
</br>
수신 호스트는 도착한 프레임을 상위 계층에 전달하는 작업을 통해 수신 작업을 완료할 수 있다.   
</br>
### 3. 오류 제어가 없는 프로토콜
두 번째 가정은, 수신 호스트의 버퍼 개수가 유한하다.   
버퍼 개수가 제한되면, 송신 호스트가 전송한 정보 프레임의 수신 작업이 늦어질 때, 버퍼에 일시적으로 보관할 수 있는 프레임의 개수가 제한된다.   
따라서 버퍼 용량 부족으로 프레임 분실 오류가 발생할 가능성이 있으므로, 송수신 호스트 사이의 흐름 제어 기능이 필요하다.   

* **단방향 통신** : 데이터는 송신 호스트에서 수신 호스트로만(한쪽 방향으로만) 전달된다.
* **전송 오류가 없는 물리 매체** : 통신 채널에서는 어떠한 형태의 전송 오류도 발생하지 않는다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/129849465-4806d740-caab-448d-8ee2-ad52b01c700c.png" width="40%" height="40%"></img></br>
</br>

흐름 제어는 주로 수신 호스트가 송신 호스트의 프레임 전송 시점을 제어하는 형태로 이루어진다.   
가장 간단한 형태는 그림과 같이, 수신 호스트가 이전 프레임의 수신을 완료한 후에 다음 프레임을 전송하도록 송신 호스트에 지시하는 것이다.   
이때 사용하는 프레임이 그림에 표시된 **ACK 프레임** 이다.   

결과적으로 ACK 프레임은 송신 호스트에 이전 프레임을 잘 받았다는 긍정 응답의 기능을 수행하는 동시에,   
다음 프레임을 전송하도록 지시하는 흐름 제어 기능도 수행한다.   

```
위의 프레임 분실 오류가 없는 간단한 흐름 제어 환경에서는 중복 프레임이 발생할 가능성이 없기 때문에 순서 번호를 사용하지 않아도 된다.    
```
</br>

> **정지 대기 프로토콜**
* 송신 호스트가 정보 프레임을 전송하고, 이어서 다음 정보 프레임을 전송하려면 ACK 프레임이 도착하기를 기다려야 한다.   
* 이처럼 각 정보 프레임(크기 1)에 대하여 수신 호스트가 회신하는 ACK 프레임이 도착해야 다음 프레임을 전송할 수 있는 프로토콜 방식을 정지-대기(Stop-and-Wait) 방식이라 한다.   
* 정지-대기 프로토콜은 전송 효율이 매우 떨어지므로, 일반 네트워크 환경에서는 사용하지 않느다.   
</br>

### 4. 단방향 프로토콜








