### 🔆 Preview
데이터 링크 계층은 물리적으로 이웃하여 연결된 두 호스트 간의 신뢰성 있는 데이터 전송을 지원한다.   
이를 위해서는 물리 계층에서 발생하는 전송 오류를 감지하고, 복구하는 기능이 필요하다.   

데이터 링크 계층은 오류 복구 기능을 수행하여 상위 계층인 네트워크 계층에 전송 오류가 발생하지 않는 논리적인 전송 선로를 보장한다.   
오류 복구 기능을 제공하려면 일차적으로 물리 매체를 이용한 전송 과정에서 오류가 발생할 수 있는지 감지할 수 있어야 한다.   
오류를 감지하면 송수신 호스트 사이의 오류 복구 과정이 이루어져야 하는데, 컴퓨터 네트워크에서는 주로 재전송 기법을 사용한다.   

프로토콜은 네트워크에서 데이터 전송 기능을 수행한다.   
따라서 프로토콜을 이해하면, 인터넷 환경에서 데이터 전송이 어떤 원리에 의해 이루어지는지 파악할 수 있다.   
특히 프레임, 오류 제어, 흐름 제어의 기능에 대해 이해함으로써 데이터가 안전하게 전송되는 원리를 파악할 수 있다.   

6장에서는 네트워크에서 데이터 전송 기능을 지원하는 프로토콜의 기본 원리에 대하여 학습한다.   
프레임의 오류 제어, 흐름 제어에 대해 살펴보고, 슬라이딩 윈도우 프로토콜의 동작 방식에 대하여 알아본다.    
이어서 실제 구현된 프로토콜인 HDLC을 이용하여 이론과 실제가 어떻게 연결되는지 확인한다.   
</br>

## 💎 01 데이터 링크 계층 프로토콜의 기초
데이터 링크 계층에서 두 호스트가 통신하려면 그림의 (a)처럼 일대일(1:1) 형식의 점대점 방식으로 연결해야 한다.     
송신 호스트에서 전송한 프레임은 점대점으로 직접 연결된 수신 호스트에 라우팅 과정 없이 전달된다.   
기본적으로 데이터 링크 계층 프로토콜은 (a)와 같은 직접 연결 구조에서 둘 사이의 전송 오류를 감지하고, 이를 복구하는 기능을 지원한다.   
(b) 의 구조를 지원하려면 호스트 주소 개념이 추가로 필요하다.   

<img src="https://user-images.githubusercontent.com/83942393/129845838-8911ed63-4fbf-40c3-b3ca-a11dd9448d66.png" width="50%" height="50%"></img></br>

그림 (b)에서 하나의 호스트가 다수의 호스트와 연결된 **비대칭** 형태로, 이러한 구조를 **멀티 드롭** (Multi-Drop) 방식이라 한다.   
멀티 드롭에서는 하나의 물리 매체를 여러 호스트가 공유하므로, 임의의 호스트에서 전송한 프레임은 물리적으로 다른 모든 호스트에 전달된다.   

(a)에서는 전송 선로에 두 개의 호스트만 연결되므로, 호스트를 구분하기 위한 주소 개념이 필요 없다.   
그러나, (b)에서는 여러 수신 호스트 중에서 프레임의 목적지 호스트를 지칭하기 위한 주소 개념이 필요하다.   
</br>

### 1. 프레임의 종류
데이터 링크 계층의 동작 원리를 이해하려면 프로토콜에서 자주 언급되는 프레임을 먼저 이해해야 한다.   
데이터 링크 계층에서 전송 오류를 해결하는 과정에서 사용하는 프레임에는 정보 프레임, 긍정 응답 프레임, 부정 응답 프레임이 있다.   
</br>

> 정보 프레임(Information Frame)
* 상위 계층이 전송을 요구한 데이터를 수신 호스트에 전송하는 용도로 사용한다.
* 약칭하여 I 프레임으로도 표기하며, 상위 계층에서 보낸 데이터와 함께 **프레임의 순서 번호, 송수신 호스트의 주소 정보** 를 포함한다.
```
순서 번호는 각 정보 프레임에 부여되는 고유의 일련번호로, 수신 호스트가 중복 프레임을 구분할 수 있도록 해준다.
```
</br>

> 긍정 응답 프레임(Positive Acknowledgement Frame)
* 정보 프레임을 수신한 수신 호스트는 맨 먼저 프레임의 내용이 깨졌는지 확인해야 한다.
* 프레임 변형 오류가 발생하지 않으면, 송신 호스트에 해당 프레임을 올바르게 수신했다는 의미로 **ACK 프레임** , 즉, 긍정 응답(Positive Acknowledgement)을 회신한다.
* 긍정 응답 프레임을 수신한 송신 호스트는 데이터가 제대로 도착했음을 확인할 수 있다.
</br>

> 부정 응답 프레임(Negative Acknowledgement Frame)
* 정보 프레임의 전송 과정에서 프레임 변형 오류가 발생하면, 수신 호스트는 송신 호스트에 **NAK 프레임** 을 회신한다. 즉, 부정 응답(Negative Acknowledgement)을 전달하여 송신 호스트가 오류 발생을 인지하고 원래의 정보 프레임을 재전송하도록 요청하는 것이다.
* 재전송 요구를 받은 송신 호스트는 오류가 발생한 프레임을 동일한 순서 번호로 다시 전송해야 한다.
</br>

정보 프레임뿐 아니라, 긍정 응답, 부정 응답 프레임에도 회신하고자 하는 정보 프레임의 순서 번호가 포함된다.   
따라서 정보 프레임의 송신 호스트는 몇 번 프레임이 제대로 도착하고, 몇 번 프레임에서 오류가 발생했는지를 응답 프레임의 순서 번호로 판단할 수 있다.    

이 세 가지 프레임을 사용해 데이터 링크 계층의 전송 프로토콜을 작성할 수 있다.   
프로토콜의 설계 과정에서 다루는 내용은 주로 **오류 제어, 흐름 제어, 양방향·단방향 전송 방식** 등이다.  
일반 통신 환경에서 세 가지 기능을 순차적으로 적용하면서 통신 프로토콜이 어떻게 설계되는지 살펴보자.    
</br>

### 2. 오류·흐름 제어가 없는 프로토콜
먼저, 전송 프로토콜의 구조를 가장 단순하게 하기 위해, 통신 환경을 다음과 같이 정의한다.

- 매우 이상적인 경우를 가정한 것으로, 데이터 전송 과정에서 어떠한 오류도 발생하지 않기 때문에, 오류 제어 기능이 필요 없다.
- 수신 호스트의 버퍼 용량에 제한이 없으므로, 송수신 호스트 사이의 속도 차이로 인해 프레임을 분실할 염려가 없어 흐름 제어 기능도 필요 없다.
</br>

* **단방향 통신** : 데이터는 송신 호스트에서 수신 호스트로만 (한쪽 방향으로만) 전달된다.
* **전송 오류가 없는 물리 매체** : 통신 채널에서는 어떠한 형태의 전송 오류도 발생하지 않는다.
* **무한 개의 수신 버퍼** : 수신 호스트의 버퍼 수는 무한하다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/129848067-3a80b833-7031-4d39-ada0-bb9051de8a1f.png" width="50%" height="50%"></img></br>

송신 호스트가 전송한 프레임은 수신 호스트에 항상 안전하게 도착하므로, 송신 호스트가 프레임을 원하는 만큼 계속 전송할 수 있으며, 구조가 단순하다.   
송신 호스트는 수신 호스트로부터 전송 프레임에 대한 응답을 받지 않아도 되므로, 단순히 정보 프레임을 전송하는 것만으로 송신 호스트의 역할은 완료된다.   

흐름 제어 측면에서는, 수신 호스트의 버퍼 크기가 무한하므로, 분실 오류를 걱정할 필요가 없다.   
따라서 송수신 호스트 사이의 흐름 제어 기능이 필요 없어 상위 계층이 요청한 데이터를 수신 호스트에 송신하는 과정만 필요하다.   

```
그림에서 I(i) 형태로 표시한 내용은 순서 번호가 i인 정보 프레임을 의미하는데,
이것은 이해를 돕기 위한 것이지 순서 번호가 필요하다는 뜻이 아니다.

수신 호스트 입장에서는 프레임이 항상 오류 없이 도착하므로, 송신 호스트에 별도의 응답 프레임을 전송할 필요가 없다.
또한 프레임이 중복해서 도착할 염려도 없으므로 순서 번호로 프레임을 구분하는 기능도 필요 없다.

그림에서는 전송되는 각 프레임이 다르다는 의미에서 표기했을 뿐이며, 순서 번호를 생략해도 프로토콜의 동작에는 영향을 주지 않는다.
```
</br>

수신 호스트는 도착한 프레임을 상위 계층에 전달하는 작업을 통해 수신 작업을 완료할 수 있다.     
</br>

### 3. 오류 제어가 없는 프로토콜
두 번째 가정은, 수신 호스트의 버퍼 개수가 유한하다.   
버퍼 개수가 제한되면, 송신 호스트가 전송한 정보 프레임의 수신 작업이 늦어질 때, 버퍼에 일시적으로 보관할 수 있는 프레임의 개수가 제한된다.   
따라서 버퍼 용량 부족으로 프레임 분실 오류가 발생할 가능성이 있으므로, 송수신 호스트 사이의 흐름 제어 기능이 필요하다.   

* **단방향 통신** : 데이터는 송신 호스트에서 수신 호스트로만(한쪽 방향으로만) 전달된다.
* **전송 오류가 없는 물리 매체** : 통신 채널에서는 어떠한 형태의 전송 오류도 발생하지 않는다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/129849465-4806d740-caab-448d-8ee2-ad52b01c700c.png" width="40%" height="40%"></img></br>
</br>

흐름 제어는 주로 수신 호스트가 송신 호스트의 프레임 전송 시점을 제어하는 형태로 이루어진다.   
가장 간단한 형태는 그림과 같이, 수신 호스트가 이전 프레임의 수신을 완료한 후에 다음 프레임을 전송하도록 송신 호스트에 지시하는 것이다.   
이때 사용하는 프레임이 그림에 표시된 **ACK 프레임** 이다.   

결과적으로 ACK 프레임은 송신 호스트에 이전 프레임을 잘 받았다는 긍정 응답의 기능을 수행하는 동시에,   
다음 프레임을 전송하도록 지시하는 흐름 제어 기능도 수행한다.   

```
위의 프레임 분실 오류가 없는 간단한 흐름 제어 환경에서는 중복 프레임이 발생할 가능성이 없기 때문에 순서 번호를 사용하지 않아도 된다.    
```
</br>

> **정지 대기 프로토콜**
* 송신 호스트가 정보 프레임을 전송하고, 이어서 다음 정보 프레임을 전송하려면 ACK 프레임이 도착하기를 기다려야 한다.   
* 이처럼 각 정보 프레임(크기 1)에 대하여 수신 호스트가 회신하는 ACK 프레임이 도착해야 다음 프레임을 전송할 수 있는 프로토콜 방식을 정지-대기(Stop-and-Wait) 방식이라 한다.   
* 정지-대기 프로토콜은 전송 효율이 매우 떨어지므로, 일반 네트워크 환경에서는 사용하지 않느다.   
</br>

### 4. 단방향 프로토콜
오류 제어와 흐름 제어 기능을 제공하는 환경에서, 다음과 같은 단방향 형식의 통신 환경을 살펴보자.   

* **단방향 통신** : 데이터는 송신 호스트에서 수신 호스트로만(한쪽 방향으로만) 전달된다.
</br>

오류 제어와 흐름 제어가 필요한 통신 환경에서, 송신 호스트가 전송한 정보 프레임에 발생할 수 있는 오류   
1. 프레임 분실 오류, 2. 프레임 변형 오류 </br>
</br>

1. 프레임 분실
- 전송된 프레임이 수신 호스트에 전달하지 못하고, 전송 도중에 사라지는 경우   
  : 수신 호스트는 정보 프레임이 도착하길 무한정 기다린다.   
  : 결과적으로 ACK 프레임을 회신할 수 없으므로 송신 호스트도 ACK 프레임의 도착을 무한정 기다린다.   
  : 이러한 현상을 예방하려면 송신 호스트의 타임아웃 기능이 동작하여, 분실된 프레임을 재전송하는 방식으로 복구한다.   
  (앞 절에서 가정한 오류 제어가 없는 프로토콜에서도 송신 호스트의 타임아웃 기능이 필요할 수 있다.)      
  
- 전송된 프레임은 잘 도착했으나, 수신 호스트에서 보낸 ACK 프레임/NAK 프레임이 사라진 경우   
  : 타임아웃 기능으로 복구한다.   
  
- NAK 프레임이 없는 경우(프로토콜이 없는 경우)   
  : 타임아웃으로 복구한다.   
  
2. 프레임 오류   
- 수신 호스트가 보내는 NAK 프레임을 받은 송신 호스트가 프레임을 재전송하여 복구한다.   
- 수신 호스트가 NAK 프레임을 보내지 않는 프로토콜이라면, 송신 호스트는 타임아웃 기능으로 재전송하여 복구한다.   
</br>

### 4.1 NAK가 없는 경우
그림은 NAK 프레임이 정의되지 않은 프로토콜에서 오류를 복구하는 방법을 보여준다.   

(a) 송신 호스트가 전송한 정보 프레임을 분실한 경우, 수신 호스트는 받은 것이 없으므로 정보 프레임에 대한 응답 프레임을 회신할 수 없다.   

<img src="https://user-images.githubusercontent.com/83942393/130008407-0d61dc9e-d795-4879-8d3d-b3f06e4cc48c.png" width="50%" height="50%"></img></br>
* 문제는 송신 호스트가 ACK 프레임을 수신해야 다음 동작을 취하도록 프로토콜이 설계된 경우, 이를 해결하려면 송신 호스트가 정보 프레임을 전송한 후에 반드시 해당 프레임의 전송 시간을 고려한 제한 시간을 설정하여 타이머(Timer)를 작동시켜야 한다.
* 그림과 같이 송신 호스트는 정보 프레임 I(i)를 전송하면서 바로 타이머를 구동시키고, 임의의 시간까지 ACK 프레임이 도착하지 않으면 시간 초과에 따른 타이머 동작으로 정보 프레임 I(i)를 재전송한다.   
</br>

(b) 수신 호스트가 정보 프레임을 오류 없이 제대로 수신하여 이 프레임에 대한 ACK 프레임을 올바르게 회신하였으나, ACK 프레임이 송신 호스트에 회신되는 과정에서 손실 혹은 변형되어 송신 호스트가 정보 프레임을 올바르게 전달되었다는 사실을 모르는 경우

<img src="https://user-images.githubusercontent.com/83942393/130008409-12712bbd-0ba3-4ecc-90c4-c6f706f908b9.png" width="50%" height="50%"></img></br>
* 송신 호스트 입장에서는 (b)의 상황이 (a)의 상황과 동일하므로, 타이머 동작에 의한 재전송 과정이 필요하다.   
</br>

그림의 (a)는 프레임의 분실 오류에 대한 설명이지만, 프레임 변형 오류에도 동일하게 적용된다.   

<img src="https://user-images.githubusercontent.com/83942393/130009030-936f301e-ef13-48ee-a845-627081a94439.png" width="50%" height="50%"></img></br>

* NAK 프레임이 정의되지 않아 수신 호스트가 프레임 변형 오류에 응답할 방법이 없다.   
* 따라서 그림처럼 송신 호스트의 타임아웃 기능에 의해 오류 복구 기능이 진행되어야 한다.    
</br>

### 4.2 NAK 가 있는 경우

정보 프레임의 전송 과정에서 변형된 프레임을 제대로 수신한 경우에 처리하는 방식은 두 가지이다.   

첫 번째 방식은 변형된 프레임을 무시하는 것으로, 이는 프레임 분실 오류와 동일한 결과를 가져오기 때문에 \[그림 6-4]나 \[그림6-5]의 분실 처리에 따른 타임아웃 기능을 거친다.   

두 번째 방식은 그림의 (a)처럼 NAK 프레임을 이용해 프레임 변형 사실을 송신 호스트에 통보하는 것이다.    

<img src="https://user-images.githubusercontent.com/83942393/130009516-f5d5b039-b573-4062-bf5b-f42d92414230.png" width="60%" height="60%"></img></br>

* 이 방식에서는 프레임 변형 오류와 분실 오류를 명확히 구분하여 처리한다.   
* 직관적으로 보면 NAK 프레임을 이용해 송신 호스트에 재전송을 요구하는 방식이 송신 호스트의 타이머 기능을 이용하는 것보다 효과적일 수 있다. 
* 그러나, 실제 네트워크 프로토콜에서는 정보 프레임에서 변형된 부분이 순서 번호처럼 중요한 정보일 수도 있고, 다른 네트워크 환경 요소에 의해 NAK 프레임을 이용하지 못할 수도 있다.

결론적으로 두 가지 원인이 발생했을 때, 송신 호스트의 재전송 기능으로 오류 복구가 이루어진다.    
하나는 정보 프레임에 대한 수신 호스트의 응답이 없을 때 송신 호스트의 타임아웃 기능에 의해 복구가 이루어지는 경우이고,    
다른 하나는 수신 호스트가 회신한 부정 응답 프레임에 의해 복구가 이루어지는 경우이다.   
</br>

## 💎 02 슬라이딩 윈도우 프로토콜
앞서 설명한 약식 프로토콜에서는 프레임 전송이 한쪽 방향으로만 이루어진다고 가정했지만, 실제 통신 환경에서는 대부분 양방향으로 이루어진다.   
슬라이딩 윈도우 프로토콜 (Sliding Window Protocol) 은 두 호스트 간의 프레임 전송을 위한 일반적인 통신 프로토콜로, 오류 제어와 흐름 제어 기능을 함께 지원한다.   
슬라이딩 윈도우 프로토콜의 원리는 현재 대부분의 통신 프로토콜에서 사용하는 방식으로, 다음과 같은 기본 절차를 따른다.   
</br>

① 정보 프레임을 전송하는 송신 호스트는 보내려는 데이터뿐 아니라, 프레임의 순서 번호, 오류 검출 코드 등을 프레임에 표기한 후에 정해진 순서 번호에 따라 순차적으로 송신한다.   

② 정보 프레임을 받은 수신 호스트는 해당 프레임의 순서 번호에 근거하여 송신 호스트에 응답 프레임을 회신해야 한다.   
일반적으로 응답 프레임의 내용에 포함되는 순서 번호는 정상적으로 수신한 프레임의 번호를 기재하지 않고, 다음에 수신하기를 기대하는 프레임의 번호를 표기한다.   
따라서 긍정 응답 프레임에서 기록된 순서 번호 이전까지의 프레임은 모두 제대로 수신했다는 의미가 된다.   
```
( 참고로 이 책에서 사용하는 순서 번호의 표기 방법은 제대로 수신한 프레임 번호를 기재하는 형식을 사용했는데, 이는 독자들이 이해하기 쉽도록 하기 위함이다 ).
```

③ 송신 호스트는 송신한 정보 프레임을 자신의 내부 버퍼에 유지해야 하며, 이를 **송신 윈도우** 라 한다.   
송신 윈도우에서 대기하는 정보 프레임은 송신 호스트가 수신 호스트에 프레임 전송을 완료했지만, 아직 수신 호스트로부터 긍정 응답을 받지 못한 프레임이다.   

④ 수신 호스트는 수신한 정보 프레임을 보관하기 위해 내부 버퍼인 **수신 윈도우** 를 유지할 수 있다.    
수신 윈도우에는 개념적으로 수신을 기대하는 프레임의 순서 번호가 들어가기 때문에 프로토콜의 동작 방식에 따라 크기가 달라질 수 있다.   
선택적 재전송(Selective Retransmission) 방식에서는 프레임의 도착이 비순서적으로 이루어져도 처리가 가능하기 때문에, 수신 윈도우의 크기가 송신 윈도우의 크기와 동일하다.   
그러나, 고백 N(Go-Back-N) 방식에서는 수신 호스트가 항상 이전에 수신한 프레임의 바로 다음 프레임만 기다리기 때문에, 수신 윈도우의 크기가 1이면 충분하다.   
</br>

### 1. 흐름 제어
슬라이딩 윈도우 프로토콜에서 슬라이딩 윈도우는 '윈도우의 이동'을 의미하며, 이는 흐름 제어 기능을 상징적으로 대변한다.   
즉, 수신 호스트가 연속으로 수신할 수 있는 정보 프레임의 개수를 윈도우의 크기로 지정함으로써, 송신 호스트의 프레임 전송 속도를 제어한다.   
</br>

### 1.1 순서 번호
정보 프레임의 내용에는 프레임별로 고유하게 부여되는 **순서 번호** (Sequence Number)라는 일련번호가 부여된다.   
이 번호는 0부터 임의의 최댓값까지 정의되는데, 최댓값 이후에는 다시 0번으로 되돌아오는 순환 방식으로 할당된다.   
따라서 프로토콜을 설계할 떄는 현재 처리되고 있는 다른 프레임에 같은 순서 번호를 부여하지 않도록 주의해야 한다.   
이런 원칙에 위배되지 않으려면 기본적으로 순서 번호의 최댓값이 송신 윈도우의 크기보다는 커야 한다.   

정보 프레임의 내용에는 순서 번호를 위한 공간이 확보되어 있는데, 할당된 공간의 크기가 n비트라고 가정하면, 프로토콜에서 사용할 수 있는 순서 번호의 범위는 0 ~ 2^n -1 이다.   
정지 - 대기 방식의 프로토콜은 슬라이딩 윈도우 프로토콜에서 가장 기본이 되는 n 값이 1 인 경우이다.   
</br>

### 1.2 윈도우의 크기
슬라이딩 윈도우 프로토콜은 원리상 흐름 제어를 지원하기 위해 제공하는 기능이다. (내부 버퍼의 최대 크기를 넘지 않게 프레임을 보내기 위한)   
기본 원리는 임의의 시점에서 송신 호스트가 수신 호스트로부터 긍정 응답 프레임을 받지 않고도 전송할 수 있는 정보 프레임의 최대 개수, 즉 **윈도우 크기** (Window Size)를 규정하기 위함이다.    
송신 호스트가 관리하는 송신 윈도우에 보관된 프레임은 수신 호스트에 전송되었으나 아직 긍정 응답 프레임을 받지 못한 프레임이다.   

윈도우에 포함되는 정보 프레임의 관리는 순서 번호를 기반으로 이루어지는데, 이들 **순서 번호의 묶음이 결과적으로 윈도우** 가 된다.  
송신 윈도우에 보관된 프레임은 낮은 순서 번호부터 차례로 처리된다.
즉, 긍정 응답 프레임이 회신되고 오류 없이 수신 호스트에 전달되었음을 확인함에 따라 윈도우에 새로 추가될 정보 프레임의 순서 번호도 순차적으로 높은 번호로 이동한다.   
</br>

```
ex) 그림은 송신 윈도우의 최대 크기를 3으로 가정하였을 때, 슬라이딩 윈도우 프로토콜의 동작 과정을 보여준다.
```      

<img width="665" alt="스크린샷 2021-08-19 오후 2 37 25" src="https://user-images.githubusercontent.com/83942393/130013770-ff9a2b0b-1b6c-47fe-8944-36e8814e5a65.png"></br>

(a)는 0번, 1번, 2번 등 세 개의 정보 프레임을 전송한 후에, 아직 해당 정보 프레임에 대한 ACK 프레임을 받지 못한 경우이다.  

- 이때, 윈도우의 크기가 3으로 제한되기 때문에, 네 번째 정보 프레임인 3번 프레임은 전송할 수 없다.    
- 3번 프레임을 전송하려면 0번 프레임에 대한 긍정 응답의 처리가 완료되어야 한다.    

(b) 수신 호스트로부터 0번에 대한 ACK 프레임이 돌아오면 프레임 처리가 완료된 것이기 때문에, 송신 윈도우에는 (b)처럼 1번과 2번 프레임만 존재한다.   
(c) 윈도우의 최대 크기가 3이므로, 3번 프레임을 전송할 수 있다.    
(d) 다시 1번 프레임에 대한 ACK 프레임이 도착하면 이와 같이 되고,    
(e) 처럼 4번 프레임까지 전송할 수 있다.   
(f) 는 2번과 3번 프레임에 대한 ACK 프레임이 도착한 직후이다.   

이후의 그림은 없지만 5번과 6번의 정보 프레임을 전송할 수 있다.    
그림에서 순서 번호의 최댓값을 9라고 가정하면, 9번 정보 프레임 다음에 전송되는 프레임은 순서 번호가 0번이 된다.    
</br>

```
위의 과정을 다르게 표현하려면 다음 아래 그림과 같다.
( 송신 호스트와 수신 호스트가 정보 프레임과 응답 프레임을 전송하는 과정이 더 직관적으로 표기되어 이해하기 쉽다. )
```   

<img src="https://user-images.githubusercontent.com/83942393/130042076-6197e6b5-b0b3-46ec-a9d7-d697c71ae234.jpg" width="40%" height="40%"></img></br>
</br>

### 2. 연속형 전송 
정지-대기 방식의 프로토콜은 송신 윈도우의 크기가 1인 특수한 경우이다.  
송신 호스트와 수신 호스트 사이의 물리적 거리 차로 인해 프레임의 전송 시간이 상대적으로 오래 걸리는 환경에서, 윈도우 크기가 1이면 전송 효율이 극단적으로 떨어진다.   
이를 해결하려면, ACK 프레임을 받지 않고도 여러 정보 프레임을 연속으로 전송할 수 있어야 하는데, 이러한 방식을 **연속형 전송** (Pipelining)이라 한다.   

전송된 정보 프레임에 대한 ACK 프레임의 회신이 이루어지지 않은 상태에서, 다음 프레임을 전송하는 방식은 전송 오류가 발생할 가능성이 적은 환경에서는 상당히 효율적이다.   
하지만, 전송된 여러 정보 프레임의 일부에 오류가 발생하면, 이를 해결하는 방법론에 따라서 전송 효율이 영향을 받는다.   
연속형 전송 방식의 오류 해결 방법에는 **고백 N 방식** 과 **선택적 재전송** 방식이 있다.   

```
ex) 윈도우의 최대 크기가 8인 환경에서, 송신 호스트가 10~17번 정보 프레임을 전송하는 경우를 가정해보자.
12번 프레임에만 오류가 발생하고, 나머지는 모두 오류 없이 수신되었다.
```
</br>

### 2.1 고백 N(Go-Back-N) 방식
: 오류 복구 과정에서 오류가 발생한 12번 프레임을 포함해, 이후에 전송된 모든 정보 프레임을 재전송하는 방식이다.   

그림처럼 고백 N 방식은 오류가 발생한 프레임뿐 아니라, 정상적으로 수신한 프레임까지 재전송한다는 문제점이 있다.  

<img src="https://user-images.githubusercontent.com/83942393/130015969-9c796fb5-e9c0-47dd-a0ce-c04da1361363.png" width="50%" height="50%"></img></br>

따라서 직관적인 관점에서 보면 매우 비효율적이라고 생각될 수 있으나, 송수신 호스트 사이의 전송 지연 등에 따라서는 효과적인 처리 방법이 될 수 있다.     

그림에서 부정 응답 기능을 수행하는 NAK 프레임이 전송되는 원인을 두 가지로 나누어 생각해볼 수 있다.    

하나는 12번 정보 프레임이 수신 호스트에 도착하였으나, 내용이 변질된 경우이고,    
다른 하나는 12번 프레임이 도착하지 않은 경우이다.   

12번 프레임이 도착하지 않은 경우를 살펴보자.   
수신 호스트에 10번과 11번 프레임이 도착한 후에 13번, 14번 15번 순으로 프레임이 도착하면, 수신 호스트는 중간의 12번 프레임을 분실했음을 인지하여 NAK 프레임을 전송할 수 있다.   
만일 프로토콜에서 NAK 프레임을 사용하지 않고, ACK 프레임만으로 프로토콜을 작성한다면 송신 호스트가 12번 전송 프레임의 긍정 응답 프레임을 받을 수 없으므로, 타임 아웃 과정에 의해 12번 프레임부터 다시 전송해야 한다.   

그림에서 볼 수 있듯이, 수신 호스트가 전송한 ACK(17) 프레임은 17번 프레임만이 제대로 도착했다는 의미가 아니고, 17번 프레임을 포함하여 이전 모두의 프레임들이 제대로 도착했음을 나타낸다.  

그림에서는 설명의 편의를 위해 송신 호스트와 수신 호스트의 전송 시점이 겹치지 않도록 하였는데, 실제 환경에서는 그림보다 짧은 시간에 송수신 과정이 이루어지므로, 프레임의 전송 순서도 이와는 형태가 다를 수 있다.   
</br>

### 2.2 선택적 재전송(Selective Retransmission) 방식
: 그림에서 12번 정보 프레임만 재전송하고 수신 호스트가 제대로 수신한 13~17번 정보 프레임은 정상적으로 처리하여 재전송되지 않도록, 오류가 발생한 프레임만 선택적으로 복구하는 방식이다. 
```
직관적인 관점에서 고백 N 방식의 문제점 : 수신 호스트가 올바르게 수신한 정보 프레임도 오류로 처리해 재전송한다는 것.
```

그림은 부정 응답 프레임을 사용해, 오류가 발생한 정보 프레임을 처리하는 경우이다.   

<img src="https://user-images.githubusercontent.com/83942393/130017071-7e81a47d-2cd1-411b-8c99-72c9b6aa2d18.png" width="60%" height="60%"></img></br>

그림처럼 수신 호스트가 NAK(12) 프레임을 전송한 후에는 I(12)번 프레임의 처리를 완료할 때까지 다음 정보 프레임에 대한 긍정 응답 프레임을 전송하지 않도록 주의해야 한다.   

```
그림에서 설명하지 않았지만, 프로토콜에서 NAK 프레임이 정의되지 않으면 그 처리 과정이 약간 달라질 수 있다.
NAK 프레임이 없는 경우의 기본 동작 원리는 제대로 전달된 모든 정보 프레임에 대해 수신 호스트가 개별적으로 ACK 프레임을 전송해야 한다는 것이다.
```
</br>

> 고백 N 방식과 선택적 재전송 방식의 차이는 수신 윈도우 크기의 차이로도 설명할 수 있다.   

**고백 N 방식에서는 수신 윈도우의 크기가 1이다.**   
* 수신 호스트가 임의의 앞선 순서 번호를 갖는 정보 프레임이 처리될 때 까지 다음 정보 프레임을 모두 버리는 방식으로 처리되므로, 수신 윈도우에는 현재 처리중인 프레임 한개만 존재한다.
</br>

**선택적 재전송 방식은 수신 윈도우의 크기가 송신 윈도우의 크기와 같다고 볼 수 있다.**    
* 앞선 정보 프레임에 대한 처리가 이루어지지 않았어도, 오류 없이 수신된 모든 정보 프레임을 수신 윈도우에 보관한다.
* 다시 말해서 선택적 재전송 방식에서는 프레임의 도착 순서가 순서 번호와 일치하지 않을 수 있다.
</br>

### 3. 피기배킹
양방향 전송 기능을 갖춘 채널 방식에서는 송신 호스트와 수신 호스트의 구분 없이, 양방향으로 동시에 정보 프레임과 응답 프레임을 교차하여 전송할 수 있다.   
정보 프레임의 구조를 적당히 조정해 재정의하면, 정보 프레임을 전송하면서 응답 기능까지 함께 수행할 수 있다.   
이런 방식으로 프로토콜을 작성하면, 응답 프레임의 전송 횟수를 줄이는 효과가 있어, 전송 효율을 높일 수 있는데, 이를 **피기배킹** (Piggybacking)이라 한다.   

피기배킹을 지원하려면, 정보 프레임의 구조를 확장해 두 종류의 순서 번호를 모두 표기해야 한다.    
즉, 피기배킹 프로토콜에는 전송할 데이터와 해당 데이터의 순서 번호는 물론이고, 현재까지 제대로 수신한 프레임의 순서 번호까지 포함된다.   
이렇게 함으로써 정보 프레임의 전송과 응답 프레임의 회신을 한 번에 처리할 수 있다.   
</br>

```
그림은 피기배킹 방식을 사용하는 프로토콜과 그렇지 않은 프로토콜의 동작 과정을 비교해 설명하고 있다.  
```
왼쪽에서 0번과 1번 정보 프레임을 전송하고, 오른쪽에서도 0번과 1번의 순서대로 정보 프레임을 전송하는 경우를 가정한다.   


![image](https://user-images.githubusercontent.com/83942393/130018685-8addb257-ff61-4454-91f9-bdb18e725701.png)

![image](https://user-images.githubusercontent.com/83942393/130018693-00067f41-e3e5-43a6-9ec2-e5774f2173eb.png)

(a) 개별 정보 프레임에 대해 긍정 응답 혹은 부정 응답 프레임이 순서 번호와 함께 별도로 처리되고 있다.    
(b) 피기배킹을 이용하면 이처럼 더 효과적으로 개선하여 전송할 수 있다.    
```
정보 프레임의 표기 방식은 I(i, j)로 재정의되었다.
이때 첫 번째 순서 번호 i 는 자신이 전송하는 데이터의 순서 번호를 의미하고, j는 제대로 수신한 프레임의 순서 번호를 의미한다. 
```
</br>

* 응답 프레임을 전송할 시점에 전송할 데이터 프레임이 있으면 피기배킹 기능을 사용할 수 있지만, 정보 프레임이 없으면 응답 프레임만 전송해야 한다. 
* 그러나 현재는 정보 프레임이 없지만 잠시 후에 전송할 정보 프레임이 생길 가능성이 있으면, 응답 프레임의 회신을 잠시 늦춰 피기배킹 방식으로 전송할 수 있다. 
* 이때는 얼마나 기다리게 할 것인가가 시스템의 성능에 영향을 준다.
</br>

## 💎 03 HDLC 프로토콜
* ISO 에서 IBM SNA의 데이터 링크 프로토콜로 사용되는 SDLC(Synchronous Data Link Control) -> HDLC(High-level Data Link Control) 로 발전
* CCITT에서 HDLC를 다시 수정하여 x.25에서 사용할 수 있도록 LAP(Link Access Procedure)로 발전
* 다시 LAPB(Link Access Procedure Balanced)로 향상
* 이들 프로토콜은 모두 같은 뿌리에서 시작해 기본 특성이 유사하다.
</br>

* **HDLC** 프로토콜은 컴퓨터가 일대일 혹은 일대다로 연결된 환경에서 데이터 송수신 기능을 제공한다.
* 데이터 통신을 위해 연결된 호스트들은 주국(Primary Station)과 종국(Secondary Station)으로 구분되고, 다시 이들의 기능을 모두 지닌 혼합국(Combination Station)으로 정의될 수 있다.
* 주국에서 전송되는 메시지를 명령(Command)이라 정의하며, 이에 대한 종국의 회신을 응답(Response)이라 한다.
</br>

![image](https://user-images.githubusercontent.com/83942393/130023656-cf2e7612-72b6-4a1d-94dc-620b02dc0601.png)   
</br>

### 1. 프레임의 구조
그림은 HDLC 프레임의 구조로, 상단의 숫자는 비트 수이다.    
프레임의 좌우에 위치한 01111110 플래그는 프레임의 시작과 끝을 구분한다.   

<img src="https://user-images.githubusercontent.com/83942393/130021261-1da01f87-7339-4a6d-a19b-6297520f6d09.png" width="60%" height="60%"></img></br>

* Address(주소) : 일대다로 연결된 환경에서 특정 호스트를 구분하여 지칭하는 목적으로 사용한다. 주국에서 정보 프레임을 전송할 때는 수신 호스트인 종국 주소를 표기하며, 종국에서 전송할 때는 송신 호스트인 자신의 주소가 기록된다. 일대일 환경에서는 명령과 응답을 구분하는 용도로 사용할 수도 있다.
* Data(데이터) : 가변 크기의 전송 데이터가 포함되는데, 상위 계층인 네트워크 계층에서 보내진 패킷이 캡슐화된다.
* Checksum(체크섬) : CRC-CCITT 를 생성 다항식으로 하는 오류 검출 용도로 사용된다. 
</br>

### 2. 프레임의 종류
그림처럼 프레임의 용도는 Control 필드 값에 따라 세 종류로 구분된다.   
즉, 네트워크 계층에서 내려온 패킷을 전송하기 위한 정보 프레임, 정보 프레임에 대한 응답 기능을 수행하는 감독 프레임, 연결 설정의 제어와 관련된 비번호 프레임으로 나뉜다.   
</br>

### 2.1 정보 프레임
네트워크 계층의 데이터 전송을 위해 정의된 정보 프레임(Information Frame)은 그림의 (a)처럼 3비트의 순서 번호(Seq)를 이용한 슬라이딩 윈도우 프로토콜을 사용한다.
순서 번호는 비트 수가 3개이므로 0~7의 순서 번호 8개를 순환하여 사용한다.

* **Seq** : 정보 프레임의 송신용 순서 번호로 사용한다.
* **Next** : 피기배킹을 이용한 응답 기능으로 사용한다. 이 값은 제대로 수신된 프레임 번호가 아닌, 다음에 수신을 기대하는 프레임 번호이다. 따라서 이 번호 이전까지의 프레임은 모두 오류없이 수신되었음을 의미한다. 
* **P/F** : 값이 1로 지정되었을 경우에 한하여, Poll 혹은 Final의 의미를 갖는다. 일반적으로 주국의 명령 프레임에서 사용될 때는 Poll 이라 하고, 종국의 응답 프레임에서 사용될 때는 Final이라 한다.
```
하나의 주국 컴퓨터가 다수의 종국 컴퓨터를 제어하기 위한 용도이며, 주국에서 종국에 데이터 전송을 허가할 때 사용한다.
즉, 주국에서 데이터를 보내고자 하는 종국이 있는지 확인할 때는 Poll(여론 조사)의 의미로 1 값을 지정하며, 종국에서 주국으로 데이터를 전송할 때는
Final의 의미로 사용한다.
```
</br>

### 2.2 감독 프레임
감독 프레임은 정보 프레임에 대한 응답 기능을 수행하는 프레임이다.   
크게 긍정 응답 프레임과 부정 응답 프레임으로 구분된다.   
프레임의 세부 종류는 Type 필드 값에 따라 다음의 네 가지로 네 가지로 구분된다.   

<img width="586" alt="스크린샷 2021-08-19 오후 4 31 58" src="https://user-images.githubusercontent.com/83942393/130026999-58a86bc3-5565-4ca5-9de5-87f5742582d5.png">  

* **Type 0** : RR로 정의된 긍정 응답 프레임. 다음에 수신을 기대하는 프레임 번호를 Next 필드에 표시한다.
* **Type 1** : REJ로 정의된 부정 응답 프레임. Next 필드에는 재전송되어야 하는 프레임의 번호를 표시한다. 따라서 송신 호스트는 Next 필드의 번호로 시작하는 프레임부터 재전송해야 한다.
* **Type 2** : RNR로 정의된 응답 프레임으로 흐름 제어 기능 까지 제공한다. 즉, Next 필드에 표시한 순서 번호를 갖는 정보 프레임의 바로 앞 번호까지 제대로 수신되었다는 긍정 응답과 함께, 송신 호스트에 송신을 중지하도록 요구한다. 송신 호스트에 다시 전송을 요구할 때는 RR, REJ 혹은 기타의 제어 프레임을 전송하면 된다.
* **Type 3** : SREJ로 정의된 프레임으로, 선택적 재전송 방식에서 부정 응답 기능을 지원한다. 즉, Next 필드의 순서 번호를 갖는 특정 프레임에 대해 재전송 요구 기능을 갖는다.
</br>

### 2.3 비번호 프레임
: 순서 번호가 없는 프레임을 정의한다.   
* 주로 연결 제어 등의 용도로 사용하지만, 비연결형 데이터 전송을 위해 사용하기도 한다.
* 비번호 프레임은 Type과 Modifier 필드를 합해 총 5비트로 다음과 같은 프레임을 정의한다.
</br>

* **SABM** (Set ABM) : 비동기 균형(Asynchronous Balanced) 모드의 연결 설정을 요구한다.
* **SNRM** (Set NRM) : 정규 응답(Normal Reponse) 모드의 연결 설정을 요구한다.
* **SARM** (Set ARM) : 비동기 응답(Asynchronous Response) 모드의 연결 설정을 요구한다.
* **DISC** (DISConnect) : 연결 설정 해제를 요구한다.
* **RSET** (ReSET) : 비정상적인 프로토콜의 동작에 따른 리셋 기능을 수행한다.
* **FRMR** (FRaMe Reject) : 비정상적인 프레임의 수신을 거부한다.
* **UA** (Unnumbered ACK) : 비번호 프레임에 대한 응답 기능을 수행한다.

SNRM, SABM, SARM은 연결 설정을 요구할 때 사용하며, 표와 같은 세 가지 연결 모드에 적용된다.    

| 연결 모드 | 설명 |
|:----------|:----------|
| 정규 응답(Normal Response) - SNRM | 불균형 모드를 의미하기 때문에 호스트 하나는 주국으로 동작하고, 다른 하나는 종국으로 동작한다. </br> SNRM을 이용하여 연결 설정을 요구하며, 종국에서 데이터를 전송하려면 반드시 주국의 허락을 받아야 한다. |
| 비동기 균형(Asynchronous(동시에 존재\[발생]하지 않는) Balanced) - SABM| 두 개의 호스트가 동일한 능력을 갖는 혼합국으로 동작하며, 양쪽에서 명령과 응답을 모두 전송할 수 있다.  </br> 따라서 둘 중 임의의 호스트에서 SABM을 이용한 연결 설정 요구를 수행할 수 있다. |
| 비동기 응답(Asynchronous Response) - SARM | 불균형 모드이나 종국이 주국의 허락 없이도 데이터를 전송할 수 있는 권한을 갖는다.  </br> 즉, 주국의 허가가 없어도 (주국에 의한 P/F 비트의 Poll 지정이 없어도) 종국에서 먼저 SARM 응답을 보낼 수 있다. |

* 사용 중인 연결을 해제하려면 DISC 프레임을 이용하며, UA는 비번호 프레임에 대한 긍정 응답으로 이용한다.
* FRMR은 프레임에 오류는 없지만, 연결 상태의 논리적인 의미가 상실된 경우에 사용된다.
* RSET 명령은 종국에 하드웨어 제어 기능을 리셋하도록 통보하는 용도로 사용한다.
</br>

### 3. LAP 프로토콜
LAP(Link Access Protocol)은 비동기 응답 모드인 ARM 으로 동작하는 프로토콜이다.   

<img width="451" alt="스크린샷 2021-08-19 오후 4 35 05" src="https://user-images.githubusercontent.com/83942393/130027443-3f3642fb-999f-45f8-abc1-d9f27a99e096.png">
<img width="462" alt="스크린샷 2021-08-19 오후 4 34 08" src="https://user-images.githubusercontent.com/83942393/130027319-43fa5919-8003-421b-8b51-a366d4cb084a.png">


연결 설정 과정은 그림의 (a)처럼 주국에서 전송된 SARM 명령에 대하여 종국에서 UA 응답을 전송함으로써 완료된다.   

LAP는 비동기 응답 모드로 동작하기 때문에 그림의 (b)처럼 종국에서 주국으로 SARM 응답을 전송하여 연결 설정을 요구할 수 있다.   
종국으로부터 SARM 응답을 받은 주국은 SARM 명령을 전송학고, 최종적으로 종국에서 UA 응답을 전송함으로써 연결 설정이 완료된다.   
이와 같이 종국에서 시작된 연결 설정은 3단계로 이루어지는 효과가 발생한다.  

연결을 해제할 경우에도 주국으로부터 DISC 명령이 발생하면, 종국에서 UA 응답을 전송하는 것으로 해제가 완료된다.   
그러나 그림의 (b)와 같은 원리에 의해 종국에서의 DISC 응답에 의한 연결 해제는 3단계로 이루어진다.   
</br>

### 4. LAPB 프로토콜
: 양쪽 호스특가 혼합국으로 동작하기 때문에 누구나 먼저 명령을 전송할 수 있다.   

그림은 비동기 균형 모드의 연결을 설정하기 위해 오른쪽 호스트가 왼쪽 호스트에 SABM 명령을 전송하는 경우이다.   

<img width="467" alt="스크린샷 2021-08-19 오후 4 34 16" src="https://user-images.githubusercontent.com/83942393/130027307-ad74cd30-29fb-43bb-be3e-f7311187fe6a.png">

왼쪽 호스트에서는 UA 응답을 전송함으로써 계층 2의 연결 설정이 완료된다.    

연결 해제의 경우에도 임의의 호스트에서 DISC 명령을 전송하고, 이를 수신한 측에서 UA 응답을 함으로써 완료된다.    

</br>
</br>

![image](https://user-images.githubusercontent.com/83942393/130029188-85e4f106-7925-4692-b18a-6bb5c75a81fe.png)

















